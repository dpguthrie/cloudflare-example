var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require3() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedAsync(name) {
  const fn = /* @__PURE__ */ notImplemented(name);
  fn.__promisify__ = () => /* @__PURE__ */ notImplemented(name + ".__promisify__");
  fn.native = fn;
  return fn;
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedAsync, "notImplementedAsync");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance;
var init_performance = __esm({
  "node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options) {
        this.name = name;
        this.startTime = options?.startTime || _performanceNow();
        this.detail = options?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e) => e.entryType !== "resource" || e.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type) {
        return this._entries.filter((e) => e.name === name && (!type || e.entryType === type));
      }
      getEntriesByType(type) {
        return this._entries.filter((e) => e.entryType === type);
      }
      mark(name, options) {
        const entry = new PerformanceMark(name, options);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start,
          detail: {
            start,
            end
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn) {
        return fn;
      }
      runInAsyncScope(fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now2 = Date.now();
      const seconds = Math.trunc(now2 / 1e3);
      const nanos = now2 % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds - startTime[0];
        let diffNanos = nanos - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir4, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env2) {
        return 1;
      }
      hasColors(count3, env2) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str2, encoding, cb) {
        if (str2 instanceof Uint8Array) {
          str2 = new TextDecoder().decode(str2);
        }
        try {
          console.log(str2);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/tty.mjs
var isatty, tty_default;
var init_tty = __esm({
  "node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
    init_read_stream();
    init_write_stream();
    isatty = /* @__PURE__ */ __name(function() {
      return false;
    }, "isatty");
    tty_default = {
      ReadStream,
      WriteStream,
      isatty
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION;
var init_node_version = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NODE_VERSION = "22.14.0";
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    init_node_version();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value = this[prop];
          if (typeof value === "function") {
            this[prop] = value.bind(this);
          }
        }
      }
      // --- event emitter ---
      emitWarning(warning2, type, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type ? `${type}: ` : ""}${warning2}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      // --- stdio (lazy initializers) ---
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      // --- cwd ---
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      // --- dummy props and getters ---
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return `v${NODE_VERSION}`;
      }
      get versions() {
        return { node: NODE_VERSION };
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      // --- noop methods ---
      ref() {
      }
      unref() {
      }
      // --- unimplemented methods ---
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      // --- attached interfaces ---
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      // --- undefined props ---
      mainModule = void 0;
      domain = void 0;
      // optional
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      // internals
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, workerdProcess, isWorkerdProcessV2, unenvProcess, exit, features, platform, env, hrtime3, nextTick, _channel, _disconnect, _events, _eventsCount, _handleQueue, _maxListeners, _pendingMessage, _send, assert2, disconnect, mainModule, _debugEnd, _debugProcess, _exiting, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _linkedBinding, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, abort, addListener, allowedNodeEnvironmentFlags, arch, argv, argv0, availableMemory, binding, channel, chdir, config, connected, constrainedMemory, cpuUsage, cwd, debugPort, dlopen, domain, emit, emitWarning, eventNames, execArgv, execPath, exitCode, finalization, getActiveResourcesInfo, getegid, geteuid, getgid, getgroups, getMaxListeners, getuid, hasUncaughtExceptionCaptureCallback, initgroups, kill, listenerCount, listeners, loadEnvFile, memoryUsage, moduleLoadList, off, on, once, openStdin, permission, pid, ppid, prependListener, prependOnceListener, rawListeners, reallyExit, ref, release, removeAllListeners, removeListener, report, resourceUsage, send, setegid, seteuid, setgid, setgroups, setMaxListeners, setSourceMapsEnabled, setuid, setUncaughtExceptionCaptureCallback, sourceMapsEnabled, stderr, stdin, stdout, throwDeprecation, title, traceDeprecation, umask, unref, uptime, version, versions, _process, process_default;
var init_process2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    workerdProcess = getBuiltinModule("node:process");
    isWorkerdProcessV2 = globalThis.Cloudflare.compatibilityFlags.enable_nodejs_process_v2;
    unenvProcess = new Process({
      env: globalProcess.env,
      // `hrtime` is only available from workerd process v2
      hrtime: isWorkerdProcessV2 ? workerdProcess.hrtime : hrtime,
      // `nextTick` is available from workerd process v1
      nextTick: workerdProcess.nextTick
    });
    ({ exit, features, platform } = workerdProcess);
    ({
      env: (
        // Always implemented by workerd
        env
      ),
      hrtime: (
        // Only implemented in workerd v2
        hrtime3
      ),
      nextTick: (
        // Always implemented by workerd
        nextTick
      )
    } = unenvProcess);
    ({
      _channel,
      _disconnect,
      _events,
      _eventsCount,
      _handleQueue,
      _maxListeners,
      _pendingMessage,
      _send,
      assert: assert2,
      disconnect,
      mainModule
    } = unenvProcess);
    ({
      _debugEnd: (
        // @ts-expect-error `_debugEnd` is missing typings
        _debugEnd
      ),
      _debugProcess: (
        // @ts-expect-error `_debugProcess` is missing typings
        _debugProcess
      ),
      _exiting: (
        // @ts-expect-error `_exiting` is missing typings
        _exiting
      ),
      _fatalException: (
        // @ts-expect-error `_fatalException` is missing typings
        _fatalException
      ),
      _getActiveHandles: (
        // @ts-expect-error `_getActiveHandles` is missing typings
        _getActiveHandles
      ),
      _getActiveRequests: (
        // @ts-expect-error `_getActiveRequests` is missing typings
        _getActiveRequests
      ),
      _kill: (
        // @ts-expect-error `_kill` is missing typings
        _kill
      ),
      _linkedBinding: (
        // @ts-expect-error `_linkedBinding` is missing typings
        _linkedBinding
      ),
      _preload_modules: (
        // @ts-expect-error `_preload_modules` is missing typings
        _preload_modules
      ),
      _rawDebug: (
        // @ts-expect-error `_rawDebug` is missing typings
        _rawDebug
      ),
      _startProfilerIdleNotifier: (
        // @ts-expect-error `_startProfilerIdleNotifier` is missing typings
        _startProfilerIdleNotifier
      ),
      _stopProfilerIdleNotifier: (
        // @ts-expect-error `_stopProfilerIdleNotifier` is missing typings
        _stopProfilerIdleNotifier
      ),
      _tickCallback: (
        // @ts-expect-error `_tickCallback` is missing typings
        _tickCallback
      ),
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      arch,
      argv,
      argv0,
      availableMemory,
      binding: (
        // @ts-expect-error `binding` is missing typings
        binding
      ),
      channel,
      chdir,
      config,
      connected,
      constrainedMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      domain: (
        // @ts-expect-error `domain` is missing typings
        domain
      ),
      emit,
      emitWarning,
      eventNames,
      execArgv,
      execPath,
      exitCode,
      finalization,
      getActiveResourcesInfo,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getMaxListeners,
      getuid,
      hasUncaughtExceptionCaptureCallback,
      initgroups: (
        // @ts-expect-error `initgroups` is missing typings
        initgroups
      ),
      kill,
      listenerCount,
      listeners,
      loadEnvFile,
      memoryUsage,
      moduleLoadList: (
        // @ts-expect-error `moduleLoadList` is missing typings
        moduleLoadList
      ),
      off,
      on,
      once,
      openStdin: (
        // @ts-expect-error `openStdin` is missing typings
        openStdin
      ),
      permission,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      reallyExit: (
        // @ts-expect-error `reallyExit` is missing typings
        reallyExit
      ),
      ref,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      send,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setMaxListeners,
      setSourceMapsEnabled,
      setuid,
      setUncaughtExceptionCaptureCallback,
      sourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      throwDeprecation,
      title,
      traceDeprecation,
      umask,
      unref,
      uptime,
      version,
      versions
    } = isWorkerdProcessV2 ? workerdProcess : unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// node_modules/@vercel/functions/headers.js
var require_headers = __commonJS({
  "node_modules/@vercel/functions/headers.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export4 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    }, "__export");
    var __copyProps4 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: /* @__PURE__ */ __name(() => from[key], "get"), enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS3 = /* @__PURE__ */ __name((mod) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod), "__toCommonJS");
    var headers_exports = {};
    __export4(headers_exports, {
      CITY_HEADER_NAME: /* @__PURE__ */ __name(() => CITY_HEADER_NAME, "CITY_HEADER_NAME"),
      COUNTRY_HEADER_NAME: /* @__PURE__ */ __name(() => COUNTRY_HEADER_NAME, "COUNTRY_HEADER_NAME"),
      EMOJI_FLAG_UNICODE_STARTING_POSITION: /* @__PURE__ */ __name(() => EMOJI_FLAG_UNICODE_STARTING_POSITION, "EMOJI_FLAG_UNICODE_STARTING_POSITION"),
      IP_HEADER_NAME: /* @__PURE__ */ __name(() => IP_HEADER_NAME, "IP_HEADER_NAME"),
      LATITUDE_HEADER_NAME: /* @__PURE__ */ __name(() => LATITUDE_HEADER_NAME, "LATITUDE_HEADER_NAME"),
      LONGITUDE_HEADER_NAME: /* @__PURE__ */ __name(() => LONGITUDE_HEADER_NAME, "LONGITUDE_HEADER_NAME"),
      POSTAL_CODE_HEADER_NAME: /* @__PURE__ */ __name(() => POSTAL_CODE_HEADER_NAME, "POSTAL_CODE_HEADER_NAME"),
      REGION_HEADER_NAME: /* @__PURE__ */ __name(() => REGION_HEADER_NAME, "REGION_HEADER_NAME"),
      REQUEST_ID_HEADER_NAME: /* @__PURE__ */ __name(() => REQUEST_ID_HEADER_NAME, "REQUEST_ID_HEADER_NAME"),
      geolocation: /* @__PURE__ */ __name(() => geolocation2, "geolocation"),
      ipAddress: /* @__PURE__ */ __name(() => ipAddress2, "ipAddress")
    });
    module.exports = __toCommonJS3(headers_exports);
    var CITY_HEADER_NAME = "x-vercel-ip-city";
    var COUNTRY_HEADER_NAME = "x-vercel-ip-country";
    var IP_HEADER_NAME = "x-real-ip";
    var LATITUDE_HEADER_NAME = "x-vercel-ip-latitude";
    var LONGITUDE_HEADER_NAME = "x-vercel-ip-longitude";
    var REGION_HEADER_NAME = "x-vercel-ip-country-region";
    var POSTAL_CODE_HEADER_NAME = "x-vercel-ip-postal-code";
    var REQUEST_ID_HEADER_NAME = "x-vercel-id";
    var EMOJI_FLAG_UNICODE_STARTING_POSITION = 127397;
    function getHeader(headers, key) {
      return headers.get(key) ?? void 0;
    }
    __name(getHeader, "getHeader");
    function getHeaderWithDecode(request, key) {
      const header = getHeader(request.headers, key);
      return header ? decodeURIComponent(header) : void 0;
    }
    __name(getHeaderWithDecode, "getHeaderWithDecode");
    function getFlag(countryCode) {
      const regex = new RegExp("^[A-Z]{2}$").test(countryCode);
      if (!countryCode || !regex)
        return void 0;
      return String.fromCodePoint(
        ...countryCode.split("").map((char) => EMOJI_FLAG_UNICODE_STARTING_POSITION + char.charCodeAt(0))
      );
    }
    __name(getFlag, "getFlag");
    function ipAddress2(input) {
      const headers = "headers" in input ? input.headers : input;
      return getHeader(headers, IP_HEADER_NAME);
    }
    __name(ipAddress2, "ipAddress");
    function getRegionFromRequestId(requestId) {
      if (!requestId) {
        return "dev1";
      }
      return requestId.split(":")[0];
    }
    __name(getRegionFromRequestId, "getRegionFromRequestId");
    function geolocation2(request) {
      return {
        // city name may be encoded to support multi-byte characters
        city: getHeaderWithDecode(request, CITY_HEADER_NAME),
        country: getHeader(request.headers, COUNTRY_HEADER_NAME),
        flag: getFlag(getHeader(request.headers, COUNTRY_HEADER_NAME)),
        countryRegion: getHeader(request.headers, REGION_HEADER_NAME),
        region: getRegionFromRequestId(
          getHeader(request.headers, REQUEST_ID_HEADER_NAME)
        ),
        latitude: getHeader(request.headers, LATITUDE_HEADER_NAME),
        longitude: getHeader(request.headers, LONGITUDE_HEADER_NAME),
        postalCode: getHeader(request.headers, POSTAL_CODE_HEADER_NAME)
      };
    }
    __name(geolocation2, "geolocation");
  }
});

// node_modules/@vercel/functions/get-env.js
var require_get_env = __commonJS({
  "node_modules/@vercel/functions/get-env.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export4 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    }, "__export");
    var __copyProps4 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: /* @__PURE__ */ __name(() => from[key], "get"), enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS3 = /* @__PURE__ */ __name((mod) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod), "__toCommonJS");
    var get_env_exports = {};
    __export4(get_env_exports, {
      getEnv: /* @__PURE__ */ __name(() => getEnv2, "getEnv")
    });
    module.exports = __toCommonJS3(get_env_exports);
    var getEnv2 = /* @__PURE__ */ __name((env2 = process.env) => ({
      /**
       * An indicator to show that System Environment Variables have been exposed to your project's Deployments.
       * @example "1"
       */
      VERCEL: get(env2, "VERCEL"),
      /**
       * An indicator that the code is running in a Continuous Integration environment.
       * @example "1"
       */
      CI: get(env2, "CI"),
      /**
       * The Environment that the app is deployed and running on.
       * @example "production"
       */
      VERCEL_ENV: get(env2, "VERCEL_ENV"),
      /**
       * The domain name of the generated deployment URL. The value does not include the protocol scheme https://.
       * NOTE: This Variable cannot be used in conjunction with Standard Deployment Protection.
       * @example "*.vercel.app"
       */
      VERCEL_URL: get(env2, "VERCEL_URL"),
      /**
       * The domain name of the generated Git branch URL. The value does not include the protocol scheme https://.
       * @example "*-git-*.vercel.app"
       */
      VERCEL_BRANCH_URL: get(env2, "VERCEL_BRANCH_URL"),
      /**
       * A production domain name of the project. This is useful to reliably generate links that point to production such as OG-image URLs.
       * The value does not include the protocol scheme https://.
       * @example "myproject.vercel.app"
       */
      VERCEL_PROJECT_PRODUCTION_URL: get(env2, "VERCEL_PROJECT_PRODUCTION_URL"),
      /**
       * The ID of the Region where the app is running.
       *
       * Possible values:
       * - arn1 (Stockholm, Sweden)
       * - bom1 (Mumbai, India)
       * - cdg1 (Paris, France)
       * - cle1 (Cleveland, USA)
       * - cpt1 (Cape Town, South Africa)
       * - dub1 (Dublin, Ireland)
       * - fra1 (Frankfurt, Germany)
       * - gru1 (São Paulo, Brazil)
       * - hkg1 (Hong Kong)
       * - hnd1 (Tokyo, Japan)
       * - iad1 (Washington, D.C., USA)
       * - icn1 (Seoul, South Korea)
       * - kix1 (Osaka, Japan)
       * - lhr1 (London, United Kingdom)
       * - pdx1 (Portland, USA)
       * - sfo1 (San Francisco, USA)
       * - sin1 (Singapore)
       * - syd1 (Sydney, Australia)
       * - dev1 (Development Region)
       *
       * @example "iad1"
       */
      VERCEL_REGION: get(env2, "VERCEL_REGION"),
      /**
       * The unique identifier for the deployment, which can be used to implement Skew Protection.
       * @example "dpl_7Gw5ZMBpQA8h9GF832KGp7nwbuh3"
       */
      VERCEL_DEPLOYMENT_ID: get(env2, "VERCEL_DEPLOYMENT_ID"),
      /**
       * When Skew Protection is enabled in Project Settings, this value is set to 1.
       * @example "1"
       */
      VERCEL_SKEW_PROTECTION_ENABLED: get(env2, "VERCEL_SKEW_PROTECTION_ENABLED"),
      /**
       * The Protection Bypass for Automation value, if the secret has been generated in the project's Deployment Protection settings.
       */
      VERCEL_AUTOMATION_BYPASS_SECRET: get(env2, "VERCEL_AUTOMATION_BYPASS_SECRET"),
      /**
       * The Git Provider the deployment is triggered from.
       * @example "github"
       */
      VERCEL_GIT_PROVIDER: get(env2, "VERCEL_GIT_PROVIDER"),
      /**
       * The origin repository the deployment is triggered from.
       * @example "my-site"
       */
      VERCEL_GIT_REPO_SLUG: get(env2, "VERCEL_GIT_REPO_SLUG"),
      /**
       * The account that owns the repository the deployment is triggered from.
       * @example "acme"
       */
      VERCEL_GIT_REPO_OWNER: get(env2, "VERCEL_GIT_REPO_OWNER"),
      /**
       * The ID of the repository the deployment is triggered from.
       * @example "117716146"
       */
      VERCEL_GIT_REPO_ID: get(env2, "VERCEL_GIT_REPO_ID"),
      /**
       * The git branch of the commit the deployment was triggered by.
       * @example "improve-about-page"
       */
      VERCEL_GIT_COMMIT_REF: get(env2, "VERCEL_GIT_COMMIT_REF"),
      /**
       * The git SHA of the commit the deployment was triggered by.
       * @example "fa1eade47b73733d6312d5abfad33ce9e4068081"
       */
      VERCEL_GIT_COMMIT_SHA: get(env2, "VERCEL_GIT_COMMIT_SHA"),
      /**
       * The message attached to the commit the deployment was triggered by.
       * @example "Update about page"
       */
      VERCEL_GIT_COMMIT_MESSAGE: get(env2, "VERCEL_GIT_COMMIT_MESSAGE"),
      /**
       * The username attached to the author of the commit that the project was deployed by.
       * @example "johndoe"
       */
      VERCEL_GIT_COMMIT_AUTHOR_LOGIN: get(env2, "VERCEL_GIT_COMMIT_AUTHOR_LOGIN"),
      /**
       * The name attached to the author of the commit that the project was deployed by.
       * @example "John Doe"
       */
      VERCEL_GIT_COMMIT_AUTHOR_NAME: get(env2, "VERCEL_GIT_COMMIT_AUTHOR_NAME"),
      /**
       * The git SHA of the last successful deployment for the project and branch.
       * NOTE: This Variable is only exposed when an Ignored Build Step is provided.
       * @example "fa1eade47b73733d6312d5abfad33ce9e4068080"
       */
      VERCEL_GIT_PREVIOUS_SHA: get(env2, "VERCEL_GIT_PREVIOUS_SHA"),
      /**
       * The pull request id the deployment was triggered by. If a deployment is created on a branch before a pull request is made, this value will be an empty string.
       * @example "23"
       */
      VERCEL_GIT_PULL_REQUEST_ID: get(env2, "VERCEL_GIT_PULL_REQUEST_ID")
    }), "getEnv");
    var get = /* @__PURE__ */ __name((env2, key) => {
      const value = env2[key];
      return value === "" ? void 0 : value;
    }, "get");
  }
});

// node_modules/@vercel/functions/get-context.js
var require_get_context = __commonJS({
  "node_modules/@vercel/functions/get-context.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export4 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    }, "__export");
    var __copyProps4 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: /* @__PURE__ */ __name(() => from[key], "get"), enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS3 = /* @__PURE__ */ __name((mod) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod), "__toCommonJS");
    var get_context_exports = {};
    __export4(get_context_exports, {
      SYMBOL_FOR_REQ_CONTEXT: /* @__PURE__ */ __name(() => SYMBOL_FOR_REQ_CONTEXT, "SYMBOL_FOR_REQ_CONTEXT"),
      getContext: /* @__PURE__ */ __name(() => getContext, "getContext")
    });
    module.exports = __toCommonJS3(get_context_exports);
    var SYMBOL_FOR_REQ_CONTEXT = Symbol.for("@vercel/request-context");
    function getContext() {
      const fromSymbol = globalThis;
      return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
    }
    __name(getContext, "getContext");
  }
});

// node_modules/@vercel/functions/wait-until.js
var require_wait_until = __commonJS({
  "node_modules/@vercel/functions/wait-until.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export4 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    }, "__export");
    var __copyProps4 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: /* @__PURE__ */ __name(() => from[key], "get"), enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS3 = /* @__PURE__ */ __name((mod) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod), "__toCommonJS");
    var wait_until_exports = {};
    __export4(wait_until_exports, {
      waitUntil: /* @__PURE__ */ __name(() => waitUntil3, "waitUntil")
    });
    module.exports = __toCommonJS3(wait_until_exports);
    var import_get_context = require_get_context();
    var waitUntil3 = /* @__PURE__ */ __name((promise) => {
      if (promise === null || typeof promise !== "object" || typeof promise.then !== "function") {
        throw new TypeError(
          `waitUntil can only be called with a Promise, got ${typeof promise}`
        );
      }
      return (0, import_get_context.getContext)().waitUntil?.(promise);
    }, "waitUntil");
  }
});

// node_modules/@vercel/functions/middleware.js
var require_middleware = __commonJS({
  "node_modules/@vercel/functions/middleware.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export4 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    }, "__export");
    var __copyProps4 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: /* @__PURE__ */ __name(() => from[key], "get"), enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS3 = /* @__PURE__ */ __name((mod) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod), "__toCommonJS");
    var middleware_exports = {};
    __export4(middleware_exports, {
      next: /* @__PURE__ */ __name(() => next2, "next"),
      rewrite: /* @__PURE__ */ __name(() => rewrite2, "rewrite")
    });
    module.exports = __toCommonJS3(middleware_exports);
    function handleMiddlewareField(init2, headers) {
      if (init2?.request?.headers) {
        if (!(init2.request.headers instanceof Headers)) {
          throw new Error("request.headers must be an instance of Headers");
        }
        const keys = [];
        for (const [key, value] of init2.request.headers) {
          headers.set("x-middleware-request-" + key, value);
          keys.push(key);
        }
        headers.set("x-middleware-override-headers", keys.join(","));
      }
    }
    __name(handleMiddlewareField, "handleMiddlewareField");
    function rewrite2(destination, init2) {
      const headers = new Headers(init2?.headers ?? {});
      headers.set("x-middleware-rewrite", String(destination));
      handleMiddlewareField(init2, headers);
      return new Response(null, {
        ...init2,
        headers
      });
    }
    __name(rewrite2, "rewrite");
    function next2(init2) {
      const headers = new Headers(init2?.headers ?? {});
      headers.set("x-middleware-next", "1");
      handleMiddlewareField(init2, headers);
      return new Response(null, {
        ...init2,
        headers
      });
    }
    __name(next2, "next");
  }
});

// node_modules/@vercel/functions/index.js
var require_functions = __commonJS({
  "node_modules/@vercel/functions/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export4 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    }, "__export");
    var __copyProps4 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: /* @__PURE__ */ __name(() => from[key], "get"), enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS3 = /* @__PURE__ */ __name((mod) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod), "__toCommonJS");
    var src_exports = {};
    __export4(src_exports, {
      geolocation: /* @__PURE__ */ __name(() => import_headers25.geolocation, "geolocation"),
      getEnv: /* @__PURE__ */ __name(() => import_get_env.getEnv, "getEnv"),
      ipAddress: /* @__PURE__ */ __name(() => import_headers25.ipAddress, "ipAddress"),
      next: /* @__PURE__ */ __name(() => import_middleware.next, "next"),
      rewrite: /* @__PURE__ */ __name(() => import_middleware.rewrite, "rewrite"),
      waitUntil: /* @__PURE__ */ __name(() => import_wait_until.waitUntil, "waitUntil")
    });
    module.exports = __toCommonJS3(src_exports);
    var import_headers25 = require_headers();
    var import_get_env = require_get_env();
    var import_wait_until = require_wait_until();
    var import_middleware = require_middleware();
  }
});

// node_modules/unenv/dist/runtime/node/internal/fs/promises.mjs
var access, copyFile, cp, open, opendir, rename, truncate, rm, rmdir, mkdir, readdir, readlink, symlink, lstat, stat, link, unlink, chmod, lchmod, lchown, chown, utimes, lutimes, realpath, mkdtemp, writeFile, appendFile, readFile, watch, statfs, glob;
var init_promises = __esm({
  "node_modules/unenv/dist/runtime/node/internal/fs/promises.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    access = /* @__PURE__ */ notImplemented("fs.access");
    copyFile = /* @__PURE__ */ notImplemented("fs.copyFile");
    cp = /* @__PURE__ */ notImplemented("fs.cp");
    open = /* @__PURE__ */ notImplemented("fs.open");
    opendir = /* @__PURE__ */ notImplemented("fs.opendir");
    rename = /* @__PURE__ */ notImplemented("fs.rename");
    truncate = /* @__PURE__ */ notImplemented("fs.truncate");
    rm = /* @__PURE__ */ notImplemented("fs.rm");
    rmdir = /* @__PURE__ */ notImplemented("fs.rmdir");
    mkdir = /* @__PURE__ */ notImplemented("fs.mkdir");
    readdir = /* @__PURE__ */ notImplemented("fs.readdir");
    readlink = /* @__PURE__ */ notImplemented("fs.readlink");
    symlink = /* @__PURE__ */ notImplemented("fs.symlink");
    lstat = /* @__PURE__ */ notImplemented("fs.lstat");
    stat = /* @__PURE__ */ notImplemented("fs.stat");
    link = /* @__PURE__ */ notImplemented("fs.link");
    unlink = /* @__PURE__ */ notImplemented("fs.unlink");
    chmod = /* @__PURE__ */ notImplemented("fs.chmod");
    lchmod = /* @__PURE__ */ notImplemented("fs.lchmod");
    lchown = /* @__PURE__ */ notImplemented("fs.lchown");
    chown = /* @__PURE__ */ notImplemented("fs.chown");
    utimes = /* @__PURE__ */ notImplemented("fs.utimes");
    lutimes = /* @__PURE__ */ notImplemented("fs.lutimes");
    realpath = /* @__PURE__ */ notImplemented("fs.realpath");
    mkdtemp = /* @__PURE__ */ notImplemented("fs.mkdtemp");
    writeFile = /* @__PURE__ */ notImplemented("fs.writeFile");
    appendFile = /* @__PURE__ */ notImplemented("fs.appendFile");
    readFile = /* @__PURE__ */ notImplemented("fs.readFile");
    watch = /* @__PURE__ */ notImplemented("fs.watch");
    statfs = /* @__PURE__ */ notImplemented("fs.statfs");
    glob = /* @__PURE__ */ notImplemented("fs.glob");
  }
});

// node_modules/unenv/dist/runtime/node/internal/fs/constants.mjs
var constants_exports = {};
__export(constants_exports, {
  COPYFILE_EXCL: () => COPYFILE_EXCL,
  COPYFILE_FICLONE: () => COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE: () => COPYFILE_FICLONE_FORCE,
  EXTENSIONLESS_FORMAT_JAVASCRIPT: () => EXTENSIONLESS_FORMAT_JAVASCRIPT,
  EXTENSIONLESS_FORMAT_WASM: () => EXTENSIONLESS_FORMAT_WASM,
  F_OK: () => F_OK,
  O_APPEND: () => O_APPEND,
  O_CREAT: () => O_CREAT,
  O_DIRECT: () => O_DIRECT,
  O_DIRECTORY: () => O_DIRECTORY,
  O_DSYNC: () => O_DSYNC,
  O_EXCL: () => O_EXCL,
  O_NOATIME: () => O_NOATIME,
  O_NOCTTY: () => O_NOCTTY,
  O_NOFOLLOW: () => O_NOFOLLOW,
  O_NONBLOCK: () => O_NONBLOCK,
  O_RDONLY: () => O_RDONLY,
  O_RDWR: () => O_RDWR,
  O_SYNC: () => O_SYNC,
  O_TRUNC: () => O_TRUNC,
  O_WRONLY: () => O_WRONLY,
  R_OK: () => R_OK,
  S_IFBLK: () => S_IFBLK,
  S_IFCHR: () => S_IFCHR,
  S_IFDIR: () => S_IFDIR,
  S_IFIFO: () => S_IFIFO,
  S_IFLNK: () => S_IFLNK,
  S_IFMT: () => S_IFMT,
  S_IFREG: () => S_IFREG,
  S_IFSOCK: () => S_IFSOCK,
  S_IRGRP: () => S_IRGRP,
  S_IROTH: () => S_IROTH,
  S_IRUSR: () => S_IRUSR,
  S_IRWXG: () => S_IRWXG,
  S_IRWXO: () => S_IRWXO,
  S_IRWXU: () => S_IRWXU,
  S_IWGRP: () => S_IWGRP,
  S_IWOTH: () => S_IWOTH,
  S_IWUSR: () => S_IWUSR,
  S_IXGRP: () => S_IXGRP,
  S_IXOTH: () => S_IXOTH,
  S_IXUSR: () => S_IXUSR,
  UV_DIRENT_BLOCK: () => UV_DIRENT_BLOCK,
  UV_DIRENT_CHAR: () => UV_DIRENT_CHAR,
  UV_DIRENT_DIR: () => UV_DIRENT_DIR,
  UV_DIRENT_FIFO: () => UV_DIRENT_FIFO,
  UV_DIRENT_FILE: () => UV_DIRENT_FILE,
  UV_DIRENT_LINK: () => UV_DIRENT_LINK,
  UV_DIRENT_SOCKET: () => UV_DIRENT_SOCKET,
  UV_DIRENT_UNKNOWN: () => UV_DIRENT_UNKNOWN,
  UV_FS_COPYFILE_EXCL: () => UV_FS_COPYFILE_EXCL,
  UV_FS_COPYFILE_FICLONE: () => UV_FS_COPYFILE_FICLONE,
  UV_FS_COPYFILE_FICLONE_FORCE: () => UV_FS_COPYFILE_FICLONE_FORCE,
  UV_FS_O_FILEMAP: () => UV_FS_O_FILEMAP,
  UV_FS_SYMLINK_DIR: () => UV_FS_SYMLINK_DIR,
  UV_FS_SYMLINK_JUNCTION: () => UV_FS_SYMLINK_JUNCTION,
  W_OK: () => W_OK,
  X_OK: () => X_OK
});
var UV_FS_SYMLINK_DIR, UV_FS_SYMLINK_JUNCTION, O_RDONLY, O_WRONLY, O_RDWR, UV_DIRENT_UNKNOWN, UV_DIRENT_FILE, UV_DIRENT_DIR, UV_DIRENT_LINK, UV_DIRENT_FIFO, UV_DIRENT_SOCKET, UV_DIRENT_CHAR, UV_DIRENT_BLOCK, EXTENSIONLESS_FORMAT_JAVASCRIPT, EXTENSIONLESS_FORMAT_WASM, S_IFMT, S_IFREG, S_IFDIR, S_IFCHR, S_IFBLK, S_IFIFO, S_IFLNK, S_IFSOCK, O_CREAT, O_EXCL, UV_FS_O_FILEMAP, O_NOCTTY, O_TRUNC, O_APPEND, O_DIRECTORY, O_NOATIME, O_NOFOLLOW, O_SYNC, O_DSYNC, O_DIRECT, O_NONBLOCK, S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRGRP, S_IWGRP, S_IXGRP, S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH, F_OK, R_OK, W_OK, X_OK, UV_FS_COPYFILE_EXCL, COPYFILE_EXCL, UV_FS_COPYFILE_FICLONE, COPYFILE_FICLONE, UV_FS_COPYFILE_FICLONE_FORCE, COPYFILE_FICLONE_FORCE;
var init_constants = __esm({
  "node_modules/unenv/dist/runtime/node/internal/fs/constants.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    UV_FS_SYMLINK_DIR = 1;
    UV_FS_SYMLINK_JUNCTION = 2;
    O_RDONLY = 0;
    O_WRONLY = 1;
    O_RDWR = 2;
    UV_DIRENT_UNKNOWN = 0;
    UV_DIRENT_FILE = 1;
    UV_DIRENT_DIR = 2;
    UV_DIRENT_LINK = 3;
    UV_DIRENT_FIFO = 4;
    UV_DIRENT_SOCKET = 5;
    UV_DIRENT_CHAR = 6;
    UV_DIRENT_BLOCK = 7;
    EXTENSIONLESS_FORMAT_JAVASCRIPT = 0;
    EXTENSIONLESS_FORMAT_WASM = 1;
    S_IFMT = 61440;
    S_IFREG = 32768;
    S_IFDIR = 16384;
    S_IFCHR = 8192;
    S_IFBLK = 24576;
    S_IFIFO = 4096;
    S_IFLNK = 40960;
    S_IFSOCK = 49152;
    O_CREAT = 64;
    O_EXCL = 128;
    UV_FS_O_FILEMAP = 0;
    O_NOCTTY = 256;
    O_TRUNC = 512;
    O_APPEND = 1024;
    O_DIRECTORY = 65536;
    O_NOATIME = 262144;
    O_NOFOLLOW = 131072;
    O_SYNC = 1052672;
    O_DSYNC = 4096;
    O_DIRECT = 16384;
    O_NONBLOCK = 2048;
    S_IRWXU = 448;
    S_IRUSR = 256;
    S_IWUSR = 128;
    S_IXUSR = 64;
    S_IRWXG = 56;
    S_IRGRP = 32;
    S_IWGRP = 16;
    S_IXGRP = 8;
    S_IRWXO = 7;
    S_IROTH = 4;
    S_IWOTH = 2;
    S_IXOTH = 1;
    F_OK = 0;
    R_OK = 4;
    W_OK = 2;
    X_OK = 1;
    UV_FS_COPYFILE_EXCL = 1;
    COPYFILE_EXCL = 1;
    UV_FS_COPYFILE_FICLONE = 2;
    COPYFILE_FICLONE = 2;
    UV_FS_COPYFILE_FICLONE_FORCE = 4;
    COPYFILE_FICLONE_FORCE = 4;
  }
});

// node_modules/unenv/dist/runtime/node/fs/promises.mjs
var promises_default;
var init_promises2 = __esm({
  "node_modules/unenv/dist/runtime/node/fs/promises.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_promises();
    init_constants();
    init_promises();
    promises_default = {
      constants: constants_exports,
      access,
      appendFile,
      chmod,
      chown,
      copyFile,
      cp,
      glob,
      lchmod,
      lchown,
      link,
      lstat,
      lutimes,
      mkdir,
      mkdtemp,
      open,
      opendir,
      readFile,
      readdir,
      readlink,
      realpath,
      rename,
      rm,
      rmdir,
      stat,
      statfs,
      symlink,
      truncate,
      unlink,
      utimes,
      watch,
      writeFile
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/fs/classes.mjs
var Dir, Dirent, Stats, ReadStream2, WriteStream2, FileReadStream, FileWriteStream;
var init_classes = __esm({
  "node_modules/unenv/dist/runtime/node/internal/fs/classes.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    Dir = /* @__PURE__ */ notImplementedClass("fs.Dir");
    Dirent = /* @__PURE__ */ notImplementedClass("fs.Dirent");
    Stats = /* @__PURE__ */ notImplementedClass("fs.Stats");
    ReadStream2 = /* @__PURE__ */ notImplementedClass("fs.ReadStream");
    WriteStream2 = /* @__PURE__ */ notImplementedClass("fs.WriteStream");
    FileReadStream = ReadStream2;
    FileWriteStream = WriteStream2;
  }
});

// node_modules/unenv/dist/runtime/node/internal/fs/fs.mjs
function callbackify(fn) {
  const fnc = /* @__PURE__ */ __name(function(...args) {
    const cb = args.pop();
    fn().catch((error4) => cb(error4)).then((val) => cb(void 0, val));
  }, "fnc");
  fnc.__promisify__ = fn;
  fnc.native = fnc;
  return fnc;
}
var access2, appendFile2, chown2, chmod2, copyFile2, cp2, lchown2, lchmod2, link2, lstat2, lutimes2, mkdir2, mkdtemp2, realpath2, open2, opendir2, readdir2, readFile2, readlink2, rename2, rm2, rmdir2, stat2, symlink2, truncate2, unlink2, utimes2, writeFile2, statfs2, close, createReadStream, createWriteStream, exists, fchown, fchmod, fdatasync, fstat, fsync, ftruncate, futimes, lstatSync, read, readv, realpathSync, statSync, unwatchFile, watch2, watchFile, write, writev, _toUnixTimestamp, openAsBlob, glob2, appendFileSync, accessSync, chownSync, chmodSync, closeSync, copyFileSync, cpSync, existsSync, fchownSync, fchmodSync, fdatasyncSync, fstatSync, fsyncSync, ftruncateSync, futimesSync, lchownSync, lchmodSync, linkSync, lutimesSync, mkdirSync, mkdtempSync, openSync, opendirSync, readdirSync, readSync, readvSync, readFileSync, readlinkSync, renameSync, rmSync, rmdirSync, symlinkSync, truncateSync, unlinkSync, utimesSync, writeFileSync, writeSync, writevSync, statfsSync, globSync;
var init_fs = __esm({
  "node_modules/unenv/dist/runtime/node/internal/fs/fs.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_promises();
    __name(callbackify, "callbackify");
    access2 = callbackify(access);
    appendFile2 = callbackify(appendFile);
    chown2 = callbackify(chown);
    chmod2 = callbackify(chmod);
    copyFile2 = callbackify(copyFile);
    cp2 = callbackify(cp);
    lchown2 = callbackify(lchown);
    lchmod2 = callbackify(lchmod);
    link2 = callbackify(link);
    lstat2 = callbackify(lstat);
    lutimes2 = callbackify(lutimes);
    mkdir2 = callbackify(mkdir);
    mkdtemp2 = callbackify(mkdtemp);
    realpath2 = callbackify(realpath);
    open2 = callbackify(open);
    opendir2 = callbackify(opendir);
    readdir2 = callbackify(readdir);
    readFile2 = callbackify(readFile);
    readlink2 = callbackify(readlink);
    rename2 = callbackify(rename);
    rm2 = callbackify(rm);
    rmdir2 = callbackify(rmdir);
    stat2 = callbackify(stat);
    symlink2 = callbackify(symlink);
    truncate2 = callbackify(truncate);
    unlink2 = callbackify(unlink);
    utimes2 = callbackify(utimes);
    writeFile2 = callbackify(writeFile);
    statfs2 = callbackify(statfs);
    close = /* @__PURE__ */ notImplementedAsync("fs.close");
    createReadStream = /* @__PURE__ */ notImplementedAsync("fs.createReadStream");
    createWriteStream = /* @__PURE__ */ notImplementedAsync("fs.createWriteStream");
    exists = /* @__PURE__ */ notImplementedAsync("fs.exists");
    fchown = /* @__PURE__ */ notImplementedAsync("fs.fchown");
    fchmod = /* @__PURE__ */ notImplementedAsync("fs.fchmod");
    fdatasync = /* @__PURE__ */ notImplementedAsync("fs.fdatasync");
    fstat = /* @__PURE__ */ notImplementedAsync("fs.fstat");
    fsync = /* @__PURE__ */ notImplementedAsync("fs.fsync");
    ftruncate = /* @__PURE__ */ notImplementedAsync("fs.ftruncate");
    futimes = /* @__PURE__ */ notImplementedAsync("fs.futimes");
    lstatSync = /* @__PURE__ */ notImplementedAsync("fs.lstatSync");
    read = /* @__PURE__ */ notImplementedAsync("fs.read");
    readv = /* @__PURE__ */ notImplementedAsync("fs.readv");
    realpathSync = /* @__PURE__ */ notImplementedAsync("fs.realpathSync");
    statSync = /* @__PURE__ */ notImplementedAsync("fs.statSync");
    unwatchFile = /* @__PURE__ */ notImplementedAsync("fs.unwatchFile");
    watch2 = /* @__PURE__ */ notImplementedAsync("fs.watch");
    watchFile = /* @__PURE__ */ notImplementedAsync("fs.watchFile");
    write = /* @__PURE__ */ notImplementedAsync("fs.write");
    writev = /* @__PURE__ */ notImplementedAsync("fs.writev");
    _toUnixTimestamp = /* @__PURE__ */ notImplementedAsync("fs._toUnixTimestamp");
    openAsBlob = /* @__PURE__ */ notImplementedAsync("fs.openAsBlob");
    glob2 = /* @__PURE__ */ notImplementedAsync("fs.glob");
    appendFileSync = /* @__PURE__ */ notImplemented("fs.appendFileSync");
    accessSync = /* @__PURE__ */ notImplemented("fs.accessSync");
    chownSync = /* @__PURE__ */ notImplemented("fs.chownSync");
    chmodSync = /* @__PURE__ */ notImplemented("fs.chmodSync");
    closeSync = /* @__PURE__ */ notImplemented("fs.closeSync");
    copyFileSync = /* @__PURE__ */ notImplemented("fs.copyFileSync");
    cpSync = /* @__PURE__ */ notImplemented("fs.cpSync");
    existsSync = /* @__PURE__ */ __name(() => false, "existsSync");
    fchownSync = /* @__PURE__ */ notImplemented("fs.fchownSync");
    fchmodSync = /* @__PURE__ */ notImplemented("fs.fchmodSync");
    fdatasyncSync = /* @__PURE__ */ notImplemented("fs.fdatasyncSync");
    fstatSync = /* @__PURE__ */ notImplemented("fs.fstatSync");
    fsyncSync = /* @__PURE__ */ notImplemented("fs.fsyncSync");
    ftruncateSync = /* @__PURE__ */ notImplemented("fs.ftruncateSync");
    futimesSync = /* @__PURE__ */ notImplemented("fs.futimesSync");
    lchownSync = /* @__PURE__ */ notImplemented("fs.lchownSync");
    lchmodSync = /* @__PURE__ */ notImplemented("fs.lchmodSync");
    linkSync = /* @__PURE__ */ notImplemented("fs.linkSync");
    lutimesSync = /* @__PURE__ */ notImplemented("fs.lutimesSync");
    mkdirSync = /* @__PURE__ */ notImplemented("fs.mkdirSync");
    mkdtempSync = /* @__PURE__ */ notImplemented("fs.mkdtempSync");
    openSync = /* @__PURE__ */ notImplemented("fs.openSync");
    opendirSync = /* @__PURE__ */ notImplemented("fs.opendirSync");
    readdirSync = /* @__PURE__ */ notImplemented("fs.readdirSync");
    readSync = /* @__PURE__ */ notImplemented("fs.readSync");
    readvSync = /* @__PURE__ */ notImplemented("fs.readvSync");
    readFileSync = /* @__PURE__ */ notImplemented("fs.readFileSync");
    readlinkSync = /* @__PURE__ */ notImplemented("fs.readlinkSync");
    renameSync = /* @__PURE__ */ notImplemented("fs.renameSync");
    rmSync = /* @__PURE__ */ notImplemented("fs.rmSync");
    rmdirSync = /* @__PURE__ */ notImplemented("fs.rmdirSync");
    symlinkSync = /* @__PURE__ */ notImplemented("fs.symlinkSync");
    truncateSync = /* @__PURE__ */ notImplemented("fs.truncateSync");
    unlinkSync = /* @__PURE__ */ notImplemented("fs.unlinkSync");
    utimesSync = /* @__PURE__ */ notImplemented("fs.utimesSync");
    writeFileSync = /* @__PURE__ */ notImplemented("fs.writeFileSync");
    writeSync = /* @__PURE__ */ notImplemented("fs.writeSync");
    writevSync = /* @__PURE__ */ notImplemented("fs.writevSync");
    statfsSync = /* @__PURE__ */ notImplemented("fs.statfsSync");
    globSync = /* @__PURE__ */ notImplemented("fs.globSync");
  }
});

// node_modules/unenv/dist/runtime/node/fs.mjs
var fs_default;
var init_fs2 = __esm({
  "node_modules/unenv/dist/runtime/node/fs.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_promises2();
    init_classes();
    init_fs();
    init_constants();
    init_constants();
    init_fs();
    init_classes();
    fs_default = {
      F_OK,
      R_OK,
      W_OK,
      X_OK,
      constants: constants_exports,
      promises: promises_default,
      Dir,
      Dirent,
      FileReadStream,
      FileWriteStream,
      ReadStream: ReadStream2,
      Stats,
      WriteStream: WriteStream2,
      _toUnixTimestamp,
      access: access2,
      accessSync,
      appendFile: appendFile2,
      appendFileSync,
      chmod: chmod2,
      chmodSync,
      chown: chown2,
      chownSync,
      close,
      closeSync,
      copyFile: copyFile2,
      copyFileSync,
      cp: cp2,
      cpSync,
      createReadStream,
      createWriteStream,
      exists,
      existsSync,
      fchmod,
      fchmodSync,
      fchown,
      fchownSync,
      fdatasync,
      fdatasyncSync,
      fstat,
      fstatSync,
      fsync,
      fsyncSync,
      ftruncate,
      ftruncateSync,
      futimes,
      futimesSync,
      glob: glob2,
      lchmod: lchmod2,
      globSync,
      lchmodSync,
      lchown: lchown2,
      lchownSync,
      link: link2,
      linkSync,
      lstat: lstat2,
      lstatSync,
      lutimes: lutimes2,
      lutimesSync,
      mkdir: mkdir2,
      mkdirSync,
      mkdtemp: mkdtemp2,
      mkdtempSync,
      open: open2,
      openAsBlob,
      openSync,
      opendir: opendir2,
      opendirSync,
      read,
      readFile: readFile2,
      readFileSync,
      readSync,
      readdir: readdir2,
      readdirSync,
      readlink: readlink2,
      readlinkSync,
      readv,
      readvSync,
      realpath: realpath2,
      realpathSync,
      rename: rename2,
      renameSync,
      rm: rm2,
      rmSync,
      rmdir: rmdir2,
      rmdirSync,
      stat: stat2,
      statSync,
      statfs: statfs2,
      statfsSync,
      symlink: symlink2,
      symlinkSync,
      truncate: truncate2,
      truncateSync,
      unlink: unlink2,
      unlinkSync,
      unwatchFile,
      utimes: utimes2,
      utimesSync,
      watch: watch2,
      watchFile,
      write,
      writeFile: writeFile2,
      writeFileSync,
      writeSync,
      writev,
      writevSync
    };
  }
});

// node-built-in-modules:fs
var require_fs = __commonJS({
  "node-built-in-modules:fs"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_fs2();
    module.exports = fs_default;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse4(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse4(str2) {
      str2 = String(str2);
      if (str2.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str2
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    __name(parse4, "parse");
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    __name(fmtShort, "fmtShort");
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    __name(fmtLong, "fmtLong");
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
    __name(plural, "plural");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      __name(selectColor, "selectColor");
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug4(...args) {
          if (!debug4.enabled) {
            return;
          }
          const self = debug4;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        __name(debug4, "debug");
        debug4.namespace = namespace;
        debug4.useColors = createDebug.useColors();
        debug4.color = createDebug.selectColor(namespace);
        debug4.extend = extend;
        debug4.destroy = createDebug.destroy;
        Object.defineProperty(debug4, "enabled", {
          enumerable: true,
          configurable: false,
          get: /* @__PURE__ */ __name(() => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          }, "get"),
          set: /* @__PURE__ */ __name((v) => {
            enableOverride = v;
          }, "set")
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug4);
        }
        return debug4;
      }
      __name(createDebug, "createDebug");
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      __name(extend, "extend");
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      __name(enable, "enable");
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      __name(matchesTemplate, "matchesTemplate");
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      __name(disable, "disable");
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      __name(enabled, "enabled");
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      __name(coerce2, "coerce");
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      __name(destroy, "destroy");
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    __name(setup, "setup");
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && "Cloudflare-Workers" && (m = "Cloudflare-Workers".toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    __name(formatArgs, "formatArgs");
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error4) {
      }
    }
    __name(save, "save");
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error4) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    __name(load, "load");
    function localstorage() {
      try {
        return localStorage;
      } catch (error4) {
      }
    }
    __name(localstorage, "localstorage");
    module.exports = require_common()(exports);
    var { formatters: formatters2 } = module.exports;
    formatters2.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error4) {
        return "[UnexpectedJSONParseError]: " + error4.message;
      }
    };
  }
});

// node-built-in-modules:tty
var require_tty = __commonJS({
  "node-built-in-modules:tty"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    module.exports = tty_default;
  }
});

// node-built-in-modules:util
import libDefault from "util";
var require_util = __commonJS({
  "node-built-in-modules:util"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault;
  }
});

// node_modules/supports-color/browser.js
var require_browser2 = __commonJS({
  "node_modules/supports-color/browser.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      stdout: false,
      stderr: false
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var tty = require_tty();
    var util2 = require_util();
    exports.init = init2;
    exports.log = log4;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_browser2();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error4) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    __name(formatArgs, "formatArgs");
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    __name(getDate, "getDate");
    function log4(...args) {
      return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    __name(log4, "log");
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    __name(save, "save");
    function load() {
      return process.env.DEBUG;
    }
    __name(load, "load");
    function init2(debug4) {
      debug4.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug4.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    __name(init2, "init");
    module.exports = require_common()(exports);
    var { formatters: formatters2 } = module.exports;
    formatters2.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str2) => str2.trim()).join(" ");
    };
    formatters2.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  }
});

// node_modules/@kwsites/file-exists/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/@kwsites/file-exists/dist/src/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs_1 = require_fs();
    var debug_1 = __importDefault(require_src());
    var log4 = debug_1.default("@kwsites/file-exists");
    function check(path4, isFile, isDirectory) {
      log4(`checking %s`, path4);
      try {
        const stat3 = fs_1.statSync(path4);
        if (stat3.isFile() && isFile) {
          log4(`[OK] path represents a file`);
          return true;
        }
        if (stat3.isDirectory() && isDirectory) {
          log4(`[OK] path represents a directory`);
          return true;
        }
        log4(`[FAIL] path represents something other than a file or directory`);
        return false;
      } catch (e) {
        if (e.code === "ENOENT") {
          log4(`[FAIL] path is not accessible: %o`, e);
          return false;
        }
        log4(`[FATAL] %o`, e);
        throw e;
      }
    }
    __name(check, "check");
    function exists3(path4, type = exports.READABLE) {
      return check(path4, (type & exports.FILE) > 0, (type & exports.FOLDER) > 0);
    }
    __name(exists3, "exists");
    exports.exists = exists3;
    exports.FILE = 1;
    exports.FOLDER = 2;
    exports.READABLE = exports.FILE + exports.FOLDER;
  }
});

// node_modules/@kwsites/file-exists/dist/index.js
var require_dist = __commonJS({
  "node_modules/@kwsites/file-exists/dist/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function __export4(m) {
      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    __name(__export4, "__export");
    Object.defineProperty(exports, "__esModule", { value: true });
    __export4(require_src2());
  }
});

// node_modules/@kwsites/promise-deferred/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@kwsites/promise-deferred/dist/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDeferred = exports.deferred = void 0;
    function deferred2() {
      let done;
      let fail;
      let status = "pending";
      const promise = new Promise((_done, _fail) => {
        done = _done;
        fail = _fail;
      });
      return {
        promise,
        done(result) {
          if (status === "pending") {
            status = "resolved";
            done(result);
          }
        },
        fail(error4) {
          if (status === "pending") {
            status = "rejected";
            fail(error4);
          }
        },
        get fulfilled() {
          return status !== "pending";
        },
        get status() {
          return status;
        }
      };
    }
    __name(deferred2, "deferred");
    exports.deferred = deferred2;
    exports.createDeferred = deferred2;
    exports.default = deferred2;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = /* @__PURE__ */ __name(function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      }, "diffc");
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    __name(comparativeDistance, "comparativeDistance");
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    __name(buildGraph, "buildGraph");
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue2 = [fromModel];
      graph[fromModel].distance = 0;
      while (queue2.length) {
        const current = queue2.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue2.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    __name(deriveBFS, "deriveBFS");
    function link3(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    __name(link3, "link");
    function wrapConversion(toModel, graph) {
      const path4 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path4.unshift(graph[cur].parent);
        fn = link3(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path4;
      return fn;
    }
    __name(wrapConversion, "wrapConversion");
    module.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = /* @__PURE__ */ __name(function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      }, "wrappedFn");
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    __name(wrapRaw, "wrapRaw");
    function wrapRounded(fn) {
      const wrappedFn = /* @__PURE__ */ __name(function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      }, "wrappedFn");
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    __name(wrapRounded, "wrapRounded");
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var wrapAnsi16 = /* @__PURE__ */ __name((fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    }, "wrapAnsi16");
    var wrapAnsi256 = /* @__PURE__ */ __name((fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    }, "wrapAnsi256");
    var wrapAnsi16m = /* @__PURE__ */ __name((fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    }, "wrapAnsi16m");
    var ansi2ansi = /* @__PURE__ */ __name((n) => n, "ansi2ansi");
    var rgb2rgb = /* @__PURE__ */ __name((r, g, b) => [r, g, b], "rgb2rgb");
    var setLazyProperty = /* @__PURE__ */ __name((object, property, get) => {
      Object.defineProperty(object, property, {
        get: /* @__PURE__ */ __name(() => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        }, "get"),
        enumerable: true,
        configurable: true
      });
    }, "setLazyProperty");
    var colorConvert;
    var makeDynamicStyles = /* @__PURE__ */ __name((wrap2, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap2(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap2(suite[targetSpace], offset);
        }
      }
      return styles;
    }, "makeDynamicStyles");
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group3] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group3)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group3[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group3,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    __name(assembleStyles, "assembleStyles");
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/chalk/source/util.js
var require_util2 = __commonJS({
  "node_modules/chalk/source/util.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var stringReplaceAll = /* @__PURE__ */ __name((string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    }, "stringReplaceAll");
    var stringEncaseCRLFWithFirstIndex = /* @__PURE__ */ __name((string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    }, "stringEncaseCRLFWithFirstIndex");
    module.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/chalk/source/templates.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    __name(unescape2, "unescape");
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, character) => escape2 ? unescape2(escape2) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    __name(parseArguments, "parseArguments");
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    __name(parseStyle, "parseStyle");
    function buildStyle(chalk2, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk2;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    __name(buildStyle, "buildStyle");
    module.exports = (chalk2, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close2, character) => {
        if (escapeCharacter) {
          chunk.push(unescape2(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk2, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close2) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk2, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/chalk/source/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_browser2();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util2();
    var { isArray: isArray4 } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = /* @__PURE__ */ __name((object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    }, "applyOptions");
    var ChalkClass = class {
      static {
        __name(this, "ChalkClass");
      }
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = /* @__PURE__ */ __name((options) => {
      const chalk3 = {};
      applyOptions(chalk3, options);
      chalk3.template = (...arguments_) => chalkTag(chalk3.template, ...arguments_);
      Object.setPrototypeOf(chalk3, Chalk.prototype);
      Object.setPrototypeOf(chalk3.template, chalk3);
      chalk3.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk3.template.Instance = ChalkClass;
      return chalk3.template;
    }, "chalkFactory");
    function Chalk(options) {
      return chalkFactory(options);
    }
    __name(Chalk, "Chalk");
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = /* @__PURE__ */ __name((open3, close2, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open3;
        closeAll = close2;
      } else {
        openAll = parent.openAll + open3;
        closeAll = close2 + parent.closeAll;
      }
      return {
        open: open3,
        close: close2,
        openAll,
        closeAll,
        parent
      };
    }, "createStyler");
    var createBuilder = /* @__PURE__ */ __name((self, _styler, _isEmpty) => {
      const builder = /* @__PURE__ */ __name((...arguments_) => {
        if (isArray4(arguments_[0]) && isArray4(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      }, "builder");
      Object.setPrototypeOf(builder, proto);
      builder._generator = self;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    }, "createBuilder");
    var applyStyle = /* @__PURE__ */ __name((self, string) => {
      if (self.level <= 0 || !string) {
        return self._isEmpty ? "" : string;
      }
      let styler = self._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    }, "applyStyle");
    var template;
    var chalkTag = /* @__PURE__ */ __name((chalk3, ...strings) => {
      const [firstString] = strings;
      if (!isArray4(firstString) || !isArray4(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(
          String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i])
        );
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk3, parts.join(""));
    }, "chalkTag");
    Object.defineProperties(Chalk.prototype, styles);
    var chalk2 = Chalk();
    chalk2.supportsColor = stdoutColor;
    chalk2.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk2.stderr.supportsColor = stderrColor;
    module.exports = chalk2;
  }
});

// node_modules/pluralize/pluralize.js
var require_pluralize = __commonJS({
  "node_modules/pluralize/pluralize.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, pluralize2) {
      if (typeof __require === "function" && typeof exports === "object" && typeof module === "object") {
        module.exports = pluralize2();
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return pluralize2();
        });
      } else {
        root.pluralize = pluralize2();
      }
    })(exports, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function sanitizeRule(rule) {
        if (typeof rule === "string") {
          return new RegExp("^" + rule + "$", "i");
        }
        return rule;
      }
      __name(sanitizeRule, "sanitizeRule");
      function restoreCase(word, token) {
        if (word === token) return token;
        if (word === word.toLowerCase()) return token.toLowerCase();
        if (word === word.toUpperCase()) return token.toUpperCase();
        if (word[0] === word[0].toUpperCase()) {
          return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
        }
        return token.toLowerCase();
      }
      __name(restoreCase, "restoreCase");
      function interpolate(str2, args) {
        return str2.replace(/\$(\d{1,2})/g, function(match, index) {
          return args[index] || "";
        });
      }
      __name(interpolate, "interpolate");
      function replace(word, rule) {
        return word.replace(rule[0], function(match, index) {
          var result = interpolate(rule[1], arguments);
          if (match === "") {
            return restoreCase(word[index - 1], result);
          }
          return restoreCase(match, result);
        });
      }
      __name(replace, "replace");
      function sanitizeWord(token, word, rules) {
        if (!token.length || uncountables.hasOwnProperty(token)) {
          return word;
        }
        var len = rules.length;
        while (len--) {
          var rule = rules[len];
          if (rule[0].test(word)) return replace(word, rule);
        }
        return word;
      }
      __name(sanitizeWord, "sanitizeWord");
      function replaceWord(replaceMap, keepMap, rules) {
        return function(word) {
          var token = word.toLowerCase();
          if (keepMap.hasOwnProperty(token)) {
            return restoreCase(word, token);
          }
          if (replaceMap.hasOwnProperty(token)) {
            return restoreCase(word, replaceMap[token]);
          }
          return sanitizeWord(token, word, rules);
        };
      }
      __name(replaceWord, "replaceWord");
      function checkWord(replaceMap, keepMap, rules, bool) {
        return function(word) {
          var token = word.toLowerCase();
          if (keepMap.hasOwnProperty(token)) return true;
          if (replaceMap.hasOwnProperty(token)) return false;
          return sanitizeWord(token, token, rules) === token;
        };
      }
      __name(checkWord, "checkWord");
      function pluralize2(word, count3, inclusive) {
        var pluralized = count3 === 1 ? pluralize2.singular(word) : pluralize2.plural(word);
        return (inclusive ? count3 + " " : "") + pluralized;
      }
      __name(pluralize2, "pluralize");
      pluralize2.plural = replaceWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.isPlural = checkWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.singular = replaceWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.isSingular = checkWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.addPluralRule = function(rule, replacement) {
        pluralRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addSingularRule = function(rule, replacement) {
        singularRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addUncountableRule = function(word) {
        if (typeof word === "string") {
          uncountables[word.toLowerCase()] = true;
          return;
        }
        pluralize2.addPluralRule(word, "$0");
        pluralize2.addSingularRule(word, "$0");
      };
      pluralize2.addIrregularRule = function(single, plural) {
        plural = plural.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural;
        irregularPlurals[plural] = single;
      };
      [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(rule) {
        return pluralize2.addIrregularRule(rule[0], rule[1]);
      });
      [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(rule) {
        return pluralize2.addPluralRule(rule[0], rule[1]);
      });
      [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(rule) {
        return pluralize2.addSingularRule(rule[0], rule[1]);
      });
      [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[eé]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(pluralize2.addUncountableRule);
      return pluralize2;
    });
  }
});

// node_modules/cli-progress/lib/eta.js
var require_eta = __commonJS({
  "node_modules/cli-progress/lib/eta.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ETA = class {
      static {
        __name(this, "ETA");
      }
      constructor(length, initTime, initValue) {
        this.etaBufferLength = length || 100;
        this.valueBuffer = [initValue];
        this.timeBuffer = [initTime];
        this.eta = "0";
      }
      // add new values to calculation buffer
      update(time3, value, total) {
        this.valueBuffer.push(value);
        this.timeBuffer.push(time3);
        this.calculate(total - value);
      }
      // fetch estimated time
      getTime() {
        return this.eta;
      }
      // eta calculation - request number of remaining events
      calculate(remaining) {
        const currentBufferSize = this.valueBuffer.length;
        const buffer = Math.min(this.etaBufferLength, currentBufferSize);
        const v_diff = this.valueBuffer[currentBufferSize - 1] - this.valueBuffer[currentBufferSize - buffer];
        const t_diff = this.timeBuffer[currentBufferSize - 1] - this.timeBuffer[currentBufferSize - buffer];
        const vt_rate = v_diff / t_diff;
        this.valueBuffer = this.valueBuffer.slice(-this.etaBufferLength);
        this.timeBuffer = this.timeBuffer.slice(-this.etaBufferLength);
        const eta = Math.ceil(remaining / vt_rate / 1e3);
        if (isNaN(eta)) {
          this.eta = "NULL";
        } else if (!isFinite(eta)) {
          this.eta = "INF";
        } else if (eta > 1e7) {
          this.eta = "INF";
        } else if (eta < 0) {
          this.eta = 0;
        } else {
          this.eta = eta;
        }
      }
    };
    module.exports = ETA;
  }
});

// node_modules/unenv/dist/runtime/node/internal/readline/interface.mjs
import { EventEmitter as EventEmitter3 } from "node:events";
var Interface;
var init_interface = __esm({
  "node_modules/unenv/dist/runtime/node/internal/readline/interface.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Interface = class extends EventEmitter3 {
      static {
        __name(this, "Interface");
      }
      terminal = false;
      line = "";
      cursor = 0;
      getPrompt() {
        return "";
      }
      setPrompt(prompt) {
      }
      prompt(preserveCursor) {
      }
      question(query, options, callback) {
        callback && typeof callback === "function" && callback("");
      }
      resume() {
        return this;
      }
      close() {
      }
      write(data, key) {
      }
      getCursorPos() {
        return {
          rows: 0,
          cols: 0
        };
      }
      pause() {
        return this;
      }
      async *[Symbol.asyncIterator]() {
        yield "";
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/readline/promises/interface.mjs
var Interface2;
var init_interface2 = __esm({
  "node_modules/unenv/dist/runtime/node/internal/readline/promises/interface.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_interface();
    Interface2 = class extends Interface {
      static {
        __name(this, "Interface");
      }
      question(query, options) {
        return Promise.resolve("");
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/readline/promises/readline.mjs
var Readline;
var init_readline = __esm({
  "node_modules/unenv/dist/runtime/node/internal/readline/promises/readline.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Readline = class {
      static {
        __name(this, "Readline");
      }
      clearLine(dir4) {
        return this;
      }
      clearScreenDown() {
        return this;
      }
      commit() {
        return Promise.resolve();
      }
      cursorTo(x, y) {
        return this;
      }
      moveCursor(dx, dy) {
        return this;
      }
      rollback() {
        return this;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/readline/promises.mjs
var createInterface, promises_default2;
var init_promises3 = __esm({
  "node_modules/unenv/dist/runtime/node/readline/promises.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_interface2();
    init_readline();
    createInterface = /* @__PURE__ */ __name(() => new Interface2(), "createInterface");
    promises_default2 = {
      Interface: Interface2,
      Readline,
      createInterface
    };
  }
});

// node_modules/unenv/dist/runtime/node/readline.mjs
var clearLine, clearScreenDown, createInterface2, cursorTo, emitKeypressEvents, moveCursor, readline_default;
var init_readline2 = __esm({
  "node_modules/unenv/dist/runtime/node/readline.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_promises3();
    init_interface();
    clearLine = /* @__PURE__ */ __name(() => false, "clearLine");
    clearScreenDown = /* @__PURE__ */ __name(() => false, "clearScreenDown");
    createInterface2 = /* @__PURE__ */ __name(() => new Interface(), "createInterface");
    cursorTo = /* @__PURE__ */ __name(() => false, "cursorTo");
    emitKeypressEvents = noop_default;
    moveCursor = /* @__PURE__ */ __name(() => false, "moveCursor");
    readline_default = {
      clearLine,
      clearScreenDown,
      createInterface: createInterface2,
      cursorTo,
      emitKeypressEvents,
      moveCursor,
      Interface,
      promises: promises_default2
    };
  }
});

// node-built-in-modules:readline
var require_readline = __commonJS({
  "node-built-in-modules:readline"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_readline2();
    module.exports = readline_default;
  }
});

// node_modules/cli-progress/lib/terminal.js
var require_terminal = __commonJS({
  "node_modules/cli-progress/lib/terminal.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _readline = require_readline();
    var Terminal = class {
      static {
        __name(this, "Terminal");
      }
      constructor(outputStream) {
        this.stream = outputStream;
        this.linewrap = true;
        this.dy = 0;
      }
      // save cursor position + settings
      cursorSave() {
        if (!this.stream.isTTY) {
          return;
        }
        this.stream.write("\x1B7");
      }
      // restore last cursor position + settings
      cursorRestore() {
        if (!this.stream.isTTY) {
          return;
        }
        this.stream.write("\x1B8");
      }
      // show/hide cursor
      cursor(enabled) {
        if (!this.stream.isTTY) {
          return;
        }
        if (enabled) {
          this.stream.write("\x1B[?25h");
        } else {
          this.stream.write("\x1B[?25l");
        }
      }
      // change cursor positionn
      cursorTo(x = null, y = null) {
        if (!this.stream.isTTY) {
          return;
        }
        _readline.cursorTo(this.stream, x, y);
      }
      // change relative cursor position
      cursorRelative(dx = null, dy = null) {
        if (!this.stream.isTTY) {
          return;
        }
        this.dy = this.dy + dy;
        _readline.moveCursor(this.stream, dx, dy);
      }
      // relative reset
      cursorRelativeReset() {
        if (!this.stream.isTTY) {
          return;
        }
        _readline.moveCursor(this.stream, 0, -this.dy);
        _readline.cursorTo(this.stream, 0, null);
        this.dy = 0;
      }
      // clear to the right from cursor
      clearRight() {
        if (!this.stream.isTTY) {
          return;
        }
        _readline.clearLine(this.stream, 1);
      }
      // clear the full line
      clearLine() {
        if (!this.stream.isTTY) {
          return;
        }
        _readline.clearLine(this.stream, 0);
      }
      // clear everyting beyond the current line
      clearBottom() {
        if (!this.stream.isTTY) {
          return;
        }
        _readline.clearScreenDown(this.stream);
      }
      // add new line; increment counter
      newline() {
        this.stream.write("\n");
        this.dy++;
      }
      // write content to output stream
      // @TODO use string-width to strip length
      write(s, rawWrite = false) {
        if (this.linewrap === true && rawWrite === false) {
          this.stream.write(s.substr(0, this.getWidth()));
        } else {
          this.stream.write(s);
        }
      }
      // control line wrapping
      lineWrapping(enabled) {
        if (!this.stream.isTTY) {
          return;
        }
        this.linewrap = enabled;
        if (enabled) {
          this.stream.write("\x1B[?7h");
        } else {
          this.stream.write("\x1B[?7l");
        }
      }
      // tty environment ?
      isTTY() {
        return this.stream.isTTY === true;
      }
      // get terminal width
      getWidth() {
        return this.stream.columns || (this.stream.isTTY ? 80 : 200);
      }
    };
    module.exports = Terminal;
  }
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/ansi-regex/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "node_modules/strip-ansi/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ansiRegex = require_ansi_regex();
    module.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  }
});

// node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS({
  "node_modules/is-fullwidth-code-point/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isFullwidthCodePoint = /* @__PURE__ */ __name((codePoint) => {
      if (Number.isNaN(codePoint)) {
        return false;
      }
      if (codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
      codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
      codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
      // CJK Radicals Supplement .. Enclosed CJK Letters and Months
      11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
      12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
      19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
      43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
      44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
      63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
      65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
      65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
      65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
      110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
      127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
      131072 <= codePoint && codePoint <= 262141)) {
        return true;
      }
      return false;
    }, "isFullwidthCodePoint");
    module.exports = isFullwidthCodePoint;
    module.exports.default = isFullwidthCodePoint;
  }
});

// node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "node_modules/emoji-regex/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// node_modules/string-width/index.js
var require_string_width = __commonJS({
  "node_modules/string-width/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var stripAnsi = require_strip_ansi();
    var isFullwidthCodePoint = require_is_fullwidth_code_point();
    var emojiRegex2 = require_emoji_regex();
    var stringWidth = /* @__PURE__ */ __name((string) => {
      if (typeof string !== "string" || string.length === 0) {
        return 0;
      }
      string = stripAnsi(string);
      if (string.length === 0) {
        return 0;
      }
      string = string.replace(emojiRegex2(), "  ");
      let width = 0;
      for (let i = 0; i < string.length; i++) {
        const code = string.codePointAt(i);
        if (code <= 31 || code >= 127 && code <= 159) {
          continue;
        }
        if (code >= 768 && code <= 879) {
          continue;
        }
        if (code > 65535) {
          i++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
      }
      return width;
    }, "stringWidth");
    module.exports = stringWidth;
    module.exports.default = stringWidth;
  }
});

// node_modules/cli-progress/lib/format-value.js
var require_format_value = __commonJS({
  "node_modules/cli-progress/lib/format-value.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function formatValue(v, options, type) {
      if (options.autopadding !== true) {
        return v;
      }
      function autopadding(value, length) {
        return (options.autopaddingChar + value).slice(-length);
      }
      __name(autopadding, "autopadding");
      switch (type) {
        case "percentage":
          return autopadding(v, 3);
        default:
          return v;
      }
    }, "formatValue");
  }
});

// node_modules/cli-progress/lib/format-bar.js
var require_format_bar = __commonJS({
  "node_modules/cli-progress/lib/format-bar.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function formatBar(progress, options) {
      const completeSize = Math.round(progress * options.barsize);
      const incompleteSize = options.barsize - completeSize;
      return options.barCompleteString.substr(0, completeSize) + options.barGlue + options.barIncompleteString.substr(0, incompleteSize);
    }, "formatBar");
  }
});

// node_modules/cli-progress/lib/format-time.js
var require_format_time = __commonJS({
  "node_modules/cli-progress/lib/format-time.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function formatTime(t, options, roundToMultipleOf) {
      function round(input) {
        if (roundToMultipleOf) {
          return roundToMultipleOf * Math.round(input / roundToMultipleOf);
        } else {
          return input;
        }
      }
      __name(round, "round");
      function autopadding(v) {
        return (options.autopaddingChar + v).slice(-2);
      }
      __name(autopadding, "autopadding");
      if (t > 3600) {
        return autopadding(Math.floor(t / 3600)) + "h" + autopadding(round(t % 3600 / 60)) + "m";
      } else if (t > 60) {
        return autopadding(Math.floor(t / 60)) + "m" + autopadding(round(t % 60)) + "s";
      } else if (t > 10) {
        return autopadding(round(t)) + "s";
      } else {
        return autopadding(t) + "s";
      }
    }, "formatTime");
  }
});

// node_modules/cli-progress/lib/formatter.js
var require_formatter = __commonJS({
  "node_modules/cli-progress/lib/formatter.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _stringWidth = require_string_width();
    var _defaultFormatValue = require_format_value();
    var _defaultFormatBar = require_format_bar();
    var _defaultFormatTime = require_format_time();
    module.exports = /* @__PURE__ */ __name(function defaultFormatter(options, params, payload) {
      let s = options.format;
      const formatTime = options.formatTime || _defaultFormatTime;
      const formatValue = options.formatValue || _defaultFormatValue;
      const formatBar = options.formatBar || _defaultFormatBar;
      const percentage = Math.floor(params.progress * 100) + "";
      const stopTime = params.stopTime || Date.now();
      const elapsedTime = Math.round((stopTime - params.startTime) / 1e3);
      const context3 = Object.assign({}, payload, {
        bar: formatBar(params.progress, options),
        percentage: formatValue(percentage, options, "percentage"),
        total: formatValue(params.total, options, "total"),
        value: formatValue(params.value, options, "value"),
        eta: formatValue(params.eta, options, "eta"),
        eta_formatted: formatTime(params.eta, options, 5),
        duration: formatValue(elapsedTime, options, "duration"),
        duration_formatted: formatTime(elapsedTime, options, 1)
      });
      s = s.replace(/\{(\w+)\}/g, function(match, key) {
        if (typeof context3[key] !== "undefined") {
          return context3[key];
        }
        return match;
      });
      const fullMargin = Math.max(0, params.maxWidth - _stringWidth(s) - 2);
      const halfMargin = Math.floor(fullMargin / 2);
      switch (options.align) {
        // fill start-of-line with whitespaces
        case "right":
          s = fullMargin > 0 ? " ".repeat(fullMargin) + s : s;
          break;
        // distribute whitespaces to left+right
        case "center":
          s = halfMargin > 0 ? " ".repeat(halfMargin) + s : s;
          break;
        // default: left align, no additional whitespaces
        case "left":
        default:
          break;
      }
      return s;
    }, "defaultFormatter");
  }
});

// node_modules/cli-progress/lib/options.js
var require_options = __commonJS({
  "node_modules/cli-progress/lib/options.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function mergeOption(v, defaultValue) {
      if (typeof v === "undefined" || v === null) {
        return defaultValue;
      } else {
        return v;
      }
    }
    __name(mergeOption, "mergeOption");
    module.exports = {
      // set global options
      parse: /* @__PURE__ */ __name(function parse4(rawOptions, preset) {
        const options = {};
        const opt = Object.assign({}, preset, rawOptions);
        options.throttleTime = 1e3 / mergeOption(opt.fps, 10);
        options.stream = mergeOption(opt.stream, process.stderr);
        options.terminal = mergeOption(opt.terminal, null);
        options.clearOnComplete = mergeOption(opt.clearOnComplete, false);
        options.stopOnComplete = mergeOption(opt.stopOnComplete, false);
        options.barsize = mergeOption(opt.barsize, 40);
        options.align = mergeOption(opt.align, "left");
        options.hideCursor = mergeOption(opt.hideCursor, false);
        options.linewrap = mergeOption(opt.linewrap, false);
        options.barGlue = mergeOption(opt.barGlue, "");
        options.barCompleteChar = mergeOption(opt.barCompleteChar, "=");
        options.barIncompleteChar = mergeOption(opt.barIncompleteChar, "-");
        options.format = mergeOption(opt.format, "progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}");
        options.formatTime = mergeOption(opt.formatTime, null);
        options.formatValue = mergeOption(opt.formatValue, null);
        options.formatBar = mergeOption(opt.formatBar, null);
        options.etaBufferLength = mergeOption(opt.etaBuffer, 10);
        options.etaAsynchronousUpdate = mergeOption(opt.etaAsynchronousUpdate, false);
        options.progressCalculationRelative = mergeOption(opt.progressCalculationRelative, false);
        options.synchronousUpdate = mergeOption(opt.synchronousUpdate, true);
        options.noTTYOutput = mergeOption(opt.noTTYOutput, false);
        options.notTTYSchedule = mergeOption(opt.notTTYSchedule, 2e3);
        options.emptyOnZero = mergeOption(opt.emptyOnZero, false);
        options.forceRedraw = mergeOption(opt.forceRedraw, false);
        options.autopadding = mergeOption(opt.autopadding, false);
        options.gracefulExit = mergeOption(opt.gracefulExit, false);
        return options;
      }, "parse"),
      // derived options: instance specific, has to be created for every bar element
      assignDerivedOptions: /* @__PURE__ */ __name(function assignDerivedOptions(options) {
        options.barCompleteString = options.barCompleteChar.repeat(options.barsize + 1);
        options.barIncompleteString = options.barIncompleteChar.repeat(options.barsize + 1);
        options.autopaddingChar = options.autopadding ? mergeOption(options.autopaddingChar, "   ") : "";
        return options;
      }, "assignDerivedOptions")
    };
  }
});

// node-built-in-modules:events
import libDefault2 from "events";
var require_events = __commonJS({
  "node-built-in-modules:events"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault2;
  }
});

// node_modules/cli-progress/lib/generic-bar.js
var require_generic_bar = __commonJS({
  "node_modules/cli-progress/lib/generic-bar.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _ETA = require_eta();
    var _Terminal = require_terminal();
    var _formatter = require_formatter();
    var _options = require_options();
    var _EventEmitter = require_events();
    module.exports = class GenericBar extends _EventEmitter {
      static {
        __name(this, "GenericBar");
      }
      constructor(options) {
        super();
        this.options = _options.assignDerivedOptions(options);
        this.terminal = this.options.terminal ? this.options.terminal : new _Terminal(this.options.stream);
        this.value = 0;
        this.startValue = 0;
        this.total = 100;
        this.lastDrawnString = null;
        this.startTime = null;
        this.stopTime = null;
        this.lastRedraw = Date.now();
        this.eta = new _ETA(this.options.etaBufferLength, 0, 0);
        this.payload = {};
        this.isActive = false;
        this.formatter = typeof this.options.format === "function" ? this.options.format : _formatter;
      }
      // internal render function
      render(forceRendering = false) {
        const params = {
          progress: this.getProgress(),
          eta: this.eta.getTime(),
          startTime: this.startTime,
          stopTime: this.stopTime,
          total: this.total,
          value: this.value,
          maxWidth: this.terminal.getWidth()
        };
        if (this.options.etaAsynchronousUpdate) {
          this.updateETA();
        }
        const s = this.formatter(this.options, params, this.payload);
        const forceRedraw = forceRendering || this.options.forceRedraw || this.options.noTTYOutput && !this.terminal.isTTY();
        if (forceRedraw || this.lastDrawnString != s) {
          this.emit("redraw-pre");
          this.terminal.cursorTo(0, null);
          this.terminal.write(s);
          this.terminal.clearRight();
          this.lastDrawnString = s;
          this.lastRedraw = Date.now();
          this.emit("redraw-post");
        }
      }
      // start the progress bar
      start(total, startValue, payload) {
        this.value = startValue || 0;
        this.total = typeof total !== "undefined" && total >= 0 ? total : 100;
        this.startValue = startValue || 0;
        this.payload = payload || {};
        this.startTime = Date.now();
        this.stopTime = null;
        this.lastDrawnString = "";
        this.eta = new _ETA(this.options.etaBufferLength, this.startTime, this.value);
        this.isActive = true;
        this.emit("start", total, startValue);
      }
      // stop the bar
      stop() {
        this.isActive = false;
        this.stopTime = Date.now();
        this.emit("stop", this.total, this.value);
      }
      // update the bar value
      // update(value, payload)
      // update(payload)
      update(arg0, arg1 = {}) {
        if (typeof arg0 === "number") {
          this.value = arg0;
          this.eta.update(Date.now(), arg0, this.total);
        }
        const payloadData = (typeof arg0 === "object" ? arg0 : arg1) || {};
        this.emit("update", this.total, this.value);
        for (const key in payloadData) {
          this.payload[key] = payloadData[key];
        }
        if (this.value >= this.getTotal() && this.options.stopOnComplete) {
          this.stop();
        }
      }
      // calculate the actual progress value
      getProgress() {
        let progress = this.value / this.total;
        if (this.options.progressCalculationRelative) {
          progress = (this.value - this.startValue) / (this.total - this.startValue);
        }
        if (isNaN(progress)) {
          progress = this.options && this.options.emptyOnZero ? 0 : 1;
        }
        progress = Math.min(Math.max(progress, 0), 1);
        return progress;
      }
      // update the bar value
      // increment(delta, payload)
      // increment(payload)
      increment(arg0 = 1, arg1 = {}) {
        if (typeof arg0 === "object") {
          this.update(this.value + 1, arg0);
        } else {
          this.update(this.value + arg0, arg1);
        }
      }
      // get the total (limit) value
      getTotal() {
        return this.total;
      }
      // set the total (limit) value
      setTotal(total) {
        if (typeof total !== "undefined" && total >= 0) {
          this.total = total;
        }
      }
      // force eta calculation update (long running processes)
      updateETA() {
        this.eta.update(Date.now(), this.value, this.total);
      }
    };
  }
});

// node_modules/cli-progress/lib/single-bar.js
var require_single_bar = __commonJS({
  "node_modules/cli-progress/lib/single-bar.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _GenericBar = require_generic_bar();
    var _options = require_options();
    module.exports = class SingleBar extends _GenericBar {
      static {
        __name(this, "SingleBar");
      }
      constructor(options, preset) {
        super(_options.parse(options, preset));
        this.timer = null;
        if (this.options.noTTYOutput && this.terminal.isTTY() === false) {
          this.options.synchronousUpdate = false;
        }
        this.schedulingRate = this.terminal.isTTY() ? this.options.throttleTime : this.options.notTTYSchedule;
        this.sigintCallback = null;
      }
      // internal render function
      render() {
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
        super.render();
        if (this.options.noTTYOutput && this.terminal.isTTY() === false) {
          this.terminal.newline();
        }
        this.timer = setTimeout(this.render.bind(this), this.schedulingRate);
      }
      update(current, payload) {
        if (!this.timer) {
          return;
        }
        super.update(current, payload);
        if (this.options.synchronousUpdate && this.lastRedraw + this.options.throttleTime * 2 < Date.now()) {
          this.render();
        }
      }
      // start the progress bar
      start(total, startValue, payload) {
        if (this.options.noTTYOutput === false && this.terminal.isTTY() === false) {
          return;
        }
        if (this.sigintCallback === null && this.options.gracefulExit) {
          this.sigintCallback = this.stop.bind(this);
          process.once("SIGINT", this.sigintCallback);
          process.once("SIGTERM", this.sigintCallback);
        }
        this.terminal.cursorSave();
        if (this.options.hideCursor === true) {
          this.terminal.cursor(false);
        }
        if (this.options.linewrap === false) {
          this.terminal.lineWrapping(false);
        }
        super.start(total, startValue, payload);
        this.render();
      }
      // stop the bar
      stop() {
        if (!this.timer) {
          return;
        }
        if (this.sigintCallback) {
          process.removeListener("SIGINT", this.sigintCallback);
          process.removeListener("SIGTERM", this.sigintCallback);
          this.sigintCallback = null;
        }
        this.render();
        super.stop();
        clearTimeout(this.timer);
        this.timer = null;
        if (this.options.hideCursor === true) {
          this.terminal.cursor(true);
        }
        if (this.options.linewrap === false) {
          this.terminal.lineWrapping(true);
        }
        this.terminal.cursorRestore();
        if (this.options.clearOnComplete) {
          this.terminal.cursorTo(0, null);
          this.terminal.clearLine();
        } else {
          this.terminal.newline();
        }
      }
    };
  }
});

// node_modules/cli-progress/lib/multi-bar.js
var require_multi_bar = __commonJS({
  "node_modules/cli-progress/lib/multi-bar.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _Terminal = require_terminal();
    var _BarElement = require_generic_bar();
    var _options = require_options();
    var _EventEmitter = require_events();
    module.exports = class MultiBar extends _EventEmitter {
      static {
        __name(this, "MultiBar");
      }
      constructor(options, preset) {
        super();
        this.bars = [];
        this.options = _options.parse(options, preset);
        this.options.synchronousUpdate = false;
        this.terminal = this.options.terminal ? this.options.terminal : new _Terminal(this.options.stream);
        this.timer = null;
        this.isActive = false;
        this.schedulingRate = this.terminal.isTTY() ? this.options.throttleTime : this.options.notTTYSchedule;
        this.loggingBuffer = [];
        this.sigintCallback = null;
      }
      // add a new bar to the stack
      create(total, startValue, payload, barOptions = {}) {
        const bar = new _BarElement(Object.assign(
          {},
          // global options
          this.options,
          // terminal instance
          {
            terminal: this.terminal
          },
          // overrides
          barOptions
        ));
        this.bars.push(bar);
        if (this.options.noTTYOutput === false && this.terminal.isTTY() === false) {
          return bar;
        }
        if (this.sigintCallback === null && this.options.gracefulExit) {
          this.sigintCallback = this.stop.bind(this);
          process.once("SIGINT", this.sigintCallback);
          process.once("SIGTERM", this.sigintCallback);
        }
        if (!this.isActive) {
          if (this.options.hideCursor === true) {
            this.terminal.cursor(false);
          }
          if (this.options.linewrap === false) {
            this.terminal.lineWrapping(false);
          }
          this.timer = setTimeout(this.update.bind(this), this.schedulingRate);
        }
        this.isActive = true;
        bar.start(total, startValue, payload);
        this.emit("start");
        return bar;
      }
      // remove a bar from the stack
      remove(bar) {
        const index = this.bars.indexOf(bar);
        if (index < 0) {
          return false;
        }
        this.bars.splice(index, 1);
        this.update();
        this.terminal.newline();
        this.terminal.clearBottom();
        return true;
      }
      // internal update routine
      update() {
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
        this.emit("update-pre");
        this.terminal.cursorRelativeReset();
        this.emit("redraw-pre");
        if (this.loggingBuffer.length > 0) {
          this.terminal.clearLine();
          while (this.loggingBuffer.length > 0) {
            this.terminal.write(this.loggingBuffer.shift(), true);
          }
        }
        for (let i = 0; i < this.bars.length; i++) {
          if (i > 0) {
            this.terminal.newline();
          }
          this.bars[i].render();
        }
        this.emit("redraw-post");
        if (this.options.noTTYOutput && this.terminal.isTTY() === false) {
          this.terminal.newline();
          this.terminal.newline();
        }
        this.timer = setTimeout(this.update.bind(this), this.schedulingRate);
        this.emit("update-post");
        if (this.options.stopOnComplete && !this.bars.find((bar) => bar.isActive)) {
          this.stop();
        }
      }
      stop() {
        clearTimeout(this.timer);
        this.timer = null;
        if (this.sigintCallback) {
          process.removeListener("SIGINT", this.sigintCallback);
          process.removeListener("SIGTERM", this.sigintCallback);
          this.sigintCallback = null;
        }
        this.isActive = false;
        if (this.options.hideCursor === true) {
          this.terminal.cursor(true);
        }
        if (this.options.linewrap === false) {
          this.terminal.lineWrapping(true);
        }
        this.terminal.cursorRelativeReset();
        this.emit("stop-pre-clear");
        if (this.options.clearOnComplete) {
          this.terminal.clearBottom();
        } else {
          for (let i = 0; i < this.bars.length; i++) {
            if (i > 0) {
              this.terminal.newline();
            }
            this.bars[i].render();
            this.bars[i].stop();
          }
          this.terminal.newline();
        }
        this.emit("stop");
      }
      log(s) {
        this.loggingBuffer.push(s);
      }
    };
  }
});

// node_modules/cli-progress/presets/legacy.js
var require_legacy = __commonJS({
  "node_modules/cli-progress/presets/legacy.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      format: "progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}",
      barCompleteChar: "=",
      barIncompleteChar: "-"
    };
  }
});

// node_modules/cli-progress/presets/shades-classic.js
var require_shades_classic = __commonJS({
  "node_modules/cli-progress/presets/shades-classic.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      format: " {bar} {percentage}% | ETA: {eta}s | {value}/{total}",
      barCompleteChar: "\u2588",
      barIncompleteChar: "\u2591"
    };
  }
});

// node_modules/cli-progress/presets/shades-grey.js
var require_shades_grey = __commonJS({
  "node_modules/cli-progress/presets/shades-grey.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      format: " \x1B[90m{bar}\x1B[0m {percentage}% | ETA: {eta}s | {value}/{total}",
      barCompleteChar: "\u2588",
      barIncompleteChar: "\u2591"
    };
  }
});

// node_modules/cli-progress/presets/rect.js
var require_rect = __commonJS({
  "node_modules/cli-progress/presets/rect.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      format: " {bar}\u25A0 {percentage}% | ETA: {eta}s | {value}/{total}",
      barCompleteChar: "\u25A0",
      barIncompleteChar: " "
    };
  }
});

// node_modules/cli-progress/presets/index.js
var require_presets = __commonJS({
  "node_modules/cli-progress/presets/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _legacy = require_legacy();
    var _shades_classic = require_shades_classic();
    var _shades_grey = require_shades_grey();
    var _rect = require_rect();
    module.exports = {
      legacy: _legacy,
      shades_classic: _shades_classic,
      shades_grey: _shades_grey,
      rect: _rect
    };
  }
});

// node_modules/cli-progress/cli-progress.js
var require_cli_progress = __commonJS({
  "node_modules/cli-progress/cli-progress.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _SingleBar = require_single_bar();
    var _MultiBar = require_multi_bar();
    var _Presets = require_presets();
    var _Formatter = require_formatter();
    var _defaultFormatValue = require_format_value();
    var _defaultFormatBar = require_format_bar();
    var _defaultFormatTime = require_format_time();
    module.exports = {
      Bar: _SingleBar,
      SingleBar: _SingleBar,
      MultiBar: _MultiBar,
      Presets: _Presets,
      Format: {
        Formatter: _Formatter,
        BarFormat: _defaultFormatBar,
        ValueFormat: _defaultFormatValue,
        TimeFormat: _defaultFormatTime
      }
    };
  }
});

// node_modules/slugify/slugify.js
var require_slugify = __commonJS({
  "node_modules/slugify/slugify.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(name, root, factory) {
      if (typeof exports === "object") {
        module.exports = factory();
        module.exports["default"] = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root[name] = factory();
      }
    })("slugify", exports, function() {
      var charMap = JSON.parse(`{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","\xA2":"cent","\xA3":"pound","\xA4":"currency","\xA5":"yen","\xA9":"(c)","\xAA":"a","\xAE":"(r)","\xBA":"o","\xC0":"A","\xC1":"A","\xC2":"A","\xC3":"A","\xC4":"A","\xC5":"A","\xC6":"AE","\xC7":"C","\xC8":"E","\xC9":"E","\xCA":"E","\xCB":"E","\xCC":"I","\xCD":"I","\xCE":"I","\xCF":"I","\xD0":"D","\xD1":"N","\xD2":"O","\xD3":"O","\xD4":"O","\xD5":"O","\xD6":"O","\xD8":"O","\xD9":"U","\xDA":"U","\xDB":"U","\xDC":"U","\xDD":"Y","\xDE":"TH","\xDF":"ss","\xE0":"a","\xE1":"a","\xE2":"a","\xE3":"a","\xE4":"a","\xE5":"a","\xE6":"ae","\xE7":"c","\xE8":"e","\xE9":"e","\xEA":"e","\xEB":"e","\xEC":"i","\xED":"i","\xEE":"i","\xEF":"i","\xF0":"d","\xF1":"n","\xF2":"o","\xF3":"o","\xF4":"o","\xF5":"o","\xF6":"o","\xF8":"o","\xF9":"u","\xFA":"u","\xFB":"u","\xFC":"u","\xFD":"y","\xFE":"th","\xFF":"y","\u0100":"A","\u0101":"a","\u0102":"A","\u0103":"a","\u0104":"A","\u0105":"a","\u0106":"C","\u0107":"c","\u010C":"C","\u010D":"c","\u010E":"D","\u010F":"d","\u0110":"DJ","\u0111":"dj","\u0112":"E","\u0113":"e","\u0116":"E","\u0117":"e","\u0118":"e","\u0119":"e","\u011A":"E","\u011B":"e","\u011E":"G","\u011F":"g","\u0122":"G","\u0123":"g","\u0128":"I","\u0129":"i","\u012A":"i","\u012B":"i","\u012E":"I","\u012F":"i","\u0130":"I","\u0131":"i","\u0136":"k","\u0137":"k","\u013B":"L","\u013C":"l","\u013D":"L","\u013E":"l","\u0141":"L","\u0142":"l","\u0143":"N","\u0144":"n","\u0145":"N","\u0146":"n","\u0147":"N","\u0148":"n","\u014C":"O","\u014D":"o","\u0150":"O","\u0151":"o","\u0152":"OE","\u0153":"oe","\u0154":"R","\u0155":"r","\u0158":"R","\u0159":"r","\u015A":"S","\u015B":"s","\u015E":"S","\u015F":"s","\u0160":"S","\u0161":"s","\u0162":"T","\u0163":"t","\u0164":"T","\u0165":"t","\u0168":"U","\u0169":"u","\u016A":"u","\u016B":"u","\u016E":"U","\u016F":"u","\u0170":"U","\u0171":"u","\u0172":"U","\u0173":"u","\u0174":"W","\u0175":"w","\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017A":"z","\u017B":"Z","\u017C":"z","\u017D":"Z","\u017E":"z","\u018F":"E","\u0192":"f","\u01A0":"O","\u01A1":"o","\u01AF":"U","\u01B0":"u","\u01C8":"LJ","\u01C9":"lj","\u01CB":"NJ","\u01CC":"nj","\u0218":"S","\u0219":"s","\u021A":"T","\u021B":"t","\u0259":"e","\u02DA":"o","\u0386":"A","\u0388":"E","\u0389":"H","\u038A":"I","\u038C":"O","\u038E":"Y","\u038F":"W","\u0390":"i","\u0391":"A","\u0392":"B","\u0393":"G","\u0394":"D","\u0395":"E","\u0396":"Z","\u0397":"H","\u0398":"8","\u0399":"I","\u039A":"K","\u039B":"L","\u039C":"M","\u039D":"N","\u039E":"3","\u039F":"O","\u03A0":"P","\u03A1":"R","\u03A3":"S","\u03A4":"T","\u03A5":"Y","\u03A6":"F","\u03A7":"X","\u03A8":"PS","\u03A9":"W","\u03AA":"I","\u03AB":"Y","\u03AC":"a","\u03AD":"e","\u03AE":"h","\u03AF":"i","\u03B0":"y","\u03B1":"a","\u03B2":"b","\u03B3":"g","\u03B4":"d","\u03B5":"e","\u03B6":"z","\u03B7":"h","\u03B8":"8","\u03B9":"i","\u03BA":"k","\u03BB":"l","\u03BC":"m","\u03BD":"n","\u03BE":"3","\u03BF":"o","\u03C0":"p","\u03C1":"r","\u03C2":"s","\u03C3":"s","\u03C4":"t","\u03C5":"y","\u03C6":"f","\u03C7":"x","\u03C8":"ps","\u03C9":"w","\u03CA":"i","\u03CB":"y","\u03CC":"o","\u03CD":"y","\u03CE":"w","\u0401":"Yo","\u0402":"DJ","\u0404":"Ye","\u0406":"I","\u0407":"Yi","\u0408":"J","\u0409":"LJ","\u040A":"NJ","\u040B":"C","\u040F":"DZ","\u0410":"A","\u0411":"B","\u0412":"V","\u0413":"G","\u0414":"D","\u0415":"E","\u0416":"Zh","\u0417":"Z","\u0418":"I","\u0419":"J","\u041A":"K","\u041B":"L","\u041C":"M","\u041D":"N","\u041E":"O","\u041F":"P","\u0420":"R","\u0421":"S","\u0422":"T","\u0423":"U","\u0424":"F","\u0425":"H","\u0426":"C","\u0427":"Ch","\u0428":"Sh","\u0429":"Sh","\u042A":"U","\u042B":"Y","\u042C":"","\u042D":"E","\u042E":"Yu","\u042F":"Ya","\u0430":"a","\u0431":"b","\u0432":"v","\u0433":"g","\u0434":"d","\u0435":"e","\u0436":"zh","\u0437":"z","\u0438":"i","\u0439":"j","\u043A":"k","\u043B":"l","\u043C":"m","\u043D":"n","\u043E":"o","\u043F":"p","\u0440":"r","\u0441":"s","\u0442":"t","\u0443":"u","\u0444":"f","\u0445":"h","\u0446":"c","\u0447":"ch","\u0448":"sh","\u0449":"sh","\u044A":"u","\u044B":"y","\u044C":"","\u044D":"e","\u044E":"yu","\u044F":"ya","\u0451":"yo","\u0452":"dj","\u0454":"ye","\u0456":"i","\u0457":"yi","\u0458":"j","\u0459":"lj","\u045A":"nj","\u045B":"c","\u045D":"u","\u045F":"dz","\u0490":"G","\u0491":"g","\u0492":"GH","\u0493":"gh","\u049A":"KH","\u049B":"kh","\u04A2":"NG","\u04A3":"ng","\u04AE":"UE","\u04AF":"ue","\u04B0":"U","\u04B1":"u","\u04BA":"H","\u04BB":"h","\u04D8":"AE","\u04D9":"ae","\u04E8":"OE","\u04E9":"oe","\u0531":"A","\u0532":"B","\u0533":"G","\u0534":"D","\u0535":"E","\u0536":"Z","\u0537":"E'","\u0538":"Y'","\u0539":"T'","\u053A":"JH","\u053B":"I","\u053C":"L","\u053D":"X","\u053E":"C'","\u053F":"K","\u0540":"H","\u0541":"D'","\u0542":"GH","\u0543":"TW","\u0544":"M","\u0545":"Y","\u0546":"N","\u0547":"SH","\u0549":"CH","\u054A":"P","\u054B":"J","\u054C":"R'","\u054D":"S","\u054E":"V","\u054F":"T","\u0550":"R","\u0551":"C","\u0553":"P'","\u0554":"Q'","\u0555":"O''","\u0556":"F","\u0587":"EV","\u0621":"a","\u0622":"aa","\u0623":"a","\u0624":"u","\u0625":"i","\u0626":"e","\u0627":"a","\u0628":"b","\u0629":"h","\u062A":"t","\u062B":"th","\u062C":"j","\u062D":"h","\u062E":"kh","\u062F":"d","\u0630":"th","\u0631":"r","\u0632":"z","\u0633":"s","\u0634":"sh","\u0635":"s","\u0636":"dh","\u0637":"t","\u0638":"z","\u0639":"a","\u063A":"gh","\u0641":"f","\u0642":"q","\u0643":"k","\u0644":"l","\u0645":"m","\u0646":"n","\u0647":"h","\u0648":"w","\u0649":"a","\u064A":"y","\u064B":"an","\u064C":"on","\u064D":"en","\u064E":"a","\u064F":"u","\u0650":"e","\u0652":"","\u0660":"0","\u0661":"1","\u0662":"2","\u0663":"3","\u0664":"4","\u0665":"5","\u0666":"6","\u0667":"7","\u0668":"8","\u0669":"9","\u067E":"p","\u0686":"ch","\u0698":"zh","\u06A9":"k","\u06AF":"g","\u06CC":"y","\u06F0":"0","\u06F1":"1","\u06F2":"2","\u06F3":"3","\u06F4":"4","\u06F5":"5","\u06F6":"6","\u06F7":"7","\u06F8":"8","\u06F9":"9","\u0E3F":"baht","\u10D0":"a","\u10D1":"b","\u10D2":"g","\u10D3":"d","\u10D4":"e","\u10D5":"v","\u10D6":"z","\u10D7":"t","\u10D8":"i","\u10D9":"k","\u10DA":"l","\u10DB":"m","\u10DC":"n","\u10DD":"o","\u10DE":"p","\u10DF":"zh","\u10E0":"r","\u10E1":"s","\u10E2":"t","\u10E3":"u","\u10E4":"f","\u10E5":"k","\u10E6":"gh","\u10E7":"q","\u10E8":"sh","\u10E9":"ch","\u10EA":"ts","\u10EB":"dz","\u10EC":"ts","\u10ED":"ch","\u10EE":"kh","\u10EF":"j","\u10F0":"h","\u1E62":"S","\u1E63":"s","\u1E80":"W","\u1E81":"w","\u1E82":"W","\u1E83":"w","\u1E84":"W","\u1E85":"w","\u1E9E":"SS","\u1EA0":"A","\u1EA1":"a","\u1EA2":"A","\u1EA3":"a","\u1EA4":"A","\u1EA5":"a","\u1EA6":"A","\u1EA7":"a","\u1EA8":"A","\u1EA9":"a","\u1EAA":"A","\u1EAB":"a","\u1EAC":"A","\u1EAD":"a","\u1EAE":"A","\u1EAF":"a","\u1EB0":"A","\u1EB1":"a","\u1EB2":"A","\u1EB3":"a","\u1EB4":"A","\u1EB5":"a","\u1EB6":"A","\u1EB7":"a","\u1EB8":"E","\u1EB9":"e","\u1EBA":"E","\u1EBB":"e","\u1EBC":"E","\u1EBD":"e","\u1EBE":"E","\u1EBF":"e","\u1EC0":"E","\u1EC1":"e","\u1EC2":"E","\u1EC3":"e","\u1EC4":"E","\u1EC5":"e","\u1EC6":"E","\u1EC7":"e","\u1EC8":"I","\u1EC9":"i","\u1ECA":"I","\u1ECB":"i","\u1ECC":"O","\u1ECD":"o","\u1ECE":"O","\u1ECF":"o","\u1ED0":"O","\u1ED1":"o","\u1ED2":"O","\u1ED3":"o","\u1ED4":"O","\u1ED5":"o","\u1ED6":"O","\u1ED7":"o","\u1ED8":"O","\u1ED9":"o","\u1EDA":"O","\u1EDB":"o","\u1EDC":"O","\u1EDD":"o","\u1EDE":"O","\u1EDF":"o","\u1EE0":"O","\u1EE1":"o","\u1EE2":"O","\u1EE3":"o","\u1EE4":"U","\u1EE5":"u","\u1EE6":"U","\u1EE7":"u","\u1EE8":"U","\u1EE9":"u","\u1EEA":"U","\u1EEB":"u","\u1EEC":"U","\u1EED":"u","\u1EEE":"U","\u1EEF":"u","\u1EF0":"U","\u1EF1":"u","\u1EF2":"Y","\u1EF3":"y","\u1EF4":"Y","\u1EF5":"y","\u1EF6":"Y","\u1EF7":"y","\u1EF8":"Y","\u1EF9":"y","\u2013":"-","\u2018":"'","\u2019":"'","\u201C":"\\"","\u201D":"\\"","\u201E":"\\"","\u2020":"+","\u2022":"*","\u2026":"...","\u20A0":"ecu","\u20A2":"cruzeiro","\u20A3":"french franc","\u20A4":"lira","\u20A5":"mill","\u20A6":"naira","\u20A7":"peseta","\u20A8":"rupee","\u20A9":"won","\u20AA":"new shequel","\u20AB":"dong","\u20AC":"euro","\u20AD":"kip","\u20AE":"tugrik","\u20AF":"drachma","\u20B0":"penny","\u20B1":"peso","\u20B2":"guarani","\u20B3":"austral","\u20B4":"hryvnia","\u20B5":"cedi","\u20B8":"kazakhstani tenge","\u20B9":"indian rupee","\u20BA":"turkish lira","\u20BD":"russian ruble","\u20BF":"bitcoin","\u2120":"sm","\u2122":"tm","\u2202":"d","\u2206":"delta","\u2211":"sum","\u221E":"infinity","\u2665":"love","\u5143":"yuan","\u5186":"yen","\uFDFC":"rial","\uFEF5":"laa","\uFEF7":"laa","\uFEF9":"lai","\uFEFB":"la"}`);
      var locales = JSON.parse('{"bg":{"\u0419":"Y","\u0426":"Ts","\u0429":"Sht","\u042A":"A","\u042C":"Y","\u0439":"y","\u0446":"ts","\u0449":"sht","\u044A":"a","\u044C":"y"},"de":{"\xC4":"AE","\xE4":"ae","\xD6":"OE","\xF6":"oe","\xDC":"UE","\xFC":"ue","\xDF":"ss","%":"prozent","&":"und","|":"oder","\u2211":"summe","\u221E":"unendlich","\u2665":"liebe"},"es":{"%":"por ciento","&":"y","<":"menor que",">":"mayor que","|":"o","\xA2":"centavos","\xA3":"libras","\xA4":"moneda","\u20A3":"francos","\u2211":"suma","\u221E":"infinito","\u2665":"amor"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","\xA2":"centime","\xA3":"livre","\xA4":"devise","\u20A3":"franc","\u2211":"somme","\u221E":"infini","\u2665":"amour"},"pt":{"%":"porcento","&":"e","<":"menor",">":"maior","|":"ou","\xA2":"centavo","\u2211":"soma","\xA3":"libra","\u221E":"infinito","\u2665":"amor"},"uk":{"\u0418":"Y","\u0438":"y","\u0419":"Y","\u0439":"y","\u0426":"Ts","\u0446":"ts","\u0425":"Kh","\u0445":"kh","\u0429":"Shch","\u0449":"shch","\u0413":"H","\u0433":"h"},"vi":{"\u0110":"D","\u0111":"d"},"da":{"\xD8":"OE","\xF8":"oe","\xC5":"AA","\xE5":"aa","%":"procent","&":"og","|":"eller","$":"dollar","<":"mindre end",">":"st\xF8rre end"},"nb":{"&":"og","\xC5":"AA","\xC6":"AE","\xD8":"OE","\xE5":"aa","\xE6":"ae","\xF8":"oe"},"it":{"&":"e"},"nl":{"&":"en"},"sv":{"&":"och","\xC5":"AA","\xC4":"AE","\xD6":"OE","\xE5":"aa","\xE4":"ae","\xF6":"oe"}}');
      function replace(string, options) {
        if (typeof string !== "string") {
          throw new Error("slugify: string argument expected");
        }
        options = typeof options === "string" ? { replacement: options } : options || {};
        var locale = locales[options.locale] || {};
        var replacement = options.replacement === void 0 ? "-" : options.replacement;
        var trim = options.trim === void 0 ? true : options.trim;
        var slug = string.normalize().split("").reduce(function(result, ch) {
          var appendChar = locale[ch];
          if (appendChar === void 0) appendChar = charMap[ch];
          if (appendChar === void 0) appendChar = ch;
          if (appendChar === replacement) appendChar = " ";
          return result + appendChar.replace(options.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, "");
        }, "");
        if (options.strict) {
          slug = slug.replace(/[^A-Za-z0-9\s]/g, "");
        }
        if (trim) {
          slug = slug.trim();
        }
        slug = slug.replace(/\s+/g, replacement);
        if (options.lower) {
          slug = slug.toLowerCase();
        }
        return slug;
      }
      __name(replace, "replace");
      replace.extend = function(customMap) {
        Object.assign(charMap, customMap);
      };
      return replace;
    });
  }
});

// src/index.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/braintrust/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/uuid/dist/esm-browser/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/uuid/dist/esm-browser/rng.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
__name(rng, "rng");

// node_modules/uuid/dist/esm-browser/stringify.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/uuid/dist/esm-browser/validate.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/uuid/dist/esm-browser/regex.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
__name(validate, "validate");
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
__name(unsafeStringify, "unsafeStringify");
function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset);
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
__name(stringify, "stringify");
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/parse.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
__name(parse, "parse");
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/v4.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/uuid/dist/esm-browser/native.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
__name(v4, "v4");
var v4_default = v4;

// node_modules/zod/v3/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/locales/en.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/ZodError.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/helpers/util.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  __name(assertIs, "assertIs");
  util2.assertIs = assertIs;
  function assertNever3(_x) {
    throw new Error();
  }
  __name(assertNever3, "assertNever");
  util2.assertNever = assertNever3;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  __name(joinValues, "joinValues");
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first2, second) => {
    return {
      ...first2,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = /* @__PURE__ */ __name((obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
var ZodError = class _ZodError extends Error {
  static {
    __name(this, "ZodError");
  }
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error4) => {
      for (const issue of error4.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error4 = new ZodError(issues);
  return error4;
};

// node_modules/zod/v3/locales/en.js
var errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
}, "errorMap");
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");

// node_modules/zod/v3/helpers/parseUtil.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeIssue = /* @__PURE__ */ __name((params) => {
  const { data, path: path4, errorMaps, issueData } = params;
  const fullPath = [...path4, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, "makeIssue");
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
var ParseStatus = class _ParseStatus {
  static {
    __name(this, "ParseStatus");
  }
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
var OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
var isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
var isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
var isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
var isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");

// node_modules/zod/v3/types.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/helpers/errorUtil.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  static {
    __name(this, "ParseInputLazyPath");
  }
  constructor(parent, value, path4, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path4;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error4 = new ZodError(ctx.common.issues);
        this._error = error4;
        return this._error;
      }
    };
  }
}, "handleResult");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");
var ZodType = class {
  static {
    __name(this, "ZodType");
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = /* @__PURE__ */ __name((val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      }), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: /* @__PURE__ */ __name((data) => this["~validate"](data), "validate")
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
__name(timeRegexSource, "timeRegexSource");
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
__name(timeRegex, "timeRegex");
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
__name(datetimeRegex, "datetimeRegex");
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
__name(isValidJWT, "isValidJWT");
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidCidr, "isValidCidr");
var ZodString = class _ZodString extends ZodType {
  static {
    __name(this, "ZodString");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
__name(floatSafeRemainder, "floatSafeRemainder");
var ZodNumber = class _ZodNumber extends ZodType {
  static {
    __name(this, "ZodNumber");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  static {
    __name(this, "ZodBigInt");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  static {
    __name(this, "ZodBoolean");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  static {
    __name(this, "ZodDate");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  static {
    __name(this, "ZodSymbol");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  static {
    __name(this, "ZodUndefined");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  static {
    __name(this, "ZodNull");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  static {
    __name(this, "ZodAny");
  }
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  static {
    __name(this, "ZodUnknown");
  }
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  static {
    __name(this, "ZodNever");
  }
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  static {
    __name(this, "ZodVoid");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  static {
    __name(this, "ZodArray");
  }
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
var ZodObject = class _ZodObject extends ZodType {
  static {
    __name(this, "ZodObject");
  }
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: /* @__PURE__ */ __name((issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }, "errorMap")
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...augmentation
      }), "shape")
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }), "shape"),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  static {
    __name(this, "ZodUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = /* @__PURE__ */ __name((type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, "getDiscriminator");
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  static {
    __name(this, "ZodDiscriminatedUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
var ZodIntersection = class extends ZodType {
  static {
    __name(this, "ZodIntersection");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  static {
    __name(this, "ZodTuple");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  static {
    __name(this, "ZodRecord");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first2, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first2,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first2,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  static {
    __name(this, "ZodMap");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  static {
    __name(this, "ZodSet");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  static {
    __name(this, "ZodFunction");
  }
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error4) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error4
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error4) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error4
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error4 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error4.addIssue(makeArgsIssue(args, e));
          throw error4;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error4.addIssue(makeReturnsIssue(result, e));
          throw error4;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  static {
    __name(this, "ZodLazy");
  }
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  static {
    __name(this, "ZodLiteral");
  }
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
__name(createZodEnum, "createZodEnum");
var ZodEnum = class _ZodEnum extends ZodType {
  static {
    __name(this, "ZodEnum");
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  static {
    __name(this, "ZodNativeEnum");
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  static {
    __name(this, "ZodPromise");
  }
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  static {
    __name(this, "ZodEffects");
  }
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: /* @__PURE__ */ __name((arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      }, "addIssue"),
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  static {
    __name(this, "ZodOptional");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  static {
    __name(this, "ZodNullable");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  static {
    __name(this, "ZodDefault");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  static {
    __name(this, "ZodCatch");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  static {
    __name(this, "ZodNaN");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  static {
    __name(this, "ZodBranded");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  static {
    __name(this, "ZodPipeline");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  static {
    __name(this, "ZodReadonly");
  }
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = /* @__PURE__ */ __name((data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    }, "freeze");
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
__name(cleanParams, "cleanParams");
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
__name(custom, "custom");
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = /* @__PURE__ */ __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), "instanceOfType");
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
var onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
var oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
var coerce = {
  string: /* @__PURE__ */ __name((arg) => ZodString.create({ ...arg, coerce: true }), "string"),
  number: /* @__PURE__ */ __name((arg) => ZodNumber.create({ ...arg, coerce: true }), "number"),
  boolean: /* @__PURE__ */ __name((arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }), "boolean"),
  bigint: /* @__PURE__ */ __name((arg) => ZodBigInt.create({ ...arg, coerce: true }), "bigint"),
  date: /* @__PURE__ */ __name((arg) => ZodDate.create({ ...arg, coerce: true }), "date")
};
var NEVER = INVALID;

// node_modules/eventsource-parser/dist/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function createParser(onParse) {
  let isFirstChunk;
  let buffer;
  let startingPosition;
  let startingFieldLength;
  let eventId;
  let eventName;
  let data;
  reset();
  return {
    feed,
    reset
  };
  function reset() {
    isFirstChunk = true;
    buffer = "";
    startingPosition = 0;
    startingFieldLength = -1;
    eventId = void 0;
    eventName = void 0;
    data = "";
  }
  __name(reset, "reset");
  function feed(chunk) {
    buffer = buffer ? buffer + chunk : chunk;
    if (isFirstChunk && hasBom(buffer)) {
      buffer = buffer.slice(BOM.length);
    }
    isFirstChunk = false;
    const length = buffer.length;
    let position = 0;
    let discardTrailingNewline = false;
    while (position < length) {
      if (discardTrailingNewline) {
        if (buffer[position] === "\n") {
          ++position;
        }
        discardTrailingNewline = false;
      }
      let lineLength = -1;
      let fieldLength = startingFieldLength;
      let character;
      for (let index = startingPosition; lineLength < 0 && index < length; ++index) {
        character = buffer[index];
        if (character === ":" && fieldLength < 0) {
          fieldLength = index - position;
        } else if (character === "\r") {
          discardTrailingNewline = true;
          lineLength = index - position;
        } else if (character === "\n") {
          lineLength = index - position;
        }
      }
      if (lineLength < 0) {
        startingPosition = length - position;
        startingFieldLength = fieldLength;
        break;
      } else {
        startingPosition = 0;
        startingFieldLength = -1;
      }
      parseEventStreamLine(buffer, position, fieldLength, lineLength);
      position += lineLength + 1;
    }
    if (position === length) {
      buffer = "";
    } else if (position > 0) {
      buffer = buffer.slice(position);
    }
  }
  __name(feed, "feed");
  function parseEventStreamLine(lineBuffer, index, fieldLength, lineLength) {
    if (lineLength === 0) {
      if (data.length > 0) {
        onParse({
          type: "event",
          id: eventId,
          event: eventName || void 0,
          data: data.slice(0, -1)
          // remove trailing newline
        });
        data = "";
        eventId = void 0;
      }
      eventName = void 0;
      return;
    }
    const noValue = fieldLength < 0;
    const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength));
    let step = 0;
    if (noValue) {
      step = lineLength;
    } else if (lineBuffer[index + fieldLength + 1] === " ") {
      step = fieldLength + 2;
    } else {
      step = fieldLength + 1;
    }
    const position = index + step;
    const valueLength = lineLength - step;
    const value = lineBuffer.slice(position, position + valueLength).toString();
    if (field === "data") {
      data += value ? "".concat(value, "\n") : "\n";
    } else if (field === "event") {
      eventName = value;
    } else if (field === "id" && !value.includes("\0")) {
      eventId = value;
    } else if (field === "retry") {
      const retry = parseInt(value, 10);
      if (!Number.isNaN(retry)) {
        onParse({
          type: "reconnect-interval",
          value: retry
        });
      }
    }
  }
  __name(parseEventStreamLine, "parseEventStreamLine");
}
__name(createParser, "createParser");
var BOM = [239, 187, 191];
function hasBom(buffer) {
  return BOM.every((charCode, index) => buffer.charCodeAt(index) === charCode);
}
__name(hasBom, "hasBom");

// node_modules/mustache/mustache.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var objectToString = Object.prototype.toString;
var isArray = Array.isArray || /* @__PURE__ */ __name(function isArrayPolyfill(object) {
  return objectToString.call(object) === "[object Array]";
}, "isArrayPolyfill");
function isFunction(object) {
  return typeof object === "function";
}
__name(isFunction, "isFunction");
function typeStr(obj) {
  return isArray(obj) ? "array" : typeof obj;
}
__name(typeStr, "typeStr");
function escapeRegExp(string) {
  return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
__name(escapeRegExp, "escapeRegExp");
function hasProperty(obj, propName) {
  return obj != null && typeof obj === "object" && propName in obj;
}
__name(hasProperty, "hasProperty");
function primitiveHasOwnProperty(primitive, propName) {
  return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
}
__name(primitiveHasOwnProperty, "primitiveHasOwnProperty");
var regExpTest = RegExp.prototype.test;
function testRegExp(re2, string) {
  return regExpTest.call(re2, string);
}
__name(testRegExp, "testRegExp");
var nonSpaceRe = /\S/;
function isWhitespace(string) {
  return !testRegExp(nonSpaceRe, string);
}
__name(isWhitespace, "isWhitespace");
var entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function escapeHtml(string) {
  return String(string).replace(/[&<>"'`=\/]/g, /* @__PURE__ */ __name(function fromEntityMap(s) {
    return entityMap[s];
  }, "fromEntityMap"));
}
__name(escapeHtml, "escapeHtml");
var whiteRe = /\s*/;
var spaceRe = /\s+/;
var equalsRe = /\s*=/;
var curlyRe = /\s*\}/;
var tagRe = /#|\^|\/|>|\{|&|=|!/;
function parseTemplate(template, tags) {
  if (!template)
    return [];
  var lineHasNonSpace = false;
  var sections = [];
  var tokens = [];
  var spaces = [];
  var hasTag = false;
  var nonSpace = false;
  var indentation = "";
  var tagIndex = 0;
  function stripSpace() {
    if (hasTag && !nonSpace) {
      while (spaces.length)
        delete tokens[spaces.pop()];
    } else {
      spaces = [];
    }
    hasTag = false;
    nonSpace = false;
  }
  __name(stripSpace, "stripSpace");
  var openingTagRe, closingTagRe, closingCurlyRe;
  function compileTags(tagsToCompile) {
    if (typeof tagsToCompile === "string")
      tagsToCompile = tagsToCompile.split(spaceRe, 2);
    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
      throw new Error("Invalid tags: " + tagsToCompile);
    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
    closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
    closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
  }
  __name(compileTags, "compileTags");
  compileTags(tags || mustache.tags);
  var scanner = new Scanner(template);
  var start, type, value, chr, token, openSection;
  while (!scanner.eos()) {
    start = scanner.pos;
    value = scanner.scanUntil(openingTagRe);
    if (value) {
      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
        chr = value.charAt(i);
        if (isWhitespace(chr)) {
          spaces.push(tokens.length);
          indentation += chr;
        } else {
          nonSpace = true;
          lineHasNonSpace = true;
          indentation += " ";
        }
        tokens.push(["text", chr, start, start + 1]);
        start += 1;
        if (chr === "\n") {
          stripSpace();
          indentation = "";
          tagIndex = 0;
          lineHasNonSpace = false;
        }
      }
    }
    if (!scanner.scan(openingTagRe))
      break;
    hasTag = true;
    type = scanner.scan(tagRe) || "name";
    scanner.scan(whiteRe);
    if (type === "=") {
      value = scanner.scanUntil(equalsRe);
      scanner.scan(equalsRe);
      scanner.scanUntil(closingTagRe);
    } else if (type === "{") {
      value = scanner.scanUntil(closingCurlyRe);
      scanner.scan(curlyRe);
      scanner.scanUntil(closingTagRe);
      type = "&";
    } else {
      value = scanner.scanUntil(closingTagRe);
    }
    if (!scanner.scan(closingTagRe))
      throw new Error("Unclosed tag at " + scanner.pos);
    if (type == ">") {
      token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
    } else {
      token = [type, value, start, scanner.pos];
    }
    tagIndex++;
    tokens.push(token);
    if (type === "#" || type === "^") {
      sections.push(token);
    } else if (type === "/") {
      openSection = sections.pop();
      if (!openSection)
        throw new Error('Unopened section "' + value + '" at ' + start);
      if (openSection[1] !== value)
        throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
    } else if (type === "name" || type === "{" || type === "&") {
      nonSpace = true;
    } else if (type === "=") {
      compileTags(value);
    }
  }
  stripSpace();
  openSection = sections.pop();
  if (openSection)
    throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
  return nestTokens(squashTokens(tokens));
}
__name(parseTemplate, "parseTemplate");
function squashTokens(tokens) {
  var squashedTokens = [];
  var token, lastToken;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    if (token) {
      if (token[0] === "text" && lastToken && lastToken[0] === "text") {
        lastToken[1] += token[1];
        lastToken[3] = token[3];
      } else {
        squashedTokens.push(token);
        lastToken = token;
      }
    }
  }
  return squashedTokens;
}
__name(squashTokens, "squashTokens");
function nestTokens(tokens) {
  var nestedTokens = [];
  var collector = nestedTokens;
  var sections = [];
  var token, section;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    switch (token[0]) {
      case "#":
      case "^":
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case "/":
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
    }
  }
  return nestedTokens;
}
__name(nestTokens, "nestTokens");
function Scanner(string) {
  this.string = string;
  this.tail = string;
  this.pos = 0;
}
__name(Scanner, "Scanner");
Scanner.prototype.eos = /* @__PURE__ */ __name(function eos() {
  return this.tail === "";
}, "eos");
Scanner.prototype.scan = /* @__PURE__ */ __name(function scan(re2) {
  var match = this.tail.match(re2);
  if (!match || match.index !== 0)
    return "";
  var string = match[0];
  this.tail = this.tail.substring(string.length);
  this.pos += string.length;
  return string;
}, "scan");
Scanner.prototype.scanUntil = /* @__PURE__ */ __name(function scanUntil(re2) {
  var index = this.tail.search(re2), match;
  switch (index) {
    case -1:
      match = this.tail;
      this.tail = "";
      break;
    case 0:
      match = "";
      break;
    default:
      match = this.tail.substring(0, index);
      this.tail = this.tail.substring(index);
  }
  this.pos += match.length;
  return match;
}, "scanUntil");
function Context(view, parentContext) {
  this.view = view;
  this.cache = { ".": this.view };
  this.parent = parentContext;
}
__name(Context, "Context");
Context.prototype.push = /* @__PURE__ */ __name(function push(view) {
  return new Context(view, this);
}, "push");
Context.prototype.lookup = /* @__PURE__ */ __name(function lookup(name) {
  var cache2 = this.cache;
  var value;
  if (cache2.hasOwnProperty(name)) {
    value = cache2[name];
  } else {
    var context3 = this, intermediateValue, names, index, lookupHit = false;
    while (context3) {
      if (name.indexOf(".") > 0) {
        intermediateValue = context3.view;
        names = name.split(".");
        index = 0;
        while (intermediateValue != null && index < names.length) {
          if (index === names.length - 1)
            lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
          intermediateValue = intermediateValue[names[index++]];
        }
      } else {
        intermediateValue = context3.view[name];
        lookupHit = hasProperty(context3.view, name);
      }
      if (lookupHit) {
        value = intermediateValue;
        break;
      }
      context3 = context3.parent;
    }
    cache2[name] = value;
  }
  if (isFunction(value))
    value = value.call(this.view);
  return value;
}, "lookup");
function Writer() {
  this.templateCache = {
    _cache: {},
    set: /* @__PURE__ */ __name(function set(key, value) {
      this._cache[key] = value;
    }, "set"),
    get: /* @__PURE__ */ __name(function get(key) {
      return this._cache[key];
    }, "get"),
    clear: /* @__PURE__ */ __name(function clear3() {
      this._cache = {};
    }, "clear")
  };
}
__name(Writer, "Writer");
Writer.prototype.clearCache = /* @__PURE__ */ __name(function clearCache() {
  if (typeof this.templateCache !== "undefined") {
    this.templateCache.clear();
  }
}, "clearCache");
Writer.prototype.parse = /* @__PURE__ */ __name(function parse2(template, tags) {
  var cache2 = this.templateCache;
  var cacheKey = template + ":" + (tags || mustache.tags).join(":");
  var isCacheEnabled = typeof cache2 !== "undefined";
  var tokens = isCacheEnabled ? cache2.get(cacheKey) : void 0;
  if (tokens == void 0) {
    tokens = parseTemplate(template, tags);
    isCacheEnabled && cache2.set(cacheKey, tokens);
  }
  return tokens;
}, "parse");
Writer.prototype.render = /* @__PURE__ */ __name(function render(template, view, partials, config2) {
  var tags = this.getConfigTags(config2);
  var tokens = this.parse(template, tags);
  var context3 = view instanceof Context ? view : new Context(view, void 0);
  return this.renderTokens(tokens, context3, partials, template, config2);
}, "render");
Writer.prototype.renderTokens = /* @__PURE__ */ __name(function renderTokens(tokens, context3, partials, originalTemplate, config2) {
  var buffer = "";
  var token, symbol, value;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    value = void 0;
    token = tokens[i];
    symbol = token[0];
    if (symbol === "#") value = this.renderSection(token, context3, partials, originalTemplate, config2);
    else if (symbol === "^") value = this.renderInverted(token, context3, partials, originalTemplate, config2);
    else if (symbol === ">") value = this.renderPartial(token, context3, partials, config2);
    else if (symbol === "&") value = this.unescapedValue(token, context3);
    else if (symbol === "name") value = this.escapedValue(token, context3, config2);
    else if (symbol === "text") value = this.rawValue(token);
    if (value !== void 0)
      buffer += value;
  }
  return buffer;
}, "renderTokens");
Writer.prototype.renderSection = /* @__PURE__ */ __name(function renderSection(token, context3, partials, originalTemplate, config2) {
  var self = this;
  var buffer = "";
  var value = context3.lookup(token[1]);
  function subRender(template) {
    return self.render(template, context3, partials, config2);
  }
  __name(subRender, "subRender");
  if (!value) return;
  if (isArray(value)) {
    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
      buffer += this.renderTokens(token[4], context3.push(value[j]), partials, originalTemplate, config2);
    }
  } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
    buffer += this.renderTokens(token[4], context3.push(value), partials, originalTemplate, config2);
  } else if (isFunction(value)) {
    if (typeof originalTemplate !== "string")
      throw new Error("Cannot use higher-order sections without the original template");
    value = value.call(context3.view, originalTemplate.slice(token[3], token[5]), subRender);
    if (value != null)
      buffer += value;
  } else {
    buffer += this.renderTokens(token[4], context3, partials, originalTemplate, config2);
  }
  return buffer;
}, "renderSection");
Writer.prototype.renderInverted = /* @__PURE__ */ __name(function renderInverted(token, context3, partials, originalTemplate, config2) {
  var value = context3.lookup(token[1]);
  if (!value || isArray(value) && value.length === 0)
    return this.renderTokens(token[4], context3, partials, originalTemplate, config2);
}, "renderInverted");
Writer.prototype.indentPartial = /* @__PURE__ */ __name(function indentPartial(partial, indentation, lineHasNonSpace) {
  var filteredIndentation = indentation.replace(/[^ \t]/g, "");
  var partialByNl = partial.split("\n");
  for (var i = 0; i < partialByNl.length; i++) {
    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
      partialByNl[i] = filteredIndentation + partialByNl[i];
    }
  }
  return partialByNl.join("\n");
}, "indentPartial");
Writer.prototype.renderPartial = /* @__PURE__ */ __name(function renderPartial(token, context3, partials, config2) {
  if (!partials) return;
  var tags = this.getConfigTags(config2);
  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
  if (value != null) {
    var lineHasNonSpace = token[6];
    var tagIndex = token[5];
    var indentation = token[4];
    var indentedValue = value;
    if (tagIndex == 0 && indentation) {
      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
    }
    var tokens = this.parse(indentedValue, tags);
    return this.renderTokens(tokens, context3, partials, indentedValue, config2);
  }
}, "renderPartial");
Writer.prototype.unescapedValue = /* @__PURE__ */ __name(function unescapedValue(token, context3) {
  var value = context3.lookup(token[1]);
  if (value != null)
    return value;
}, "unescapedValue");
Writer.prototype.escapedValue = /* @__PURE__ */ __name(function escapedValue(token, context3, config2) {
  var escape2 = this.getConfigEscape(config2) || mustache.escape;
  var value = context3.lookup(token[1]);
  if (value != null)
    return typeof value === "number" && escape2 === mustache.escape ? String(value) : escape2(value);
}, "escapedValue");
Writer.prototype.rawValue = /* @__PURE__ */ __name(function rawValue(token) {
  return token[1];
}, "rawValue");
Writer.prototype.getConfigTags = /* @__PURE__ */ __name(function getConfigTags(config2) {
  if (isArray(config2)) {
    return config2;
  } else if (config2 && typeof config2 === "object") {
    return config2.tags;
  } else {
    return void 0;
  }
}, "getConfigTags");
Writer.prototype.getConfigEscape = /* @__PURE__ */ __name(function getConfigEscape(config2) {
  if (config2 && typeof config2 === "object" && !isArray(config2)) {
    return config2.escape;
  } else {
    return void 0;
  }
}, "getConfigEscape");
var mustache = {
  name: "mustache.js",
  version: "4.2.0",
  tags: ["{{", "}}"],
  clearCache: void 0,
  escape: void 0,
  parse: void 0,
  render: void 0,
  Scanner: void 0,
  Context: void 0,
  Writer: void 0,
  /**
   * Allows a user to override the default caching strategy, by providing an
   * object with set, get and clear methods. This can also be used to disable
   * the cache by setting it to the literal `undefined`.
   */
  set templateCache(cache2) {
    defaultWriter.templateCache = cache2;
  },
  /**
   * Gets the default or overridden caching object from the default writer.
   */
  get templateCache() {
    return defaultWriter.templateCache;
  }
};
var defaultWriter = new Writer();
mustache.clearCache = /* @__PURE__ */ __name(function clearCache2() {
  return defaultWriter.clearCache();
}, "clearCache");
mustache.parse = /* @__PURE__ */ __name(function parse3(template, tags) {
  return defaultWriter.parse(template, tags);
}, "parse");
mustache.render = /* @__PURE__ */ __name(function render2(template, view, partials, config2) {
  if (typeof template !== "string") {
    throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
  }
  return defaultWriter.render(template, view, partials, config2);
}, "render");
mustache.escape = escapeHtml;
mustache.Scanner = Scanner;
mustache.Context = Context;
mustache.Writer = Writer;
var mustache_default = mustache;

// node_modules/braintrust/dist/index.mjs
var import_functions = __toESM(require_functions(), 1);
init_promises2();
import { AsyncLocalStorage } from "node:async_hooks";
import * as path from "node:path";

// node_modules/unenv/dist/runtime/node/os.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var homedir = /* @__PURE__ */ __name(() => "/", "homedir");

// node_modules/braintrust/dist/index.mjs
init_fs2();
import * as crypto2 from "node:crypto";

// node_modules/simple-git/dist/esm/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_file_exists = __toESM(require_dist(), 1);
var import_debug = __toESM(require_src(), 1);
import { Buffer as Buffer2 } from "node:buffer";

// node_modules/unenv/dist/runtime/node/child_process.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();
var spawn = /* @__PURE__ */ notImplemented("child_process.spawn");

// node_modules/simple-git/dist/esm/index.js
var import_promise_deferred = __toESM(require_dist2(), 1);
var import_promise_deferred2 = __toESM(require_dist2(), 1);
import { EventEmitter as EventEmitter2 } from "node:events";
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __esm2 = /* @__PURE__ */ __name((fn, res) => /* @__PURE__ */ __name(function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
}, "__init"), "__esm");
var __commonJS2 = /* @__PURE__ */ __name((cb, mod) => /* @__PURE__ */ __name(function __require3() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
}, "__require"), "__commonJS");
var __export2 = /* @__PURE__ */ __name((target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
}, "__export");
var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: /* @__PURE__ */ __name(() => from[key], "get"), enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
}, "__copyProps");
var __toCommonJS = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod), "__toCommonJS");
function pathspec(...paths) {
  const key = new String(paths);
  cache.set(key, paths);
  return key;
}
__name(pathspec, "pathspec");
function isPathSpec(path4) {
  return path4 instanceof String && cache.has(path4);
}
__name(isPathSpec, "isPathSpec");
function toPaths(pathSpec) {
  return cache.get(pathSpec) || [];
}
__name(toPaths, "toPaths");
var cache;
var init_pathspec = __esm2({
  "src/lib/args/pathspec.ts"() {
    "use strict";
    cache = /* @__PURE__ */ new WeakMap();
  }
});
var GitError;
var init_git_error = __esm2({
  "src/lib/errors/git-error.ts"() {
    "use strict";
    GitError = class extends Error {
      static {
        __name(this, "GitError");
      }
      constructor(task, message) {
        super(message);
        this.task = task;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
  }
});
var GitResponseError;
var init_git_response_error = __esm2({
  "src/lib/errors/git-response-error.ts"() {
    "use strict";
    init_git_error();
    GitResponseError = class extends GitError {
      static {
        __name(this, "GitResponseError");
      }
      constructor(git, message) {
        super(void 0, message || String(git));
        this.git = git;
      }
    };
  }
});
var TaskConfigurationError;
var init_task_configuration_error = __esm2({
  "src/lib/errors/task-configuration-error.ts"() {
    "use strict";
    init_git_error();
    TaskConfigurationError = class extends GitError {
      static {
        __name(this, "TaskConfigurationError");
      }
      constructor(message) {
        super(void 0, message);
      }
    };
  }
});
function asFunction(source) {
  if (typeof source !== "function") {
    return NOOP;
  }
  return source;
}
__name(asFunction, "asFunction");
function isUserFunction(source) {
  return typeof source === "function" && source !== NOOP;
}
__name(isUserFunction, "isUserFunction");
function splitOn(input, char) {
  const index = input.indexOf(char);
  if (index <= 0) {
    return [input, ""];
  }
  return [input.substr(0, index), input.substr(index + 1)];
}
__name(splitOn, "splitOn");
function first(input, offset = 0) {
  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;
}
__name(first, "first");
function last(input, offset = 0) {
  if (isArrayLike(input) && input.length > offset) {
    return input[input.length - 1 - offset];
  }
}
__name(last, "last");
function isArrayLike(input) {
  return !!(input && typeof input.length === "number");
}
__name(isArrayLike, "isArrayLike");
function toLinesWithContent(input = "", trimmed2 = true, separator = "\n") {
  return input.split(separator).reduce((output, line) => {
    const lineContent = trimmed2 ? line.trim() : line;
    if (lineContent) {
      output.push(lineContent);
    }
    return output;
  }, []);
}
__name(toLinesWithContent, "toLinesWithContent");
function forEachLineWithContent(input, callback) {
  return toLinesWithContent(input, true).map((line) => callback(line));
}
__name(forEachLineWithContent, "forEachLineWithContent");
function folderExists(path4) {
  return (0, import_file_exists.exists)(path4, import_file_exists.FOLDER);
}
__name(folderExists, "folderExists");
function append(target, item) {
  if (Array.isArray(target)) {
    if (!target.includes(item)) {
      target.push(item);
    }
  } else {
    target.add(item);
  }
  return item;
}
__name(append, "append");
function including(target, item) {
  if (Array.isArray(target) && !target.includes(item)) {
    target.push(item);
  }
  return target;
}
__name(including, "including");
function remove(target, item) {
  if (Array.isArray(target)) {
    const index = target.indexOf(item);
    if (index >= 0) {
      target.splice(index, 1);
    }
  } else {
    target.delete(item);
  }
  return item;
}
__name(remove, "remove");
function asArray(source) {
  return Array.isArray(source) ? source : [source];
}
__name(asArray, "asArray");
function asCamelCase(str2) {
  return str2.replace(/[\s-]+(.)/g, (_all, chr) => {
    return chr.toUpperCase();
  });
}
__name(asCamelCase, "asCamelCase");
function asStringArray(source) {
  return asArray(source).map(String);
}
__name(asStringArray, "asStringArray");
function asNumber(source, onNaN = 0) {
  if (source == null) {
    return onNaN;
  }
  const num = parseInt(source, 10);
  return isNaN(num) ? onNaN : num;
}
__name(asNumber, "asNumber");
function prefixedArray(input, prefix) {
  const output = [];
  for (let i = 0, max = input.length; i < max; i++) {
    output.push(prefix, input[i]);
  }
  return output;
}
__name(prefixedArray, "prefixedArray");
function bufferToString(input) {
  return (Array.isArray(input) ? Buffer2.concat(input) : input).toString("utf-8");
}
__name(bufferToString, "bufferToString");
function pick(source, properties) {
  return Object.assign(
    {},
    ...properties.map((property) => property in source ? { [property]: source[property] } : {})
  );
}
__name(pick, "pick");
function delay(duration = 0) {
  return new Promise((done) => setTimeout(done, duration));
}
__name(delay, "delay");
function orVoid(input) {
  if (input === false) {
    return void 0;
  }
  return input;
}
__name(orVoid, "orVoid");
var NULL;
var NOOP;
var objectToString2;
var init_util = __esm2({
  "src/lib/utils/util.ts"() {
    "use strict";
    NULL = "\0";
    NOOP = /* @__PURE__ */ __name(() => {
    }, "NOOP");
    objectToString2 = Object.prototype.toString.call.bind(Object.prototype.toString);
  }
});
function filterType(input, filter2, def) {
  if (filter2(input)) {
    return input;
  }
  return arguments.length > 2 ? def : void 0;
}
__name(filterType, "filterType");
function filterPrimitives(input, omit) {
  const type = isPathSpec(input) ? "string" : typeof input;
  return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));
}
__name(filterPrimitives, "filterPrimitives");
function filterPlainObject(input) {
  return !!input && objectToString2(input) === "[object Object]";
}
__name(filterPlainObject, "filterPlainObject");
function filterFunction(input) {
  return typeof input === "function";
}
__name(filterFunction, "filterFunction");
var filterArray;
var filterString;
var filterStringArray;
var filterStringOrStringArray;
var filterHasLength;
var init_argument_filters = __esm2({
  "src/lib/utils/argument-filters.ts"() {
    "use strict";
    init_util();
    init_pathspec();
    filterArray = /* @__PURE__ */ __name((input) => {
      return Array.isArray(input);
    }, "filterArray");
    filterString = /* @__PURE__ */ __name((input) => {
      return typeof input === "string";
    }, "filterString");
    filterStringArray = /* @__PURE__ */ __name((input) => {
      return Array.isArray(input) && input.every(filterString);
    }, "filterStringArray");
    filterStringOrStringArray = /* @__PURE__ */ __name((input) => {
      return filterString(input) || Array.isArray(input) && input.every(filterString);
    }, "filterStringOrStringArray");
    filterHasLength = /* @__PURE__ */ __name((input) => {
      if (input == null || "number|boolean|function".includes(typeof input)) {
        return false;
      }
      return Array.isArray(input) || typeof input === "string" || typeof input.length === "number";
    }, "filterHasLength");
  }
});
var ExitCodes;
var init_exit_codes = __esm2({
  "src/lib/utils/exit-codes.ts"() {
    "use strict";
    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {
      ExitCodes2[ExitCodes2["SUCCESS"] = 0] = "SUCCESS";
      ExitCodes2[ExitCodes2["ERROR"] = 1] = "ERROR";
      ExitCodes2[ExitCodes2["NOT_FOUND"] = -2] = "NOT_FOUND";
      ExitCodes2[ExitCodes2["UNCLEAN"] = 128] = "UNCLEAN";
      return ExitCodes2;
    })(ExitCodes || {});
  }
});
var GitOutputStreams;
var init_git_output_streams = __esm2({
  "src/lib/utils/git-output-streams.ts"() {
    "use strict";
    GitOutputStreams = class _GitOutputStreams {
      static {
        __name(this, "_GitOutputStreams");
      }
      constructor(stdOut, stdErr) {
        this.stdOut = stdOut;
        this.stdErr = stdErr;
      }
      asStrings() {
        return new _GitOutputStreams(this.stdOut.toString("utf8"), this.stdErr.toString("utf8"));
      }
    };
  }
});
var LineParser;
var RemoteLineParser;
var init_line_parser = __esm2({
  "src/lib/utils/line-parser.ts"() {
    "use strict";
    LineParser = class {
      static {
        __name(this, "LineParser");
      }
      constructor(regExp, useMatches) {
        this.matches = [];
        this.parse = (line, target) => {
          this.resetMatches();
          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {
            return false;
          }
          return this.useMatches(target, this.prepareMatches()) !== false;
        };
        this._regExp = Array.isArray(regExp) ? regExp : [regExp];
        if (useMatches) {
          this.useMatches = useMatches;
        }
      }
      // @ts-ignore
      useMatches(target, match) {
        throw new Error(`LineParser:useMatches not implemented`);
      }
      resetMatches() {
        this.matches.length = 0;
      }
      prepareMatches() {
        return this.matches;
      }
      addMatch(reg, index, line) {
        const matched = line && reg.exec(line);
        if (matched) {
          this.pushMatch(index, matched);
        }
        return !!matched;
      }
      pushMatch(_index, matched) {
        this.matches.push(...matched.slice(1));
      }
    };
    RemoteLineParser = class extends LineParser {
      static {
        __name(this, "RemoteLineParser");
      }
      addMatch(reg, index, line) {
        return /^remote:\s/.test(String(line)) && super.addMatch(reg, index, line);
      }
      pushMatch(index, matched) {
        if (index > 0 || matched.length > 1) {
          super.pushMatch(index, matched);
        }
      }
    };
  }
});
function createInstanceConfig(...options) {
  const baseDir = process.cwd();
  const config2 = Object.assign(
    { baseDir, ...defaultOptions },
    ...options.filter((o) => typeof o === "object" && o)
  );
  config2.baseDir = config2.baseDir || baseDir;
  config2.trimmed = config2.trimmed === true;
  return config2;
}
__name(createInstanceConfig, "createInstanceConfig");
var defaultOptions;
var init_simple_git_options = __esm2({
  "src/lib/utils/simple-git-options.ts"() {
    "use strict";
    defaultOptions = {
      binary: "git",
      maxConcurrentProcesses: 5,
      config: [],
      trimmed: false
    };
  }
});
function appendTaskOptions(options, commands = []) {
  if (!filterPlainObject(options)) {
    return commands;
  }
  return Object.keys(options).reduce((commands2, key) => {
    const value = options[key];
    if (isPathSpec(value)) {
      commands2.push(value);
    } else if (filterPrimitives(value, ["boolean"])) {
      commands2.push(key + "=" + value);
    } else if (Array.isArray(value)) {
      for (const v of value) {
        if (!filterPrimitives(v, ["string", "number"])) {
          commands2.push(key + "=" + v);
        }
      }
    } else {
      commands2.push(key);
    }
    return commands2;
  }, commands);
}
__name(appendTaskOptions, "appendTaskOptions");
function getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {
  const command = [];
  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {
    if ("string|number".includes(typeof args[i])) {
      command.push(String(args[i]));
    }
  }
  appendTaskOptions(trailingOptionsArgument(args), command);
  if (!objectOnly) {
    command.push(...trailingArrayArgument(args));
  }
  return command;
}
__name(getTrailingOptions, "getTrailingOptions");
function trailingArrayArgument(args) {
  const hasTrailingCallback = typeof last(args) === "function";
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []);
}
__name(trailingArrayArgument, "trailingArrayArgument");
function trailingOptionsArgument(args) {
  const hasTrailingCallback = filterFunction(last(args));
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);
}
__name(trailingOptionsArgument, "trailingOptionsArgument");
function trailingFunctionArgument(args, includeNoop = true) {
  const callback = asFunction(last(args));
  return includeNoop || isUserFunction(callback) ? callback : void 0;
}
__name(trailingFunctionArgument, "trailingFunctionArgument");
var init_task_options = __esm2({
  "src/lib/utils/task-options.ts"() {
    "use strict";
    init_argument_filters();
    init_util();
    init_pathspec();
  }
});
function callTaskParser(parser4, streams) {
  return parser4(streams.stdOut, streams.stdErr);
}
__name(callTaskParser, "callTaskParser");
function parseStringResponse(result, parsers12, texts, trim = true) {
  asArray(texts).forEach((text) => {
    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {
      const line = /* @__PURE__ */ __name((offset = 0) => {
        if (i + offset >= max) {
          return;
        }
        return lines[i + offset];
      }, "line");
      parsers12.some(({ parse: parse4 }) => parse4(line, result));
    }
  });
  return result;
}
__name(parseStringResponse, "parseStringResponse");
var init_task_parser = __esm2({
  "src/lib/utils/task-parser.ts"() {
    "use strict";
    init_util();
  }
});
var utils_exports = {};
__export2(utils_exports, {
  ExitCodes: /* @__PURE__ */ __name(() => ExitCodes, "ExitCodes"),
  GitOutputStreams: /* @__PURE__ */ __name(() => GitOutputStreams, "GitOutputStreams"),
  LineParser: /* @__PURE__ */ __name(() => LineParser, "LineParser"),
  NOOP: /* @__PURE__ */ __name(() => NOOP, "NOOP"),
  NULL: /* @__PURE__ */ __name(() => NULL, "NULL"),
  RemoteLineParser: /* @__PURE__ */ __name(() => RemoteLineParser, "RemoteLineParser"),
  append: /* @__PURE__ */ __name(() => append, "append"),
  appendTaskOptions: /* @__PURE__ */ __name(() => appendTaskOptions, "appendTaskOptions"),
  asArray: /* @__PURE__ */ __name(() => asArray, "asArray"),
  asCamelCase: /* @__PURE__ */ __name(() => asCamelCase, "asCamelCase"),
  asFunction: /* @__PURE__ */ __name(() => asFunction, "asFunction"),
  asNumber: /* @__PURE__ */ __name(() => asNumber, "asNumber"),
  asStringArray: /* @__PURE__ */ __name(() => asStringArray, "asStringArray"),
  bufferToString: /* @__PURE__ */ __name(() => bufferToString, "bufferToString"),
  callTaskParser: /* @__PURE__ */ __name(() => callTaskParser, "callTaskParser"),
  createInstanceConfig: /* @__PURE__ */ __name(() => createInstanceConfig, "createInstanceConfig"),
  delay: /* @__PURE__ */ __name(() => delay, "delay"),
  filterArray: /* @__PURE__ */ __name(() => filterArray, "filterArray"),
  filterFunction: /* @__PURE__ */ __name(() => filterFunction, "filterFunction"),
  filterHasLength: /* @__PURE__ */ __name(() => filterHasLength, "filterHasLength"),
  filterPlainObject: /* @__PURE__ */ __name(() => filterPlainObject, "filterPlainObject"),
  filterPrimitives: /* @__PURE__ */ __name(() => filterPrimitives, "filterPrimitives"),
  filterString: /* @__PURE__ */ __name(() => filterString, "filterString"),
  filterStringArray: /* @__PURE__ */ __name(() => filterStringArray, "filterStringArray"),
  filterStringOrStringArray: /* @__PURE__ */ __name(() => filterStringOrStringArray, "filterStringOrStringArray"),
  filterType: /* @__PURE__ */ __name(() => filterType, "filterType"),
  first: /* @__PURE__ */ __name(() => first, "first"),
  folderExists: /* @__PURE__ */ __name(() => folderExists, "folderExists"),
  forEachLineWithContent: /* @__PURE__ */ __name(() => forEachLineWithContent, "forEachLineWithContent"),
  getTrailingOptions: /* @__PURE__ */ __name(() => getTrailingOptions, "getTrailingOptions"),
  including: /* @__PURE__ */ __name(() => including, "including"),
  isUserFunction: /* @__PURE__ */ __name(() => isUserFunction, "isUserFunction"),
  last: /* @__PURE__ */ __name(() => last, "last"),
  objectToString: /* @__PURE__ */ __name(() => objectToString2, "objectToString"),
  orVoid: /* @__PURE__ */ __name(() => orVoid, "orVoid"),
  parseStringResponse: /* @__PURE__ */ __name(() => parseStringResponse, "parseStringResponse"),
  pick: /* @__PURE__ */ __name(() => pick, "pick"),
  prefixedArray: /* @__PURE__ */ __name(() => prefixedArray, "prefixedArray"),
  remove: /* @__PURE__ */ __name(() => remove, "remove"),
  splitOn: /* @__PURE__ */ __name(() => splitOn, "splitOn"),
  toLinesWithContent: /* @__PURE__ */ __name(() => toLinesWithContent, "toLinesWithContent"),
  trailingFunctionArgument: /* @__PURE__ */ __name(() => trailingFunctionArgument, "trailingFunctionArgument"),
  trailingOptionsArgument: /* @__PURE__ */ __name(() => trailingOptionsArgument, "trailingOptionsArgument")
});
var init_utils2 = __esm2({
  "src/lib/utils/index.ts"() {
    "use strict";
    init_argument_filters();
    init_exit_codes();
    init_git_output_streams();
    init_line_parser();
    init_simple_git_options();
    init_task_options();
    init_task_parser();
    init_util();
  }
});
var check_is_repo_exports = {};
__export2(check_is_repo_exports, {
  CheckRepoActions: /* @__PURE__ */ __name(() => CheckRepoActions, "CheckRepoActions"),
  checkIsBareRepoTask: /* @__PURE__ */ __name(() => checkIsBareRepoTask, "checkIsBareRepoTask"),
  checkIsRepoRootTask: /* @__PURE__ */ __name(() => checkIsRepoRootTask, "checkIsRepoRootTask"),
  checkIsRepoTask: /* @__PURE__ */ __name(() => checkIsRepoTask, "checkIsRepoTask")
});
function checkIsRepoTask(action) {
  switch (action) {
    case "bare":
      return checkIsBareRepoTask();
    case "root":
      return checkIsRepoRootTask();
  }
  const commands = ["rev-parse", "--is-inside-work-tree"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
__name(checkIsRepoTask, "checkIsRepoTask");
function checkIsRepoRootTask() {
  const commands = ["rev-parse", "--git-dir"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser(path4) {
      return /^\.(git)?$/.test(path4.trim());
    }
  };
}
__name(checkIsRepoRootTask, "checkIsRepoRootTask");
function checkIsBareRepoTask() {
  const commands = ["rev-parse", "--is-bare-repository"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
__name(checkIsBareRepoTask, "checkIsBareRepoTask");
function isNotRepoMessage(error4) {
  return /(Not a git repository|Kein Git-Repository)/i.test(String(error4));
}
__name(isNotRepoMessage, "isNotRepoMessage");
var CheckRepoActions;
var onError;
var parser;
var init_check_is_repo = __esm2({
  "src/lib/tasks/check-is-repo.ts"() {
    "use strict";
    init_utils2();
    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {
      CheckRepoActions2["BARE"] = "bare";
      CheckRepoActions2["IN_TREE"] = "tree";
      CheckRepoActions2["IS_REPO_ROOT"] = "root";
      return CheckRepoActions2;
    })(CheckRepoActions || {});
    onError = /* @__PURE__ */ __name(({ exitCode: exitCode2 }, error4, done, fail) => {
      if (exitCode2 === 128 && isNotRepoMessage(error4)) {
        return done(Buffer.from("false"));
      }
      fail(error4);
    }, "onError");
    parser = /* @__PURE__ */ __name((text) => {
      return text.trim() === "true";
    }, "parser");
  }
});
function cleanSummaryParser(dryRun, text) {
  const summary = new CleanResponse(dryRun);
  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;
  toLinesWithContent(text).forEach((line) => {
    const removed = line.replace(regexp, "");
    summary.paths.push(removed);
    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);
  });
  return summary;
}
__name(cleanSummaryParser, "cleanSummaryParser");
var CleanResponse;
var removalRegexp;
var dryRunRemovalRegexp;
var isFolderRegexp;
var init_CleanSummary = __esm2({
  "src/lib/responses/CleanSummary.ts"() {
    "use strict";
    init_utils2();
    CleanResponse = class {
      static {
        __name(this, "CleanResponse");
      }
      constructor(dryRun) {
        this.dryRun = dryRun;
        this.paths = [];
        this.files = [];
        this.folders = [];
      }
    };
    removalRegexp = /^[a-z]+\s*/i;
    dryRunRemovalRegexp = /^[a-z]+\s+[a-z]+\s*/i;
    isFolderRegexp = /\/$/;
  }
});
var task_exports = {};
__export2(task_exports, {
  EMPTY_COMMANDS: /* @__PURE__ */ __name(() => EMPTY_COMMANDS, "EMPTY_COMMANDS"),
  adhocExecTask: /* @__PURE__ */ __name(() => adhocExecTask, "adhocExecTask"),
  configurationErrorTask: /* @__PURE__ */ __name(() => configurationErrorTask, "configurationErrorTask"),
  isBufferTask: /* @__PURE__ */ __name(() => isBufferTask, "isBufferTask"),
  isEmptyTask: /* @__PURE__ */ __name(() => isEmptyTask, "isEmptyTask"),
  straightThroughBufferTask: /* @__PURE__ */ __name(() => straightThroughBufferTask, "straightThroughBufferTask"),
  straightThroughStringTask: /* @__PURE__ */ __name(() => straightThroughStringTask, "straightThroughStringTask")
});
function adhocExecTask(parser4) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser: parser4
  };
}
__name(adhocExecTask, "adhocExecTask");
function configurationErrorTask(error4) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser() {
      throw typeof error4 === "string" ? new TaskConfigurationError(error4) : error4;
    }
  };
}
__name(configurationErrorTask, "configurationErrorTask");
function straightThroughStringTask(commands, trimmed2 = false) {
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return trimmed2 ? String(text).trim() : text;
    }
  };
}
__name(straightThroughStringTask, "straightThroughStringTask");
function straightThroughBufferTask(commands) {
  return {
    commands,
    format: "buffer",
    parser(buffer) {
      return buffer;
    }
  };
}
__name(straightThroughBufferTask, "straightThroughBufferTask");
function isBufferTask(task) {
  return task.format === "buffer";
}
__name(isBufferTask, "isBufferTask");
function isEmptyTask(task) {
  return task.format === "empty" || !task.commands.length;
}
__name(isEmptyTask, "isEmptyTask");
var EMPTY_COMMANDS;
var init_task = __esm2({
  "src/lib/tasks/task.ts"() {
    "use strict";
    init_task_configuration_error();
    EMPTY_COMMANDS = [];
  }
});
var clean_exports = {};
__export2(clean_exports, {
  CONFIG_ERROR_INTERACTIVE_MODE: /* @__PURE__ */ __name(() => CONFIG_ERROR_INTERACTIVE_MODE, "CONFIG_ERROR_INTERACTIVE_MODE"),
  CONFIG_ERROR_MODE_REQUIRED: /* @__PURE__ */ __name(() => CONFIG_ERROR_MODE_REQUIRED, "CONFIG_ERROR_MODE_REQUIRED"),
  CONFIG_ERROR_UNKNOWN_OPTION: /* @__PURE__ */ __name(() => CONFIG_ERROR_UNKNOWN_OPTION, "CONFIG_ERROR_UNKNOWN_OPTION"),
  CleanOptions: /* @__PURE__ */ __name(() => CleanOptions, "CleanOptions"),
  cleanTask: /* @__PURE__ */ __name(() => cleanTask, "cleanTask"),
  cleanWithOptionsTask: /* @__PURE__ */ __name(() => cleanWithOptionsTask, "cleanWithOptionsTask"),
  isCleanOptionsArray: /* @__PURE__ */ __name(() => isCleanOptionsArray, "isCleanOptionsArray")
});
function cleanWithOptionsTask(mode, customArgs) {
  const { cleanMode, options, valid } = getCleanOptions(mode);
  if (!cleanMode) {
    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);
  }
  if (!valid.options) {
    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));
  }
  options.push(...customArgs);
  if (options.some(isInteractiveMode)) {
    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);
  }
  return cleanTask(cleanMode, options);
}
__name(cleanWithOptionsTask, "cleanWithOptionsTask");
function cleanTask(mode, customArgs) {
  const commands = ["clean", `-${mode}`, ...customArgs];
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return cleanSummaryParser(mode === "n", text);
    }
  };
}
__name(cleanTask, "cleanTask");
function isCleanOptionsArray(input) {
  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));
}
__name(isCleanOptionsArray, "isCleanOptionsArray");
function getCleanOptions(input) {
  let cleanMode;
  let options = [];
  let valid = { cleanMode: false, options: true };
  input.replace(/[^a-z]i/g, "").split("").forEach((char) => {
    if (isCleanMode(char)) {
      cleanMode = char;
      valid.cleanMode = true;
    } else {
      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);
    }
  });
  return {
    cleanMode,
    options,
    valid
  };
}
__name(getCleanOptions, "getCleanOptions");
function isCleanMode(cleanMode) {
  return cleanMode === "f" || cleanMode === "n";
}
__name(isCleanMode, "isCleanMode");
function isKnownOption(option) {
  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));
}
__name(isKnownOption, "isKnownOption");
function isInteractiveMode(option) {
  if (/^-[^\-]/.test(option)) {
    return option.indexOf("i") > 0;
  }
  return option === "--interactive";
}
__name(isInteractiveMode, "isInteractiveMode");
var CONFIG_ERROR_INTERACTIVE_MODE;
var CONFIG_ERROR_MODE_REQUIRED;
var CONFIG_ERROR_UNKNOWN_OPTION;
var CleanOptions;
var CleanOptionValues;
var init_clean = __esm2({
  "src/lib/tasks/clean.ts"() {
    "use strict";
    init_CleanSummary();
    init_utils2();
    init_task();
    CONFIG_ERROR_INTERACTIVE_MODE = "Git clean interactive mode is not supported";
    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter ("n" or "f") is required';
    CONFIG_ERROR_UNKNOWN_OPTION = "Git clean unknown option found in: ";
    CleanOptions = /* @__PURE__ */ ((CleanOptions2) => {
      CleanOptions2["DRY_RUN"] = "n";
      CleanOptions2["FORCE"] = "f";
      CleanOptions2["IGNORED_INCLUDED"] = "x";
      CleanOptions2["IGNORED_ONLY"] = "X";
      CleanOptions2["EXCLUDING"] = "e";
      CleanOptions2["QUIET"] = "q";
      CleanOptions2["RECURSIVE"] = "d";
      return CleanOptions2;
    })(CleanOptions || {});
    CleanOptionValues = /* @__PURE__ */ new Set([
      "i",
      ...asStringArray(Object.values(CleanOptions))
    ]);
  }
});
function configListParser(text) {
  const config2 = new ConfigList();
  for (const item of configParser(text)) {
    config2.addValue(item.file, String(item.key), item.value);
  }
  return config2;
}
__name(configListParser, "configListParser");
function configGetParser(text, key) {
  let value = null;
  const values = [];
  const scopes = /* @__PURE__ */ new Map();
  for (const item of configParser(text, key)) {
    if (item.key !== key) {
      continue;
    }
    values.push(value = item.value);
    if (!scopes.has(item.file)) {
      scopes.set(item.file, []);
    }
    scopes.get(item.file).push(value);
  }
  return {
    key,
    paths: Array.from(scopes.keys()),
    scopes,
    value,
    values
  };
}
__name(configGetParser, "configGetParser");
function configFilePath(filePath) {
  return filePath.replace(/^(file):/, "");
}
__name(configFilePath, "configFilePath");
function* configParser(text, requestedKey = null) {
  const lines = text.split("\0");
  for (let i = 0, max = lines.length - 1; i < max; ) {
    const file = configFilePath(lines[i++]);
    let value = lines[i++];
    let key = requestedKey;
    if (value.includes("\n")) {
      const line = splitOn(value, "\n");
      key = line[0];
      value = line[1];
    }
    yield { file, key, value };
  }
}
__name(configParser, "configParser");
var ConfigList;
var init_ConfigList = __esm2({
  "src/lib/responses/ConfigList.ts"() {
    "use strict";
    init_utils2();
    ConfigList = class {
      static {
        __name(this, "ConfigList");
      }
      constructor() {
        this.files = [];
        this.values = /* @__PURE__ */ Object.create(null);
      }
      get all() {
        if (!this._all) {
          this._all = this.files.reduce((all, file) => {
            return Object.assign(all, this.values[file]);
          }, {});
        }
        return this._all;
      }
      addFile(file) {
        if (!(file in this.values)) {
          const latest = last(this.files);
          this.values[file] = latest ? Object.create(this.values[latest]) : {};
          this.files.push(file);
        }
        return this.values[file];
      }
      addValue(file, key, value) {
        const values = this.addFile(file);
        if (!values.hasOwnProperty(key)) {
          values[key] = value;
        } else if (Array.isArray(values[key])) {
          values[key].push(value);
        } else {
          values[key] = [values[key], value];
        }
        this._all = void 0;
      }
    };
  }
});
function asConfigScope(scope, fallback2) {
  if (typeof scope === "string" && GitConfigScope.hasOwnProperty(scope)) {
    return scope;
  }
  return fallback2;
}
__name(asConfigScope, "asConfigScope");
function addConfigTask(key, value, append2, scope) {
  const commands = ["config", `--${scope}`];
  if (append2) {
    commands.push("--add");
  }
  commands.push(key, value);
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return text;
    }
  };
}
__name(addConfigTask, "addConfigTask");
function getConfigTask(key, scope) {
  const commands = ["config", "--null", "--show-origin", "--get-all", key];
  if (scope) {
    commands.splice(1, 0, `--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configGetParser(text, key);
    }
  };
}
__name(getConfigTask, "getConfigTask");
function listConfigTask(scope) {
  const commands = ["config", "--list", "--show-origin", "--null"];
  if (scope) {
    commands.push(`--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configListParser(text);
    }
  };
}
__name(listConfigTask, "listConfigTask");
function config_default() {
  return {
    addConfig(key, value, ...rest) {
      return this._runTask(
        addConfigTask(
          key,
          value,
          rest[0] === true,
          asConfigScope(
            rest[1],
            "local"
            /* local */
          )
        ),
        trailingFunctionArgument(arguments)
      );
    },
    getConfig(key, scope) {
      return this._runTask(
        getConfigTask(key, asConfigScope(scope, void 0)),
        trailingFunctionArgument(arguments)
      );
    },
    listConfig(...rest) {
      return this._runTask(
        listConfigTask(asConfigScope(rest[0], void 0)),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
__name(config_default, "config_default");
var GitConfigScope;
var init_config = __esm2({
  "src/lib/tasks/config.ts"() {
    "use strict";
    init_ConfigList();
    init_utils2();
    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {
      GitConfigScope2["system"] = "system";
      GitConfigScope2["global"] = "global";
      GitConfigScope2["local"] = "local";
      GitConfigScope2["worktree"] = "worktree";
      return GitConfigScope2;
    })(GitConfigScope || {});
  }
});
function isDiffNameStatus(input) {
  return diffNameStatus.has(input);
}
__name(isDiffNameStatus, "isDiffNameStatus");
var DiffNameStatus;
var diffNameStatus;
var init_diff_name_status = __esm2({
  "src/lib/tasks/diff-name-status.ts"() {
    "use strict";
    DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {
      DiffNameStatus2["ADDED"] = "A";
      DiffNameStatus2["COPIED"] = "C";
      DiffNameStatus2["DELETED"] = "D";
      DiffNameStatus2["MODIFIED"] = "M";
      DiffNameStatus2["RENAMED"] = "R";
      DiffNameStatus2["CHANGED"] = "T";
      DiffNameStatus2["UNMERGED"] = "U";
      DiffNameStatus2["UNKNOWN"] = "X";
      DiffNameStatus2["BROKEN"] = "B";
      return DiffNameStatus2;
    })(DiffNameStatus || {});
    diffNameStatus = new Set(Object.values(DiffNameStatus));
  }
});
function grepQueryBuilder(...params) {
  return new GrepQuery().param(...params);
}
__name(grepQueryBuilder, "grepQueryBuilder");
function parseGrep(grep) {
  const paths = /* @__PURE__ */ new Set();
  const results = {};
  forEachLineWithContent(grep, (input) => {
    const [path4, line, preview] = input.split(NULL);
    paths.add(path4);
    (results[path4] = results[path4] || []).push({
      line: asNumber(line),
      path: path4,
      preview
    });
  });
  return {
    paths,
    results
  };
}
__name(parseGrep, "parseGrep");
function grep_default() {
  return {
    grep(searchTerm) {
      const then = trailingFunctionArgument(arguments);
      const options = getTrailingOptions(arguments);
      for (const option of disallowedOptions) {
        if (options.includes(option)) {
          return this._runTask(
            configurationErrorTask(`git.grep: use of "${option}" is not supported.`),
            then
          );
        }
      }
      if (typeof searchTerm === "string") {
        searchTerm = grepQueryBuilder().param(searchTerm);
      }
      const commands = ["grep", "--null", "-n", "--full-name", ...options, ...searchTerm];
      return this._runTask(
        {
          commands,
          format: "utf-8",
          parser(stdOut) {
            return parseGrep(stdOut);
          }
        },
        then
      );
    }
  };
}
__name(grep_default, "grep_default");
var disallowedOptions;
var Query;
var _a;
var GrepQuery;
var init_grep = __esm2({
  "src/lib/tasks/grep.ts"() {
    "use strict";
    init_utils2();
    init_task();
    disallowedOptions = ["-h"];
    Query = Symbol("grepQuery");
    GrepQuery = class {
      static {
        __name(this, "GrepQuery");
      }
      constructor() {
        this[_a] = [];
      }
      *[(_a = Query, Symbol.iterator)]() {
        for (const query of this[Query]) {
          yield query;
        }
      }
      and(...and) {
        and.length && this[Query].push("--and", "(", ...prefixedArray(and, "-e"), ")");
        return this;
      }
      param(...param) {
        this[Query].push(...prefixedArray(param, "-e"));
        return this;
      }
    };
  }
});
var reset_exports = {};
__export2(reset_exports, {
  ResetMode: /* @__PURE__ */ __name(() => ResetMode, "ResetMode"),
  getResetMode: /* @__PURE__ */ __name(() => getResetMode, "getResetMode"),
  resetTask: /* @__PURE__ */ __name(() => resetTask, "resetTask")
});
function resetTask(mode, customArgs) {
  const commands = ["reset"];
  if (isValidResetMode(mode)) {
    commands.push(`--${mode}`);
  }
  commands.push(...customArgs);
  return straightThroughStringTask(commands);
}
__name(resetTask, "resetTask");
function getResetMode(mode) {
  if (isValidResetMode(mode)) {
    return mode;
  }
  switch (typeof mode) {
    case "string":
    case "undefined":
      return "soft";
  }
  return;
}
__name(getResetMode, "getResetMode");
function isValidResetMode(mode) {
  return ResetModes.includes(mode);
}
__name(isValidResetMode, "isValidResetMode");
var ResetMode;
var ResetModes;
var init_reset = __esm2({
  "src/lib/tasks/reset.ts"() {
    "use strict";
    init_task();
    ResetMode = /* @__PURE__ */ ((ResetMode2) => {
      ResetMode2["MIXED"] = "mixed";
      ResetMode2["SOFT"] = "soft";
      ResetMode2["HARD"] = "hard";
      ResetMode2["MERGE"] = "merge";
      ResetMode2["KEEP"] = "keep";
      return ResetMode2;
    })(ResetMode || {});
    ResetModes = Array.from(Object.values(ResetMode));
  }
});
function createLog() {
  return (0, import_debug.default)("simple-git");
}
__name(createLog, "createLog");
function prefixedLogger(to, prefix, forward) {
  if (!prefix || !String(prefix).replace(/\s*/, "")) {
    return !forward ? to : (message, ...args) => {
      to(message, ...args);
      forward(message, ...args);
    };
  }
  return (message, ...args) => {
    to(`%s ${message}`, prefix, ...args);
    if (forward) {
      forward(message, ...args);
    }
  };
}
__name(prefixedLogger, "prefixedLogger");
function childLoggerName(name, childDebugger, { namespace: parentNamespace }) {
  if (typeof name === "string") {
    return name;
  }
  const childNamespace = childDebugger && childDebugger.namespace || "";
  if (childNamespace.startsWith(parentNamespace)) {
    return childNamespace.substr(parentNamespace.length + 1);
  }
  return childNamespace || parentNamespace;
}
__name(childLoggerName, "childLoggerName");
function createLogger(label, verbose, initialStep, infoDebugger = createLog()) {
  const labelPrefix = label && `[${label}]` || "";
  const spawned = [];
  const debugDebugger = typeof verbose === "string" ? infoDebugger.extend(verbose) : verbose;
  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);
  return step(initialStep);
  function sibling(name, initial) {
    return append(
      spawned,
      createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger)
    );
  }
  __name(sibling, "sibling");
  function step(phase) {
    const stepPrefix = phase && `[${phase}]` || "";
    const debug22 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;
    const info3 = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug22);
    return Object.assign(debugDebugger ? debug22 : info3, {
      label,
      sibling,
      info: info3,
      step
    });
  }
  __name(step, "step");
}
__name(createLogger, "createLogger");
var init_git_logger = __esm2({
  "src/lib/git-logger.ts"() {
    "use strict";
    init_utils2();
    import_debug.default.formatters.L = (value) => String(filterHasLength(value) ? value.length : "-");
    import_debug.default.formatters.B = (value) => {
      if (Buffer.isBuffer(value)) {
        return value.toString("utf8");
      }
      return objectToString2(value);
    };
  }
});
var TasksPendingQueue;
var init_tasks_pending_queue = __esm2({
  "src/lib/runners/tasks-pending-queue.ts"() {
    "use strict";
    init_git_error();
    init_git_logger();
    TasksPendingQueue = class _TasksPendingQueue {
      static {
        __name(this, "_TasksPendingQueue");
      }
      constructor(logLabel = "GitExecutor") {
        this.logLabel = logLabel;
        this._queue = /* @__PURE__ */ new Map();
      }
      withProgress(task) {
        return this._queue.get(task);
      }
      createProgress(task) {
        const name = _TasksPendingQueue.getName(task.commands[0]);
        const logger = createLogger(this.logLabel, name);
        return {
          task,
          logger,
          name
        };
      }
      push(task) {
        const progress = this.createProgress(task);
        progress.logger("Adding task to the queue, commands = %o", task.commands);
        this._queue.set(task, progress);
        return progress;
      }
      fatal(err) {
        for (const [task, { logger }] of Array.from(this._queue.entries())) {
          if (task === err.task) {
            logger.info(`Failed %o`, err);
            logger(
              `Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`
            );
          } else {
            logger.info(
              `A fatal exception occurred in a previous task, the queue has been purged: %o`,
              err.message
            );
          }
          this.complete(task);
        }
        if (this._queue.size !== 0) {
          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);
        }
      }
      complete(task) {
        const progress = this.withProgress(task);
        if (progress) {
          this._queue.delete(task);
        }
      }
      attempt(task) {
        const progress = this.withProgress(task);
        if (!progress) {
          throw new GitError(void 0, "TasksPendingQueue: attempt called for an unknown task");
        }
        progress.logger("Starting task");
        return progress;
      }
      static getName(name = "empty") {
        return `task:${name}:${++_TasksPendingQueue.counter}`;
      }
      static {
        this.counter = 0;
      }
    };
  }
});
function pluginContext(task, commands) {
  return {
    method: first(task.commands) || "",
    commands
  };
}
__name(pluginContext, "pluginContext");
function onErrorReceived(target, logger) {
  return (err) => {
    logger(`[ERROR] child process exception %o`, err);
    target.push(Buffer.from(String(err.stack), "ascii"));
  };
}
__name(onErrorReceived, "onErrorReceived");
function onDataReceived(target, name, logger, output) {
  return (buffer) => {
    logger(`%s received %L bytes`, name, buffer);
    output(`%B`, buffer);
    target.push(buffer);
  };
}
__name(onDataReceived, "onDataReceived");
var GitExecutorChain;
var init_git_executor_chain = __esm2({
  "src/lib/runners/git-executor-chain.ts"() {
    "use strict";
    init_git_error();
    init_task();
    init_utils2();
    init_tasks_pending_queue();
    GitExecutorChain = class {
      static {
        __name(this, "GitExecutorChain");
      }
      constructor(_executor, _scheduler, _plugins) {
        this._executor = _executor;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = Promise.resolve();
        this._queue = new TasksPendingQueue();
      }
      get cwd() {
        return this._cwd || this._executor.cwd;
      }
      set cwd(cwd2) {
        this._cwd = cwd2;
      }
      get env() {
        return this._executor.env;
      }
      get outputHandler() {
        return this._executor.outputHandler;
      }
      chain() {
        return this;
      }
      push(task) {
        this._queue.push(task);
        return this._chain = this._chain.then(() => this.attemptTask(task));
      }
      async attemptTask(task) {
        const onScheduleComplete = await this._scheduler.next();
        const onQueueComplete = /* @__PURE__ */ __name(() => this._queue.complete(task), "onQueueComplete");
        try {
          const { logger } = this._queue.attempt(task);
          return await (isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger));
        } catch (e) {
          throw this.onFatalException(task, e);
        } finally {
          onQueueComplete();
          onScheduleComplete();
        }
      }
      onFatalException(task, e) {
        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));
        this._chain = Promise.resolve();
        this._queue.fatal(gitError);
        return gitError;
      }
      async attemptRemoteTask(task, logger) {
        const binary = this._plugins.exec("spawn.binary", "", pluginContext(task, task.commands));
        const args = this._plugins.exec(
          "spawn.args",
          [...task.commands],
          pluginContext(task, task.commands)
        );
        const raw = await this.gitResponse(
          task,
          binary,
          args,
          this.outputHandler,
          logger.step("SPAWN")
        );
        const outputStreams = await this.handleTaskData(task, args, raw, logger.step("HANDLE"));
        logger(`passing response to task's parser as a %s`, task.format);
        if (isBufferTask(task)) {
          return callTaskParser(task.parser, outputStreams);
        }
        return callTaskParser(task.parser, outputStreams.asStrings());
      }
      async attemptEmptyTask(task, logger) {
        logger(`empty task bypassing child process to call to task's parser`);
        return task.parser(this);
      }
      handleTaskData(task, args, result, logger) {
        const { exitCode: exitCode2, rejection, stdOut, stdErr } = result;
        return new Promise((done, fail) => {
          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode2);
          const { error: error4 } = this._plugins.exec(
            "task.error",
            { error: rejection },
            {
              ...pluginContext(task, args),
              ...result
            }
          );
          if (error4 && task.onError) {
            logger.info(`exitCode=%s handling with custom error handler`);
            return task.onError(
              result,
              error4,
              (newStdOut) => {
                logger.info(`custom error handler treated as success`);
                logger(`custom error returned a %s`, objectToString2(newStdOut));
                done(
                  new GitOutputStreams(
                    Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,
                    Buffer.concat(stdErr)
                  )
                );
              },
              fail
            );
          }
          if (error4) {
            logger.info(
              `handling as error: exitCode=%s stdErr=%s rejection=%o`,
              exitCode2,
              stdErr.length,
              rejection
            );
            return fail(error4);
          }
          logger.info(`retrieving task output complete`);
          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));
        });
      }
      async gitResponse(task, command, args, outputHandler, logger) {
        const outputLogger = logger.sibling("output");
        const spawnOptions = this._plugins.exec(
          "spawn.options",
          {
            cwd: this.cwd,
            env: this.env,
            windowsHide: true
          },
          pluginContext(task, task.commands)
        );
        return new Promise((done) => {
          const stdOut = [];
          const stdErr = [];
          logger.info(`%s %o`, command, args);
          logger("%O", spawnOptions);
          let rejection = this._beforeSpawn(task, args);
          if (rejection) {
            return done({
              stdOut,
              stdErr,
              exitCode: 9901,
              rejection
            });
          }
          this._plugins.exec("spawn.before", void 0, {
            ...pluginContext(task, args),
            kill(reason) {
              rejection = reason || rejection;
            }
          });
          const spawned = spawn(command, args, spawnOptions);
          spawned.stdout.on(
            "data",
            onDataReceived(stdOut, "stdOut", logger, outputLogger.step("stdOut"))
          );
          spawned.stderr.on(
            "data",
            onDataReceived(stdErr, "stdErr", logger, outputLogger.step("stdErr"))
          );
          spawned.on("error", onErrorReceived(stdErr, logger));
          if (outputHandler) {
            logger(`Passing child process stdOut/stdErr to custom outputHandler`);
            outputHandler(command, spawned.stdout, spawned.stderr, [...args]);
          }
          this._plugins.exec("spawn.after", void 0, {
            ...pluginContext(task, args),
            spawned,
            close(exitCode2, reason) {
              done({
                stdOut,
                stdErr,
                exitCode: exitCode2,
                rejection: rejection || reason
              });
            },
            kill(reason) {
              if (spawned.killed) {
                return;
              }
              rejection = reason;
              spawned.kill("SIGINT");
            }
          });
        });
      }
      _beforeSpawn(task, args) {
        let rejection;
        this._plugins.exec("spawn.before", void 0, {
          ...pluginContext(task, args),
          kill(reason) {
            rejection = reason || rejection;
          }
        });
        return rejection;
      }
    };
  }
});
var git_executor_exports = {};
__export2(git_executor_exports, {
  GitExecutor: /* @__PURE__ */ __name(() => GitExecutor, "GitExecutor")
});
var GitExecutor;
var init_git_executor = __esm2({
  "src/lib/runners/git-executor.ts"() {
    "use strict";
    init_git_executor_chain();
    GitExecutor = class {
      static {
        __name(this, "GitExecutor");
      }
      constructor(cwd2, _scheduler, _plugins) {
        this.cwd = cwd2;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      chain() {
        return new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      push(task) {
        return this._chain.push(task);
      }
    };
  }
});
function taskCallback(task, response, callback = NOOP) {
  const onSuccess = /* @__PURE__ */ __name((data) => {
    callback(null, data);
  }, "onSuccess");
  const onError2 = /* @__PURE__ */ __name((err) => {
    if (err?.task === task) {
      callback(
        err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err,
        void 0
      );
    }
  }, "onError2");
  response.then(onSuccess, onError2);
}
__name(taskCallback, "taskCallback");
function addDeprecationNoticeToError(err) {
  let log4 = /* @__PURE__ */ __name((name) => {
    console.warn(
      `simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`
    );
    log4 = NOOP;
  }, "log");
  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));
  function descriptorReducer(all, name) {
    if (name in err) {
      return all;
    }
    all[name] = {
      enumerable: false,
      configurable: false,
      get() {
        log4(name);
        return err.git[name];
      }
    };
    return all;
  }
  __name(descriptorReducer, "descriptorReducer");
}
__name(addDeprecationNoticeToError, "addDeprecationNoticeToError");
var init_task_callback = __esm2({
  "src/lib/task-callback.ts"() {
    "use strict";
    init_git_response_error();
    init_utils2();
  }
});
function changeWorkingDirectoryTask(directory, root) {
  return adhocExecTask((instance) => {
    if (!folderExists(directory)) {
      throw new Error(`Git.cwd: cannot change to non-directory "${directory}"`);
    }
    return (root || instance).cwd = directory;
  });
}
__name(changeWorkingDirectoryTask, "changeWorkingDirectoryTask");
var init_change_working_directory = __esm2({
  "src/lib/tasks/change-working-directory.ts"() {
    "use strict";
    init_utils2();
    init_task();
  }
});
function checkoutTask(args) {
  const commands = ["checkout", ...args];
  if (commands[1] === "-b" && commands.includes("-B")) {
    commands[1] = remove(commands, "-B");
  }
  return straightThroughStringTask(commands);
}
__name(checkoutTask, "checkoutTask");
function checkout_default() {
  return {
    checkout() {
      return this._runTask(
        checkoutTask(getTrailingOptions(arguments, 1)),
        trailingFunctionArgument(arguments)
      );
    },
    checkoutBranch(branchName, startPoint) {
      return this._runTask(
        checkoutTask(["-b", branchName, startPoint, ...getTrailingOptions(arguments)]),
        trailingFunctionArgument(arguments)
      );
    },
    checkoutLocalBranch(branchName) {
      return this._runTask(
        checkoutTask(["-b", branchName, ...getTrailingOptions(arguments)]),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
__name(checkout_default, "checkout_default");
var init_checkout = __esm2({
  "src/lib/tasks/checkout.ts"() {
    "use strict";
    init_utils2();
    init_task();
  }
});
function countObjectsResponse() {
  return {
    count: 0,
    garbage: 0,
    inPack: 0,
    packs: 0,
    prunePackable: 0,
    size: 0,
    sizeGarbage: 0,
    sizePack: 0
  };
}
__name(countObjectsResponse, "countObjectsResponse");
function count_objects_default() {
  return {
    countObjects() {
      return this._runTask({
        commands: ["count-objects", "--verbose"],
        format: "utf-8",
        parser(stdOut) {
          return parseStringResponse(countObjectsResponse(), [parser2], stdOut);
        }
      });
    }
  };
}
__name(count_objects_default, "count_objects_default");
var parser2;
var init_count_objects = __esm2({
  "src/lib/tasks/count-objects.ts"() {
    "use strict";
    init_utils2();
    parser2 = new LineParser(
      /([a-z-]+): (\d+)$/,
      (result, [key, value]) => {
        const property = asCamelCase(key);
        if (result.hasOwnProperty(property)) {
          result[property] = asNumber(value);
        }
      }
    );
  }
});
function parseCommitResult(stdOut) {
  const result = {
    author: null,
    branch: "",
    commit: "",
    root: false,
    summary: {
      changes: 0,
      insertions: 0,
      deletions: 0
    }
  };
  return parseStringResponse(result, parsers, stdOut);
}
__name(parseCommitResult, "parseCommitResult");
var parsers;
var init_parse_commit = __esm2({
  "src/lib/parsers/parse-commit.ts"() {
    "use strict";
    init_utils2();
    parsers = [
      new LineParser(/^\[([^\s]+)( \([^)]+\))? ([^\]]+)/, (result, [branch, root, commit]) => {
        result.branch = branch;
        result.commit = commit;
        result.root = !!root;
      }),
      new LineParser(/\s*Author:\s(.+)/i, (result, [author]) => {
        const parts = author.split("<");
        const email = parts.pop();
        if (!email || !email.includes("@")) {
          return;
        }
        result.author = {
          email: email.substr(0, email.length - 1),
          name: parts.join("<").trim()
        };
      }),
      new LineParser(
        /(\d+)[^,]*(?:,\s*(\d+)[^,]*)(?:,\s*(\d+))/g,
        (result, [changes, insertions, deletions]) => {
          result.summary.changes = parseInt(changes, 10) || 0;
          result.summary.insertions = parseInt(insertions, 10) || 0;
          result.summary.deletions = parseInt(deletions, 10) || 0;
        }
      ),
      new LineParser(
        /^(\d+)[^,]*(?:,\s*(\d+)[^(]+\(([+-]))?/,
        (result, [changes, lines, direction]) => {
          result.summary.changes = parseInt(changes, 10) || 0;
          const count3 = parseInt(lines, 10) || 0;
          if (direction === "-") {
            result.summary.deletions = count3;
          } else if (direction === "+") {
            result.summary.insertions = count3;
          }
        }
      )
    ];
  }
});
function commitTask(message, files, customArgs) {
  const commands = [
    "-c",
    "core.abbrev=40",
    "commit",
    ...prefixedArray(message, "-m"),
    ...files,
    ...customArgs
  ];
  return {
    commands,
    format: "utf-8",
    parser: parseCommitResult
  };
}
__name(commitTask, "commitTask");
function commit_default() {
  return {
    commit(message, ...rest) {
      const next2 = trailingFunctionArgument(arguments);
      const task = rejectDeprecatedSignatures(message) || commitTask(
        asArray(message),
        asArray(filterType(rest[0], filterStringOrStringArray, [])),
        [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]
      );
      return this._runTask(task, next2);
    }
  };
  function rejectDeprecatedSignatures(message) {
    return !filterStringOrStringArray(message) && configurationErrorTask(
      `git.commit: requires the commit message to be supplied as a string/string[]`
    );
  }
  __name(rejectDeprecatedSignatures, "rejectDeprecatedSignatures");
}
__name(commit_default, "commit_default");
var init_commit = __esm2({
  "src/lib/tasks/commit.ts"() {
    "use strict";
    init_parse_commit();
    init_utils2();
    init_task();
  }
});
function first_commit_default() {
  return {
    firstCommit() {
      return this._runTask(
        straightThroughStringTask(["rev-list", "--max-parents=0", "HEAD"], true),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
__name(first_commit_default, "first_commit_default");
var init_first_commit = __esm2({
  "src/lib/tasks/first-commit.ts"() {
    "use strict";
    init_utils2();
    init_task();
  }
});
function hashObjectTask(filePath, write2) {
  const commands = ["hash-object", filePath];
  if (write2) {
    commands.push("-w");
  }
  return straightThroughStringTask(commands, true);
}
__name(hashObjectTask, "hashObjectTask");
var init_hash_object = __esm2({
  "src/lib/tasks/hash-object.ts"() {
    "use strict";
    init_task();
  }
});
function parseInit(bare, path4, text) {
  const response = String(text).trim();
  let result;
  if (result = initResponseRegex.exec(response)) {
    return new InitSummary(bare, path4, false, result[1]);
  }
  if (result = reInitResponseRegex.exec(response)) {
    return new InitSummary(bare, path4, true, result[1]);
  }
  let gitDir = "";
  const tokens = response.split(" ");
  while (tokens.length) {
    const token = tokens.shift();
    if (token === "in") {
      gitDir = tokens.join(" ");
      break;
    }
  }
  return new InitSummary(bare, path4, /^re/i.test(response), gitDir);
}
__name(parseInit, "parseInit");
var InitSummary;
var initResponseRegex;
var reInitResponseRegex;
var init_InitSummary = __esm2({
  "src/lib/responses/InitSummary.ts"() {
    "use strict";
    InitSummary = class {
      static {
        __name(this, "InitSummary");
      }
      constructor(bare, path4, existing, gitDir) {
        this.bare = bare;
        this.path = path4;
        this.existing = existing;
        this.gitDir = gitDir;
      }
    };
    initResponseRegex = /^Init.+ repository in (.+)$/;
    reInitResponseRegex = /^Rein.+ in (.+)$/;
  }
});
function hasBareCommand(command) {
  return command.includes(bareCommand);
}
__name(hasBareCommand, "hasBareCommand");
function initTask(bare = false, path4, customArgs) {
  const commands = ["init", ...customArgs];
  if (bare && !hasBareCommand(commands)) {
    commands.splice(1, 0, bareCommand);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return parseInit(commands.includes("--bare"), path4, text);
    }
  };
}
__name(initTask, "initTask");
var bareCommand;
var init_init = __esm2({
  "src/lib/tasks/init.ts"() {
    "use strict";
    init_InitSummary();
    bareCommand = "--bare";
  }
});
function logFormatFromCommand(customArgs) {
  for (let i = 0; i < customArgs.length; i++) {
    const format = logFormatRegex.exec(customArgs[i]);
    if (format) {
      return `--${format[1]}`;
    }
  }
  return "";
}
__name(logFormatFromCommand, "logFormatFromCommand");
function isLogFormat(customArg) {
  return logFormatRegex.test(customArg);
}
__name(isLogFormat, "isLogFormat");
var logFormatRegex;
var init_log_format = __esm2({
  "src/lib/args/log-format.ts"() {
    "use strict";
    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;
  }
});
var DiffSummary;
var init_DiffSummary = __esm2({
  "src/lib/responses/DiffSummary.ts"() {
    "use strict";
    DiffSummary = class {
      static {
        __name(this, "DiffSummary");
      }
      constructor() {
        this.changed = 0;
        this.deletions = 0;
        this.insertions = 0;
        this.files = [];
      }
    };
  }
});
function getDiffParser(format = "") {
  const parser4 = diffSummaryParsers[format];
  return (stdOut) => parseStringResponse(new DiffSummary(), parser4, stdOut, false);
}
__name(getDiffParser, "getDiffParser");
var statParser;
var numStatParser;
var nameOnlyParser;
var nameStatusParser;
var diffSummaryParsers;
var init_parse_diff_summary = __esm2({
  "src/lib/parsers/parse-diff-summary.ts"() {
    "use strict";
    init_log_format();
    init_DiffSummary();
    init_diff_name_status();
    init_utils2();
    statParser = [
      new LineParser(
        /^(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/,
        (result, [file, changes, alterations = ""]) => {
          result.files.push({
            file: file.trim(),
            changes: asNumber(changes),
            insertions: alterations.replace(/[^+]/g, "").length,
            deletions: alterations.replace(/[^-]/g, "").length,
            binary: false
          });
        }
      ),
      new LineParser(
        /^(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/,
        (result, [file, before, after]) => {
          result.files.push({
            file: file.trim(),
            before: asNumber(before),
            after: asNumber(after),
            binary: true
          });
        }
      ),
      new LineParser(
        /(\d+) files? changed\s*((?:, \d+ [^,]+){0,2})/,
        (result, [changed, summary]) => {
          const inserted = /(\d+) i/.exec(summary);
          const deleted = /(\d+) d/.exec(summary);
          result.changed = asNumber(changed);
          result.insertions = asNumber(inserted?.[1]);
          result.deletions = asNumber(deleted?.[1]);
        }
      )
    ];
    numStatParser = [
      new LineParser(
        /(\d+)\t(\d+)\t(.+)$/,
        (result, [changesInsert, changesDelete, file]) => {
          const insertions = asNumber(changesInsert);
          const deletions = asNumber(changesDelete);
          result.changed++;
          result.insertions += insertions;
          result.deletions += deletions;
          result.files.push({
            file,
            changes: insertions + deletions,
            insertions,
            deletions,
            binary: false
          });
        }
      ),
      new LineParser(/-\t-\t(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          after: 0,
          before: 0,
          binary: true
        });
      })
    ];
    nameOnlyParser = [
      new LineParser(/(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          changes: 0,
          insertions: 0,
          deletions: 0,
          binary: false
        });
      })
    ];
    nameStatusParser = [
      new LineParser(
        /([ACDMRTUXB])([0-9]{0,3})\t(.[^\t]*)(\t(.[^\t]*))?$/,
        (result, [status, similarity, from, _to, to]) => {
          result.changed++;
          result.files.push({
            file: to ?? from,
            changes: 0,
            insertions: 0,
            deletions: 0,
            binary: false,
            status: orVoid(isDiffNameStatus(status) && status),
            from: orVoid(!!to && from !== to && from),
            similarity: asNumber(similarity)
          });
        }
      )
    ];
    diffSummaryParsers = {
      [
        ""
        /* NONE */
      ]: statParser,
      [
        "--stat"
        /* STAT */
      ]: statParser,
      [
        "--numstat"
        /* NUM_STAT */
      ]: numStatParser,
      [
        "--name-status"
        /* NAME_STATUS */
      ]: nameStatusParser,
      [
        "--name-only"
        /* NAME_ONLY */
      ]: nameOnlyParser
    };
  }
});
function lineBuilder(tokens, fields) {
  return fields.reduce(
    (line, field, index) => {
      line[field] = tokens[index] || "";
      return line;
    },
    /* @__PURE__ */ Object.create({ diff: null })
  );
}
__name(lineBuilder, "lineBuilder");
function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = "") {
  const parseDiffResult = getDiffParser(logFormat);
  return function(stdOut) {
    const all = toLinesWithContent(
      stdOut.trim(),
      false,
      START_BOUNDARY
    ).map(function(item) {
      const lineDetail = item.split(COMMIT_BOUNDARY);
      const listLogLine = lineBuilder(lineDetail[0].split(splitter), fields);
      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {
        listLogLine.diff = parseDiffResult(lineDetail[1]);
      }
      return listLogLine;
    });
    return {
      all,
      latest: all.length && all[0] || null,
      total: all.length
    };
  };
}
__name(createListLogSummaryParser, "createListLogSummaryParser");
var START_BOUNDARY;
var COMMIT_BOUNDARY;
var SPLITTER;
var defaultFieldNames;
var init_parse_list_log_summary = __esm2({
  "src/lib/parsers/parse-list-log-summary.ts"() {
    "use strict";
    init_utils2();
    init_parse_diff_summary();
    init_log_format();
    START_BOUNDARY = "\xF2\xF2\xF2\xF2\xF2\xF2 ";
    COMMIT_BOUNDARY = " \xF2\xF2";
    SPLITTER = " \xF2 ";
    defaultFieldNames = ["hash", "date", "message", "refs", "author_name", "author_email"];
  }
});
var diff_exports = {};
__export2(diff_exports, {
  diffSummaryTask: /* @__PURE__ */ __name(() => diffSummaryTask, "diffSummaryTask"),
  validateLogFormatConfig: /* @__PURE__ */ __name(() => validateLogFormatConfig, "validateLogFormatConfig")
});
function diffSummaryTask(customArgs) {
  let logFormat = logFormatFromCommand(customArgs);
  const commands = ["diff"];
  if (logFormat === "") {
    logFormat = "--stat";
    commands.push("--stat=4096");
  }
  commands.push(...customArgs);
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: getDiffParser(logFormat)
  };
}
__name(diffSummaryTask, "diffSummaryTask");
function validateLogFormatConfig(customArgs) {
  const flags = customArgs.filter(isLogFormat);
  if (flags.length > 1) {
    return configurationErrorTask(
      `Summary flags are mutually exclusive - pick one of ${flags.join(",")}`
    );
  }
  if (flags.length && customArgs.includes("-z")) {
    return configurationErrorTask(
      `Summary flag ${flags} parsing is not compatible with null termination option '-z'`
    );
  }
}
__name(validateLogFormatConfig, "validateLogFormatConfig");
var init_diff = __esm2({
  "src/lib/tasks/diff.ts"() {
    "use strict";
    init_log_format();
    init_parse_diff_summary();
    init_task();
  }
});
function prettyFormat(format, splitter) {
  const fields = [];
  const formatStr = [];
  Object.keys(format).forEach((field) => {
    fields.push(field);
    formatStr.push(String(format[field]));
  });
  return [fields, formatStr.join(splitter)];
}
__name(prettyFormat, "prettyFormat");
function userOptions(input) {
  return Object.keys(input).reduce((out, key) => {
    if (!(key in excludeOptions)) {
      out[key] = input[key];
    }
    return out;
  }, {});
}
__name(userOptions, "userOptions");
function parseLogOptions(opt = {}, customArgs = []) {
  const splitter = filterType(opt.splitter, filterString, SPLITTER);
  const format = filterPlainObject(opt.format) ? opt.format : {
    hash: "%H",
    date: opt.strictDate === false ? "%ai" : "%aI",
    message: "%s",
    refs: "%D",
    body: opt.multiLine ? "%B" : "%b",
    author_name: opt.mailMap !== false ? "%aN" : "%an",
    author_email: opt.mailMap !== false ? "%aE" : "%ae"
  };
  const [fields, formatStr] = prettyFormat(format, splitter);
  const suffix = [];
  const command = [
    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,
    ...customArgs
  ];
  const maxCount = opt.n || opt["max-count"] || opt.maxCount;
  if (maxCount) {
    command.push(`--max-count=${maxCount}`);
  }
  if (opt.from || opt.to) {
    const rangeOperator = opt.symmetric !== false ? "..." : "..";
    suffix.push(`${opt.from || ""}${rangeOperator}${opt.to || ""}`);
  }
  if (filterString(opt.file)) {
    command.push("--follow", pathspec(opt.file));
  }
  appendTaskOptions(userOptions(opt), command);
  return {
    fields,
    splitter,
    commands: [...command, ...suffix]
  };
}
__name(parseLogOptions, "parseLogOptions");
function logTask(splitter, fields, customArgs) {
  const parser4 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));
  return {
    commands: ["log", ...customArgs],
    format: "utf-8",
    parser: parser4
  };
}
__name(logTask, "logTask");
function log_default() {
  return {
    log(...rest) {
      const next2 = trailingFunctionArgument(arguments);
      const options = parseLogOptions(
        trailingOptionsArgument(arguments),
        filterType(arguments[0], filterArray)
      );
      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);
      return this._runTask(task, next2);
    }
  };
  function createLogTask(options) {
    return logTask(options.splitter, options.fields, options.commands);
  }
  __name(createLogTask, "createLogTask");
  function rejectDeprecatedSignatures(from, to) {
    return filterString(from) && filterString(to) && configurationErrorTask(
      `git.log(string, string) should be replaced with git.log({ from: string, to: string })`
    );
  }
  __name(rejectDeprecatedSignatures, "rejectDeprecatedSignatures");
}
__name(log_default, "log_default");
var excludeOptions;
var init_log = __esm2({
  "src/lib/tasks/log.ts"() {
    "use strict";
    init_log_format();
    init_pathspec();
    init_parse_list_log_summary();
    init_utils2();
    init_task();
    init_diff();
    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {
      excludeOptions2[excludeOptions2["--pretty"] = 0] = "--pretty";
      excludeOptions2[excludeOptions2["max-count"] = 1] = "max-count";
      excludeOptions2[excludeOptions2["maxCount"] = 2] = "maxCount";
      excludeOptions2[excludeOptions2["n"] = 3] = "n";
      excludeOptions2[excludeOptions2["file"] = 4] = "file";
      excludeOptions2[excludeOptions2["format"] = 5] = "format";
      excludeOptions2[excludeOptions2["from"] = 6] = "from";
      excludeOptions2[excludeOptions2["to"] = 7] = "to";
      excludeOptions2[excludeOptions2["splitter"] = 8] = "splitter";
      excludeOptions2[excludeOptions2["symmetric"] = 9] = "symmetric";
      excludeOptions2[excludeOptions2["mailMap"] = 10] = "mailMap";
      excludeOptions2[excludeOptions2["multiLine"] = 11] = "multiLine";
      excludeOptions2[excludeOptions2["strictDate"] = 12] = "strictDate";
      return excludeOptions2;
    })(excludeOptions || {});
  }
});
var MergeSummaryConflict;
var MergeSummaryDetail;
var init_MergeSummary = __esm2({
  "src/lib/responses/MergeSummary.ts"() {
    "use strict";
    MergeSummaryConflict = class {
      static {
        __name(this, "MergeSummaryConflict");
      }
      constructor(reason, file = null, meta) {
        this.reason = reason;
        this.file = file;
        this.meta = meta;
      }
      toString() {
        return `${this.file}:${this.reason}`;
      }
    };
    MergeSummaryDetail = class {
      static {
        __name(this, "MergeSummaryDetail");
      }
      constructor() {
        this.conflicts = [];
        this.merges = [];
        this.result = "success";
      }
      get failed() {
        return this.conflicts.length > 0;
      }
      get reason() {
        return this.result;
      }
      toString() {
        if (this.conflicts.length) {
          return `CONFLICTS: ${this.conflicts.join(", ")}`;
        }
        return "OK";
      }
    };
  }
});
var PullSummary;
var PullFailedSummary;
var init_PullSummary = __esm2({
  "src/lib/responses/PullSummary.ts"() {
    "use strict";
    PullSummary = class {
      static {
        __name(this, "PullSummary");
      }
      constructor() {
        this.remoteMessages = {
          all: []
        };
        this.created = [];
        this.deleted = [];
        this.files = [];
        this.deletions = {};
        this.insertions = {};
        this.summary = {
          changes: 0,
          deletions: 0,
          insertions: 0
        };
      }
    };
    PullFailedSummary = class {
      static {
        __name(this, "PullFailedSummary");
      }
      constructor() {
        this.remote = "";
        this.hash = {
          local: "",
          remote: ""
        };
        this.branch = {
          local: "",
          remote: ""
        };
        this.message = "";
      }
      toString() {
        return this.message;
      }
    };
  }
});
function objectEnumerationResult(remoteMessages) {
  return remoteMessages.objects = remoteMessages.objects || {
    compressing: 0,
    counting: 0,
    enumerating: 0,
    packReused: 0,
    reused: { count: 0, delta: 0 },
    total: { count: 0, delta: 0 }
  };
}
__name(objectEnumerationResult, "objectEnumerationResult");
function asObjectCount(source) {
  const count3 = /^\s*(\d+)/.exec(source);
  const delta = /delta (\d+)/i.exec(source);
  return {
    count: asNumber(count3 && count3[1] || "0"),
    delta: asNumber(delta && delta[1] || "0")
  };
}
__name(asObjectCount, "asObjectCount");
var remoteMessagesObjectParsers;
var init_parse_remote_objects = __esm2({
  "src/lib/parsers/parse-remote-objects.ts"() {
    "use strict";
    init_utils2();
    remoteMessagesObjectParsers = [
      new RemoteLineParser(
        /^remote:\s*(enumerating|counting|compressing) objects: (\d+),/i,
        (result, [action, count3]) => {
          const key = action.toLowerCase();
          const enumeration = objectEnumerationResult(result.remoteMessages);
          Object.assign(enumeration, { [key]: asNumber(count3) });
        }
      ),
      new RemoteLineParser(
        /^remote:\s*(enumerating|counting|compressing) objects: \d+% \(\d+\/(\d+)\),/i,
        (result, [action, count3]) => {
          const key = action.toLowerCase();
          const enumeration = objectEnumerationResult(result.remoteMessages);
          Object.assign(enumeration, { [key]: asNumber(count3) });
        }
      ),
      new RemoteLineParser(
        /total ([^,]+), reused ([^,]+), pack-reused (\d+)/i,
        (result, [total, reused, packReused]) => {
          const objects = objectEnumerationResult(result.remoteMessages);
          objects.total = asObjectCount(total);
          objects.reused = asObjectCount(reused);
          objects.packReused = asNumber(packReused);
        }
      )
    ];
  }
});
function parseRemoteMessages(_stdOut, stdErr) {
  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);
}
__name(parseRemoteMessages, "parseRemoteMessages");
var parsers2;
var RemoteMessageSummary;
var init_parse_remote_messages = __esm2({
  "src/lib/parsers/parse-remote-messages.ts"() {
    "use strict";
    init_utils2();
    init_parse_remote_objects();
    parsers2 = [
      new RemoteLineParser(/^remote:\s*(.+)$/, (result, [text]) => {
        result.remoteMessages.all.push(text.trim());
        return false;
      }),
      ...remoteMessagesObjectParsers,
      new RemoteLineParser(
        [/create a (?:pull|merge) request/i, /\s(https?:\/\/\S+)$/],
        (result, [pullRequestUrl]) => {
          result.remoteMessages.pullRequestUrl = pullRequestUrl;
        }
      ),
      new RemoteLineParser(
        [/found (\d+) vulnerabilities.+\(([^)]+)\)/i, /\s(https?:\/\/\S+)$/],
        (result, [count3, summary, url]) => {
          result.remoteMessages.vulnerabilities = {
            count: asNumber(count3),
            summary,
            url
          };
        }
      )
    ];
    RemoteMessageSummary = class {
      static {
        __name(this, "RemoteMessageSummary");
      }
      constructor() {
        this.all = [];
      }
    };
  }
});
function parsePullErrorResult(stdOut, stdErr) {
  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);
  return pullError.message && pullError;
}
__name(parsePullErrorResult, "parsePullErrorResult");
var FILE_UPDATE_REGEX;
var SUMMARY_REGEX;
var ACTION_REGEX;
var parsers3;
var errorParsers;
var parsePullDetail;
var parsePullResult;
var init_parse_pull = __esm2({
  "src/lib/parsers/parse-pull.ts"() {
    "use strict";
    init_PullSummary();
    init_utils2();
    init_parse_remote_messages();
    FILE_UPDATE_REGEX = /^\s*(.+?)\s+\|\s+\d+\s*(\+*)(-*)/;
    SUMMARY_REGEX = /(\d+)\D+((\d+)\D+\(\+\))?(\D+(\d+)\D+\(-\))?/;
    ACTION_REGEX = /^(create|delete) mode \d+ (.+)/;
    parsers3 = [
      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {
        result.files.push(file);
        if (insertions) {
          result.insertions[file] = insertions.length;
        }
        if (deletions) {
          result.deletions[file] = deletions.length;
        }
      }),
      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {
        if (insertions !== void 0 || deletions !== void 0) {
          result.summary.changes = +changes || 0;
          result.summary.insertions = +insertions || 0;
          result.summary.deletions = +deletions || 0;
          return true;
        }
        return false;
      }),
      new LineParser(ACTION_REGEX, (result, [action, file]) => {
        append(result.files, file);
        append(action === "create" ? result.created : result.deleted, file);
      })
    ];
    errorParsers = [
      new LineParser(/^from\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),
      new LineParser(/^fatal:\s(.+)$/, (result, [message]) => void (result.message = message)),
      new LineParser(
        /([a-z0-9]+)\.\.([a-z0-9]+)\s+(\S+)\s+->\s+(\S+)$/,
        (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {
          result.branch.local = branchLocal;
          result.hash.local = hashLocal;
          result.branch.remote = branchRemote;
          result.hash.remote = hashRemote;
        }
      )
    ];
    parsePullDetail = /* @__PURE__ */ __name((stdOut, stdErr) => {
      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);
    }, "parsePullDetail");
    parsePullResult = /* @__PURE__ */ __name((stdOut, stdErr) => {
      return Object.assign(
        new PullSummary(),
        parsePullDetail(stdOut, stdErr),
        parseRemoteMessages(stdOut, stdErr)
      );
    }, "parsePullResult");
  }
});
var parsers4;
var parseMergeResult;
var parseMergeDetail;
var init_parse_merge = __esm2({
  "src/lib/parsers/parse-merge.ts"() {
    "use strict";
    init_MergeSummary();
    init_utils2();
    init_parse_pull();
    parsers4 = [
      new LineParser(/^Auto-merging\s+(.+)$/, (summary, [autoMerge]) => {
        summary.merges.push(autoMerge);
      }),
      new LineParser(/^CONFLICT\s+\((.+)\): Merge conflict in (.+)$/, (summary, [reason, file]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, file));
      }),
      new LineParser(
        /^CONFLICT\s+\((.+\/delete)\): (.+) deleted in (.+) and/,
        (summary, [reason, file, deleteRef]) => {
          summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));
        }
      ),
      new LineParser(/^CONFLICT\s+\((.+)\):/, (summary, [reason]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, null));
      }),
      new LineParser(/^Automatic merge failed;\s+(.+)$/, (summary, [result]) => {
        summary.result = result;
      })
    ];
    parseMergeResult = /* @__PURE__ */ __name((stdOut, stdErr) => {
      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));
    }, "parseMergeResult");
    parseMergeDetail = /* @__PURE__ */ __name((stdOut) => {
      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);
    }, "parseMergeDetail");
  }
});
function mergeTask(customArgs) {
  if (!customArgs.length) {
    return configurationErrorTask("Git.merge requires at least one option");
  }
  return {
    commands: ["merge", ...customArgs],
    format: "utf-8",
    parser(stdOut, stdErr) {
      const merge = parseMergeResult(stdOut, stdErr);
      if (merge.failed) {
        throw new GitResponseError(merge);
      }
      return merge;
    }
  };
}
__name(mergeTask, "mergeTask");
var init_merge = __esm2({
  "src/lib/tasks/merge.ts"() {
    "use strict";
    init_git_response_error();
    init_parse_merge();
    init_task();
  }
});
function pushResultPushedItem(local, remote, status) {
  const deleted = status.includes("deleted");
  const tag = status.includes("tag") || /^refs\/tags/.test(local);
  const alreadyUpdated = !status.includes("new");
  return {
    deleted,
    tag,
    branch: !tag,
    new: !alreadyUpdated,
    alreadyUpdated,
    local,
    remote
  };
}
__name(pushResultPushedItem, "pushResultPushedItem");
var parsers5;
var parsePushResult;
var parsePushDetail;
var init_parse_push = __esm2({
  "src/lib/parsers/parse-push.ts"() {
    "use strict";
    init_utils2();
    init_parse_remote_messages();
    parsers5 = [
      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {
        result.repo = repo;
      }),
      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {
        result.ref = {
          ...result.ref || {},
          local
        };
      }),
      new LineParser(/^[=*-]\s+([^:]+):(\S+)\s+\[(.+)]$/, (result, [local, remote, type]) => {
        result.pushed.push(pushResultPushedItem(local, remote, type));
      }),
      new LineParser(
        /^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/,
        (result, [local, remote, remoteName]) => {
          result.branch = {
            ...result.branch || {},
            local,
            remote,
            remoteName
          };
        }
      ),
      new LineParser(
        /^([^:]+):(\S+)\s+([a-z0-9]+)\.\.([a-z0-9]+)$/,
        (result, [local, remote, from, to]) => {
          result.update = {
            head: {
              local,
              remote
            },
            hash: {
              from,
              to
            }
          };
        }
      )
    ];
    parsePushResult = /* @__PURE__ */ __name((stdOut, stdErr) => {
      const pushDetail = parsePushDetail(stdOut, stdErr);
      const responseDetail = parseRemoteMessages(stdOut, stdErr);
      return {
        ...pushDetail,
        ...responseDetail
      };
    }, "parsePushResult");
    parsePushDetail = /* @__PURE__ */ __name((stdOut, stdErr) => {
      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);
    }, "parsePushDetail");
  }
});
var push_exports = {};
__export2(push_exports, {
  pushTagsTask: /* @__PURE__ */ __name(() => pushTagsTask, "pushTagsTask"),
  pushTask: /* @__PURE__ */ __name(() => pushTask, "pushTask")
});
function pushTagsTask(ref2 = {}, customArgs) {
  append(customArgs, "--tags");
  return pushTask(ref2, customArgs);
}
__name(pushTagsTask, "pushTagsTask");
function pushTask(ref2 = {}, customArgs) {
  const commands = ["push", ...customArgs];
  if (ref2.branch) {
    commands.splice(1, 0, ref2.branch);
  }
  if (ref2.remote) {
    commands.splice(1, 0, ref2.remote);
  }
  remove(commands, "-v");
  append(commands, "--verbose");
  append(commands, "--porcelain");
  return {
    commands,
    format: "utf-8",
    parser: parsePushResult
  };
}
__name(pushTask, "pushTask");
var init_push = __esm2({
  "src/lib/tasks/push.ts"() {
    "use strict";
    init_parse_push();
    init_utils2();
  }
});
function show_default() {
  return {
    showBuffer() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      if (!commands.includes("--binary")) {
        commands.splice(1, 0, "--binary");
      }
      return this._runTask(
        straightThroughBufferTask(commands),
        trailingFunctionArgument(arguments)
      );
    },
    show() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      return this._runTask(
        straightThroughStringTask(commands),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
__name(show_default, "show_default");
var init_show = __esm2({
  "src/lib/tasks/show.ts"() {
    "use strict";
    init_utils2();
    init_task();
  }
});
var fromPathRegex;
var FileStatusSummary;
var init_FileStatusSummary = __esm2({
  "src/lib/responses/FileStatusSummary.ts"() {
    "use strict";
    fromPathRegex = /^(.+)\0(.+)$/;
    FileStatusSummary = class {
      static {
        __name(this, "FileStatusSummary");
      }
      constructor(path4, index, working_dir) {
        this.path = path4;
        this.index = index;
        this.working_dir = working_dir;
        if (index === "R" || working_dir === "R") {
          const detail = fromPathRegex.exec(path4) || [null, path4, path4];
          this.from = detail[2] || "";
          this.path = detail[1] || "";
        }
      }
    };
  }
});
function renamedFile(line) {
  const [to, from] = line.split(NULL);
  return {
    from: from || to,
    to
  };
}
__name(renamedFile, "renamedFile");
function parser3(indexX, indexY, handler) {
  return [`${indexX}${indexY}`, handler];
}
__name(parser3, "parser3");
function conflicts(indexX, ...indexY) {
  return indexY.map((y) => parser3(indexX, y, (result, file) => append(result.conflicted, file)));
}
__name(conflicts, "conflicts");
function splitLine(result, lineStr) {
  const trimmed2 = lineStr.trim();
  switch (" ") {
    case trimmed2.charAt(2):
      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.substr(3));
    case trimmed2.charAt(1):
      return data(" ", trimmed2.charAt(0), trimmed2.substr(2));
    default:
      return;
  }
  function data(index, workingDir, path4) {
    const raw = `${index}${workingDir}`;
    const handler = parsers6.get(raw);
    if (handler) {
      handler(result, path4);
    }
    if (raw !== "##" && raw !== "!!") {
      result.files.push(new FileStatusSummary(path4, index, workingDir));
    }
  }
  __name(data, "data");
}
__name(splitLine, "splitLine");
var StatusSummary;
var parsers6;
var parseStatusSummary;
var init_StatusSummary = __esm2({
  "src/lib/responses/StatusSummary.ts"() {
    "use strict";
    init_utils2();
    init_FileStatusSummary();
    StatusSummary = class {
      static {
        __name(this, "StatusSummary");
      }
      constructor() {
        this.not_added = [];
        this.conflicted = [];
        this.created = [];
        this.deleted = [];
        this.ignored = void 0;
        this.modified = [];
        this.renamed = [];
        this.files = [];
        this.staged = [];
        this.ahead = 0;
        this.behind = 0;
        this.current = null;
        this.tracking = null;
        this.detached = false;
        this.isClean = () => {
          return !this.files.length;
        };
      }
    };
    parsers6 = new Map([
      parser3(
        " ",
        "A",
        (result, file) => append(result.created, file)
      ),
      parser3(
        " ",
        "D",
        (result, file) => append(result.deleted, file)
      ),
      parser3(
        " ",
        "M",
        (result, file) => append(result.modified, file)
      ),
      parser3(
        "A",
        " ",
        (result, file) => append(result.created, file) && append(result.staged, file)
      ),
      parser3(
        "A",
        "M",
        (result, file) => append(result.created, file) && append(result.staged, file) && append(result.modified, file)
      ),
      parser3(
        "D",
        " ",
        (result, file) => append(result.deleted, file) && append(result.staged, file)
      ),
      parser3(
        "M",
        " ",
        (result, file) => append(result.modified, file) && append(result.staged, file)
      ),
      parser3(
        "M",
        "M",
        (result, file) => append(result.modified, file) && append(result.staged, file)
      ),
      parser3("R", " ", (result, file) => {
        append(result.renamed, renamedFile(file));
      }),
      parser3("R", "M", (result, file) => {
        const renamed = renamedFile(file);
        append(result.renamed, renamed);
        append(result.modified, renamed.to);
      }),
      parser3("!", "!", (_result, _file) => {
        append(_result.ignored = _result.ignored || [], _file);
      }),
      parser3(
        "?",
        "?",
        (result, file) => append(result.not_added, file)
      ),
      ...conflicts(
        "A",
        "A",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "D",
        "D",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "U",
        "A",
        "D",
        "U"
        /* UNMERGED */
      ),
      [
        "##",
        (result, line) => {
          const aheadReg = /ahead (\d+)/;
          const behindReg = /behind (\d+)/;
          const currentReg = /^(.+?(?=(?:\.{3}|\s|$)))/;
          const trackingReg = /\.{3}(\S*)/;
          const onEmptyBranchReg = /\son\s([\S]+)$/;
          let regexResult;
          regexResult = aheadReg.exec(line);
          result.ahead = regexResult && +regexResult[1] || 0;
          regexResult = behindReg.exec(line);
          result.behind = regexResult && +regexResult[1] || 0;
          regexResult = currentReg.exec(line);
          result.current = regexResult && regexResult[1];
          regexResult = trackingReg.exec(line);
          result.tracking = regexResult && regexResult[1];
          regexResult = onEmptyBranchReg.exec(line);
          result.current = regexResult && regexResult[1] || result.current;
          result.detached = /\(no branch\)/.test(line);
        }
      ]
    ]);
    parseStatusSummary = /* @__PURE__ */ __name(function(text) {
      const lines = text.split(NULL);
      const status = new StatusSummary();
      for (let i = 0, l = lines.length; i < l; ) {
        let line = lines[i++].trim();
        if (!line) {
          continue;
        }
        if (line.charAt(0) === "R") {
          line += NULL + (lines[i++] || "");
        }
        splitLine(status, line);
      }
      return status;
    }, "parseStatusSummary");
  }
});
function statusTask(customArgs) {
  const commands = [
    "status",
    "--porcelain",
    "-b",
    "-u",
    "--null",
    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))
  ];
  return {
    format: "utf-8",
    commands,
    parser(text) {
      return parseStatusSummary(text);
    }
  };
}
__name(statusTask, "statusTask");
var ignoredOptions;
var init_status = __esm2({
  "src/lib/tasks/status.ts"() {
    "use strict";
    init_StatusSummary();
    ignoredOptions = ["--null", "-z"];
  }
});
function versionResponse(major2 = 0, minor = 0, patch = 0, agent = "", installed = true) {
  return Object.defineProperty(
    {
      major: major2,
      minor,
      patch,
      agent,
      installed
    },
    "toString",
    {
      value() {
        return `${this.major}.${this.minor}.${this.patch}`;
      },
      configurable: false,
      enumerable: false
    }
  );
}
__name(versionResponse, "versionResponse");
function notInstalledResponse() {
  return versionResponse(0, 0, 0, "", false);
}
__name(notInstalledResponse, "notInstalledResponse");
function version_default() {
  return {
    version() {
      return this._runTask({
        commands: ["--version"],
        format: "utf-8",
        parser: versionParser,
        onError(result, error4, done, fail) {
          if (result.exitCode === -2) {
            return done(Buffer.from(NOT_INSTALLED));
          }
          fail(error4);
        }
      });
    }
  };
}
__name(version_default, "version_default");
function versionParser(stdOut) {
  if (stdOut === NOT_INSTALLED) {
    return notInstalledResponse();
  }
  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);
}
__name(versionParser, "versionParser");
var NOT_INSTALLED;
var parsers7;
var init_version = __esm2({
  "src/lib/tasks/version.ts"() {
    "use strict";
    init_utils2();
    NOT_INSTALLED = "installed=false";
    parsers7 = [
      new LineParser(
        /version (\d+)\.(\d+)\.(\d+)(?:\s*\((.+)\))?/,
        (result, [major2, minor, patch, agent = ""]) => {
          Object.assign(
            result,
            versionResponse(asNumber(major2), asNumber(minor), asNumber(patch), agent)
          );
        }
      ),
      new LineParser(
        /version (\d+)\.(\d+)\.(\D+)(.+)?$/,
        (result, [major2, minor, patch, agent = ""]) => {
          Object.assign(result, versionResponse(asNumber(major2), asNumber(minor), patch, agent));
        }
      )
    ];
  }
});
var simple_git_api_exports = {};
__export2(simple_git_api_exports, {
  SimpleGitApi: /* @__PURE__ */ __name(() => SimpleGitApi, "SimpleGitApi")
});
var SimpleGitApi;
var init_simple_git_api = __esm2({
  "src/lib/simple-git-api.ts"() {
    "use strict";
    init_task_callback();
    init_change_working_directory();
    init_checkout();
    init_count_objects();
    init_commit();
    init_config();
    init_first_commit();
    init_grep();
    init_hash_object();
    init_init();
    init_log();
    init_merge();
    init_push();
    init_show();
    init_status();
    init_task();
    init_version();
    init_utils2();
    SimpleGitApi = class {
      static {
        __name(this, "SimpleGitApi");
      }
      constructor(_executor) {
        this._executor = _executor;
      }
      _runTask(task, then) {
        const chain = this._executor.chain();
        const promise = chain.push(task);
        if (then) {
          taskCallback(task, promise, then);
        }
        return Object.create(this, {
          then: { value: promise.then.bind(promise) },
          catch: { value: promise.catch.bind(promise) },
          _executor: { value: chain }
        });
      }
      add(files) {
        return this._runTask(
          straightThroughStringTask(["add", ...asArray(files)]),
          trailingFunctionArgument(arguments)
        );
      }
      cwd(directory) {
        const next2 = trailingFunctionArgument(arguments);
        if (typeof directory === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next2);
        }
        if (typeof directory?.path === "string") {
          return this._runTask(
            changeWorkingDirectoryTask(
              directory.path,
              directory.root && this._executor || void 0
            ),
            next2
          );
        }
        return this._runTask(
          configurationErrorTask("Git.cwd: workingDirectory must be supplied as a string"),
          next2
        );
      }
      hashObject(path4, write2) {
        return this._runTask(
          hashObjectTask(path4, write2 === true),
          trailingFunctionArgument(arguments)
        );
      }
      init(bare) {
        return this._runTask(
          initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
      merge() {
        return this._runTask(
          mergeTask(getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
      mergeFromTo(remote, branch) {
        if (!(filterString(remote) && filterString(branch))) {
          return this._runTask(
            configurationErrorTask(
              `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`
            )
          );
        }
        return this._runTask(
          mergeTask([remote, branch, ...getTrailingOptions(arguments)]),
          trailingFunctionArgument(arguments, false)
        );
      }
      outputHandler(handler) {
        this._executor.outputHandler = handler;
        return this;
      }
      push() {
        const task = pushTask(
          {
            remote: filterType(arguments[0], filterString),
            branch: filterType(arguments[1], filterString)
          },
          getTrailingOptions(arguments)
        );
        return this._runTask(task, trailingFunctionArgument(arguments));
      }
      stash() {
        return this._runTask(
          straightThroughStringTask(["stash", ...getTrailingOptions(arguments)]),
          trailingFunctionArgument(arguments)
        );
      }
      status() {
        return this._runTask(
          statusTask(getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
    };
    Object.assign(
      SimpleGitApi.prototype,
      checkout_default(),
      commit_default(),
      config_default(),
      count_objects_default(),
      first_commit_default(),
      grep_default(),
      log_default(),
      show_default(),
      version_default()
    );
  }
});
var scheduler_exports = {};
__export2(scheduler_exports, {
  Scheduler: /* @__PURE__ */ __name(() => Scheduler, "Scheduler")
});
var createScheduledTask;
var Scheduler;
var init_scheduler = __esm2({
  "src/lib/runners/scheduler.ts"() {
    "use strict";
    init_utils2();
    init_git_logger();
    createScheduledTask = /* @__PURE__ */ (() => {
      let id = 0;
      return () => {
        id++;
        const { promise, done } = (0, import_promise_deferred.createDeferred)();
        return {
          promise,
          done,
          id
        };
      };
    })();
    Scheduler = class {
      static {
        __name(this, "Scheduler");
      }
      constructor(concurrency = 2) {
        this.concurrency = concurrency;
        this.logger = createLogger("", "scheduler");
        this.pending = [];
        this.running = [];
        this.logger(`Constructed, concurrency=%s`, concurrency);
      }
      schedule() {
        if (!this.pending.length || this.running.length >= this.concurrency) {
          this.logger(
            `Schedule attempt ignored, pending=%s running=%s concurrency=%s`,
            this.pending.length,
            this.running.length,
            this.concurrency
          );
          return;
        }
        const task = append(this.running, this.pending.shift());
        this.logger(`Attempting id=%s`, task.id);
        task.done(() => {
          this.logger(`Completing id=`, task.id);
          remove(this.running, task);
          this.schedule();
        });
      }
      next() {
        const { promise, id } = append(this.pending, createScheduledTask());
        this.logger(`Scheduling id=%s`, id);
        this.schedule();
        return promise;
      }
    };
  }
});
var apply_patch_exports = {};
__export2(apply_patch_exports, {
  applyPatchTask: /* @__PURE__ */ __name(() => applyPatchTask, "applyPatchTask")
});
function applyPatchTask(patches, customArgs) {
  return straightThroughStringTask(["apply", ...customArgs, ...patches]);
}
__name(applyPatchTask, "applyPatchTask");
var init_apply_patch = __esm2({
  "src/lib/tasks/apply-patch.ts"() {
    "use strict";
    init_task();
  }
});
function branchDeletionSuccess(branch, hash) {
  return {
    branch,
    hash,
    success: true
  };
}
__name(branchDeletionSuccess, "branchDeletionSuccess");
function branchDeletionFailure(branch) {
  return {
    branch,
    hash: null,
    success: false
  };
}
__name(branchDeletionFailure, "branchDeletionFailure");
var BranchDeletionBatch;
var init_BranchDeleteSummary = __esm2({
  "src/lib/responses/BranchDeleteSummary.ts"() {
    "use strict";
    BranchDeletionBatch = class {
      static {
        __name(this, "BranchDeletionBatch");
      }
      constructor() {
        this.all = [];
        this.branches = {};
        this.errors = [];
      }
      get success() {
        return !this.errors.length;
      }
    };
  }
});
function hasBranchDeletionError(data, processExitCode) {
  return processExitCode === 1 && deleteErrorRegex.test(data);
}
__name(hasBranchDeletionError, "hasBranchDeletionError");
var deleteSuccessRegex;
var deleteErrorRegex;
var parsers8;
var parseBranchDeletions;
var init_parse_branch_delete = __esm2({
  "src/lib/parsers/parse-branch-delete.ts"() {
    "use strict";
    init_BranchDeleteSummary();
    init_utils2();
    deleteSuccessRegex = /(\S+)\s+\(\S+\s([^)]+)\)/;
    deleteErrorRegex = /^error[^']+'([^']+)'/m;
    parsers8 = [
      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {
        const deletion = branchDeletionSuccess(branch, hash);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      }),
      new LineParser(deleteErrorRegex, (result, [branch]) => {
        const deletion = branchDeletionFailure(branch);
        result.errors.push(deletion);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      })
    ];
    parseBranchDeletions = /* @__PURE__ */ __name((stdOut, stdErr) => {
      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);
    }, "parseBranchDeletions");
  }
});
var BranchSummaryResult;
var init_BranchSummary = __esm2({
  "src/lib/responses/BranchSummary.ts"() {
    "use strict";
    BranchSummaryResult = class {
      static {
        __name(this, "BranchSummaryResult");
      }
      constructor() {
        this.all = [];
        this.branches = {};
        this.current = "";
        this.detached = false;
      }
      push(status, detached, name, commit, label) {
        if (status === "*") {
          this.detached = detached;
          this.current = name;
        }
        this.all.push(name);
        this.branches[name] = {
          current: status === "*",
          linkedWorkTree: status === "+",
          name,
          commit,
          label
        };
      }
    };
  }
});
function branchStatus(input) {
  return input ? input.charAt(0) : "";
}
__name(branchStatus, "branchStatus");
function parseBranchSummary(stdOut) {
  return parseStringResponse(new BranchSummaryResult(), parsers9, stdOut);
}
__name(parseBranchSummary, "parseBranchSummary");
var parsers9;
var init_parse_branch = __esm2({
  "src/lib/parsers/parse-branch.ts"() {
    "use strict";
    init_BranchSummary();
    init_utils2();
    parsers9 = [
      new LineParser(
        /^([*+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/,
        (result, [current, name, commit, label]) => {
          result.push(branchStatus(current), true, name, commit, label);
        }
      ),
      new LineParser(
        /^([*+]\s)?(\S+)\s+([a-z0-9]+)\s?(.*)$/s,
        (result, [current, name, commit, label]) => {
          result.push(branchStatus(current), false, name, commit, label);
        }
      )
    ];
  }
});
var branch_exports = {};
__export2(branch_exports, {
  branchLocalTask: /* @__PURE__ */ __name(() => branchLocalTask, "branchLocalTask"),
  branchTask: /* @__PURE__ */ __name(() => branchTask, "branchTask"),
  containsDeleteBranchCommand: /* @__PURE__ */ __name(() => containsDeleteBranchCommand, "containsDeleteBranchCommand"),
  deleteBranchTask: /* @__PURE__ */ __name(() => deleteBranchTask, "deleteBranchTask"),
  deleteBranchesTask: /* @__PURE__ */ __name(() => deleteBranchesTask, "deleteBranchesTask")
});
function containsDeleteBranchCommand(commands) {
  const deleteCommands = ["-d", "-D", "--delete"];
  return commands.some((command) => deleteCommands.includes(command));
}
__name(containsDeleteBranchCommand, "containsDeleteBranchCommand");
function branchTask(customArgs) {
  const isDelete = containsDeleteBranchCommand(customArgs);
  const commands = ["branch", ...customArgs];
  if (commands.length === 1) {
    commands.push("-a");
  }
  if (!commands.includes("-v")) {
    commands.splice(1, 0, "-v");
  }
  return {
    format: "utf-8",
    commands,
    parser(stdOut, stdErr) {
      if (isDelete) {
        return parseBranchDeletions(stdOut, stdErr).all[0];
      }
      return parseBranchSummary(stdOut);
    }
  };
}
__name(branchTask, "branchTask");
function branchLocalTask() {
  const parser4 = parseBranchSummary;
  return {
    format: "utf-8",
    commands: ["branch", "-v"],
    parser: parser4
  };
}
__name(branchLocalTask, "branchLocalTask");
function deleteBranchesTask(branches, forceDelete = false) {
  return {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", ...branches],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr);
    },
    onError({ exitCode: exitCode2, stdOut }, error4, done, fail) {
      if (!hasBranchDeletionError(String(error4), exitCode2)) {
        return fail(error4);
      }
      done(stdOut);
    }
  };
}
__name(deleteBranchesTask, "deleteBranchesTask");
function deleteBranchTask(branch, forceDelete = false) {
  const task = {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", branch],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr).branches[branch];
    },
    onError({ exitCode: exitCode2, stdErr, stdOut }, error4, _, fail) {
      if (!hasBranchDeletionError(String(error4), exitCode2)) {
        return fail(error4);
      }
      throw new GitResponseError(
        task.parser(bufferToString(stdOut), bufferToString(stdErr)),
        String(error4)
      );
    }
  };
  return task;
}
__name(deleteBranchTask, "deleteBranchTask");
var init_branch = __esm2({
  "src/lib/tasks/branch.ts"() {
    "use strict";
    init_git_response_error();
    init_parse_branch_delete();
    init_parse_branch();
    init_utils2();
  }
});
var parseCheckIgnore;
var init_CheckIgnore = __esm2({
  "src/lib/responses/CheckIgnore.ts"() {
    "use strict";
    parseCheckIgnore = /* @__PURE__ */ __name((text) => {
      return text.split(/\n/g).map((line) => line.trim()).filter((file) => !!file);
    }, "parseCheckIgnore");
  }
});
var check_ignore_exports = {};
__export2(check_ignore_exports, {
  checkIgnoreTask: /* @__PURE__ */ __name(() => checkIgnoreTask, "checkIgnoreTask")
});
function checkIgnoreTask(paths) {
  return {
    commands: ["check-ignore", ...paths],
    format: "utf-8",
    parser: parseCheckIgnore
  };
}
__name(checkIgnoreTask, "checkIgnoreTask");
var init_check_ignore = __esm2({
  "src/lib/tasks/check-ignore.ts"() {
    "use strict";
    init_CheckIgnore();
  }
});
var clone_exports = {};
__export2(clone_exports, {
  cloneMirrorTask: /* @__PURE__ */ __name(() => cloneMirrorTask, "cloneMirrorTask"),
  cloneTask: /* @__PURE__ */ __name(() => cloneTask, "cloneTask")
});
function disallowedCommand(command) {
  return /^--upload-pack(=|$)/.test(command);
}
__name(disallowedCommand, "disallowedCommand");
function cloneTask(repo, directory, customArgs) {
  const commands = ["clone", ...customArgs];
  filterString(repo) && commands.push(repo);
  filterString(directory) && commands.push(directory);
  const banned = commands.find(disallowedCommand);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return straightThroughStringTask(commands);
}
__name(cloneTask, "cloneTask");
function cloneMirrorTask(repo, directory, customArgs) {
  append(customArgs, "--mirror");
  return cloneTask(repo, directory, customArgs);
}
__name(cloneMirrorTask, "cloneMirrorTask");
var init_clone = __esm2({
  "src/lib/tasks/clone.ts"() {
    "use strict";
    init_task();
    init_utils2();
  }
});
function parseFetchResult(stdOut, stdErr) {
  const result = {
    raw: stdOut,
    remote: null,
    branches: [],
    tags: [],
    updated: [],
    deleted: []
  };
  return parseStringResponse(result, parsers10, [stdOut, stdErr]);
}
__name(parseFetchResult, "parseFetchResult");
var parsers10;
var init_parse_fetch = __esm2({
  "src/lib/parsers/parse-fetch.ts"() {
    "use strict";
    init_utils2();
    parsers10 = [
      new LineParser(/From (.+)$/, (result, [remote]) => {
        result.remote = remote;
      }),
      new LineParser(/\* \[new branch]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.branches.push({
          name,
          tracking
        });
      }),
      new LineParser(/\* \[new tag]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.tags.push({
          name,
          tracking
        });
      }),
      new LineParser(/- \[deleted]\s+\S+\s*-> (.+)$/, (result, [tracking]) => {
        result.deleted.push({
          tracking
        });
      }),
      new LineParser(
        /\s*([^.]+)\.\.(\S+)\s+(\S+)\s*-> (.+)$/,
        (result, [from, to, name, tracking]) => {
          result.updated.push({
            name,
            tracking,
            to,
            from
          });
        }
      )
    ];
  }
});
var fetch_exports = {};
__export2(fetch_exports, {
  fetchTask: /* @__PURE__ */ __name(() => fetchTask, "fetchTask")
});
function disallowedCommand2(command) {
  return /^--upload-pack(=|$)/.test(command);
}
__name(disallowedCommand2, "disallowedCommand2");
function fetchTask(remote, branch, customArgs) {
  const commands = ["fetch", ...customArgs];
  if (remote && branch) {
    commands.push(remote, branch);
  }
  const banned = commands.find(disallowedCommand2);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return {
    commands,
    format: "utf-8",
    parser: parseFetchResult
  };
}
__name(fetchTask, "fetchTask");
var init_fetch = __esm2({
  "src/lib/tasks/fetch.ts"() {
    "use strict";
    init_parse_fetch();
    init_task();
  }
});
function parseMoveResult(stdOut) {
  return parseStringResponse({ moves: [] }, parsers11, stdOut);
}
__name(parseMoveResult, "parseMoveResult");
var parsers11;
var init_parse_move = __esm2({
  "src/lib/parsers/parse-move.ts"() {
    "use strict";
    init_utils2();
    parsers11 = [
      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {
        result.moves.push({ from, to });
      })
    ];
  }
});
var move_exports = {};
__export2(move_exports, {
  moveTask: /* @__PURE__ */ __name(() => moveTask, "moveTask")
});
function moveTask(from, to) {
  return {
    commands: ["mv", "-v", ...asArray(from), to],
    format: "utf-8",
    parser: parseMoveResult
  };
}
__name(moveTask, "moveTask");
var init_move = __esm2({
  "src/lib/tasks/move.ts"() {
    "use strict";
    init_parse_move();
    init_utils2();
  }
});
var pull_exports = {};
__export2(pull_exports, {
  pullTask: /* @__PURE__ */ __name(() => pullTask, "pullTask")
});
function pullTask(remote, branch, customArgs) {
  const commands = ["pull", ...customArgs];
  if (remote && branch) {
    commands.splice(1, 0, remote, branch);
  }
  return {
    commands,
    format: "utf-8",
    parser(stdOut, stdErr) {
      return parsePullResult(stdOut, stdErr);
    },
    onError(result, _error, _done, fail) {
      const pullError = parsePullErrorResult(
        bufferToString(result.stdOut),
        bufferToString(result.stdErr)
      );
      if (pullError) {
        return fail(new GitResponseError(pullError));
      }
      fail(_error);
    }
  };
}
__name(pullTask, "pullTask");
var init_pull = __esm2({
  "src/lib/tasks/pull.ts"() {
    "use strict";
    init_git_response_error();
    init_parse_pull();
    init_utils2();
  }
});
function parseGetRemotes(text) {
  const remotes = {};
  forEach(text, ([name]) => remotes[name] = { name });
  return Object.values(remotes);
}
__name(parseGetRemotes, "parseGetRemotes");
function parseGetRemotesVerbose(text) {
  const remotes = {};
  forEach(text, ([name, url, purpose]) => {
    if (!remotes.hasOwnProperty(name)) {
      remotes[name] = {
        name,
        refs: { fetch: "", push: "" }
      };
    }
    if (purpose && url) {
      remotes[name].refs[purpose.replace(/[^a-z]/g, "")] = url;
    }
  });
  return Object.values(remotes);
}
__name(parseGetRemotesVerbose, "parseGetRemotesVerbose");
function forEach(text, handler) {
  forEachLineWithContent(text, (line) => handler(line.split(/\s+/)));
}
__name(forEach, "forEach");
var init_GetRemoteSummary = __esm2({
  "src/lib/responses/GetRemoteSummary.ts"() {
    "use strict";
    init_utils2();
  }
});
var remote_exports = {};
__export2(remote_exports, {
  addRemoteTask: /* @__PURE__ */ __name(() => addRemoteTask, "addRemoteTask"),
  getRemotesTask: /* @__PURE__ */ __name(() => getRemotesTask, "getRemotesTask"),
  listRemotesTask: /* @__PURE__ */ __name(() => listRemotesTask, "listRemotesTask"),
  remoteTask: /* @__PURE__ */ __name(() => remoteTask, "remoteTask"),
  removeRemoteTask: /* @__PURE__ */ __name(() => removeRemoteTask, "removeRemoteTask")
});
function addRemoteTask(remoteName, remoteRepo, customArgs) {
  return straightThroughStringTask(["remote", "add", ...customArgs, remoteName, remoteRepo]);
}
__name(addRemoteTask, "addRemoteTask");
function getRemotesTask(verbose) {
  const commands = ["remote"];
  if (verbose) {
    commands.push("-v");
  }
  return {
    commands,
    format: "utf-8",
    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes
  };
}
__name(getRemotesTask, "getRemotesTask");
function listRemotesTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "ls-remote") {
    commands.unshift("ls-remote");
  }
  return straightThroughStringTask(commands);
}
__name(listRemotesTask, "listRemotesTask");
function remoteTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "remote") {
    commands.unshift("remote");
  }
  return straightThroughStringTask(commands);
}
__name(remoteTask, "remoteTask");
function removeRemoteTask(remoteName) {
  return straightThroughStringTask(["remote", "remove", remoteName]);
}
__name(removeRemoteTask, "removeRemoteTask");
var init_remote = __esm2({
  "src/lib/tasks/remote.ts"() {
    "use strict";
    init_GetRemoteSummary();
    init_task();
  }
});
var stash_list_exports = {};
__export2(stash_list_exports, {
  stashListTask: /* @__PURE__ */ __name(() => stashListTask, "stashListTask")
});
function stashListTask(opt = {}, customArgs) {
  const options = parseLogOptions(opt);
  const commands = ["stash", "list", ...options.commands, ...customArgs];
  const parser4 = createListLogSummaryParser(
    options.splitter,
    options.fields,
    logFormatFromCommand(commands)
  );
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: parser4
  };
}
__name(stashListTask, "stashListTask");
var init_stash_list = __esm2({
  "src/lib/tasks/stash-list.ts"() {
    "use strict";
    init_log_format();
    init_parse_list_log_summary();
    init_diff();
    init_log();
  }
});
var sub_module_exports = {};
__export2(sub_module_exports, {
  addSubModuleTask: /* @__PURE__ */ __name(() => addSubModuleTask, "addSubModuleTask"),
  initSubModuleTask: /* @__PURE__ */ __name(() => initSubModuleTask, "initSubModuleTask"),
  subModuleTask: /* @__PURE__ */ __name(() => subModuleTask, "subModuleTask"),
  updateSubModuleTask: /* @__PURE__ */ __name(() => updateSubModuleTask, "updateSubModuleTask")
});
function addSubModuleTask(repo, path4) {
  return subModuleTask(["add", repo, path4]);
}
__name(addSubModuleTask, "addSubModuleTask");
function initSubModuleTask(customArgs) {
  return subModuleTask(["init", ...customArgs]);
}
__name(initSubModuleTask, "initSubModuleTask");
function subModuleTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "submodule") {
    commands.unshift("submodule");
  }
  return straightThroughStringTask(commands);
}
__name(subModuleTask, "subModuleTask");
function updateSubModuleTask(customArgs) {
  return subModuleTask(["update", ...customArgs]);
}
__name(updateSubModuleTask, "updateSubModuleTask");
var init_sub_module = __esm2({
  "src/lib/tasks/sub-module.ts"() {
    "use strict";
    init_task();
  }
});
function singleSorted(a, b) {
  const aIsNum = isNaN(a);
  const bIsNum = isNaN(b);
  if (aIsNum !== bIsNum) {
    return aIsNum ? 1 : -1;
  }
  return aIsNum ? sorted(a, b) : 0;
}
__name(singleSorted, "singleSorted");
function sorted(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
__name(sorted, "sorted");
function trimmed(input) {
  return input.trim();
}
__name(trimmed, "trimmed");
function toNumber(input) {
  if (typeof input === "string") {
    return parseInt(input.replace(/^\D+/g, ""), 10) || 0;
  }
  return 0;
}
__name(toNumber, "toNumber");
var TagList;
var parseTagList;
var init_TagList = __esm2({
  "src/lib/responses/TagList.ts"() {
    "use strict";
    TagList = class {
      static {
        __name(this, "TagList");
      }
      constructor(all, latest) {
        this.all = all;
        this.latest = latest;
      }
    };
    parseTagList = /* @__PURE__ */ __name(function(data, customSort = false) {
      const tags = data.split("\n").map(trimmed).filter(Boolean);
      if (!customSort) {
        tags.sort(function(tagA, tagB) {
          const partsA = tagA.split(".");
          const partsB = tagB.split(".");
          if (partsA.length === 1 || partsB.length === 1) {
            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));
          }
          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {
            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));
            if (diff) {
              return diff;
            }
          }
          return 0;
        });
      }
      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(".") >= 0);
      return new TagList(tags, latest);
    }, "parseTagList");
  }
});
var tag_exports = {};
__export2(tag_exports, {
  addAnnotatedTagTask: /* @__PURE__ */ __name(() => addAnnotatedTagTask, "addAnnotatedTagTask"),
  addTagTask: /* @__PURE__ */ __name(() => addTagTask, "addTagTask"),
  tagListTask: /* @__PURE__ */ __name(() => tagListTask, "tagListTask")
});
function tagListTask(customArgs = []) {
  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));
  return {
    format: "utf-8",
    commands: ["tag", "-l", ...customArgs],
    parser(text) {
      return parseTagList(text, hasCustomSort);
    }
  };
}
__name(tagListTask, "tagListTask");
function addTagTask(name) {
  return {
    format: "utf-8",
    commands: ["tag", name],
    parser() {
      return { name };
    }
  };
}
__name(addTagTask, "addTagTask");
function addAnnotatedTagTask(name, tagMessage) {
  return {
    format: "utf-8",
    commands: ["tag", "-a", "-m", tagMessage, name],
    parser() {
      return { name };
    }
  };
}
__name(addAnnotatedTagTask, "addAnnotatedTagTask");
var init_tag = __esm2({
  "src/lib/tasks/tag.ts"() {
    "use strict";
    init_TagList();
  }
});
var require_git = __commonJS2({
  "src/git.js"(exports, module) {
    "use strict";
    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS(git_executor_exports));
    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS(simple_git_api_exports));
    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS(scheduler_exports));
    var { configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS(task_exports));
    var {
      asArray: asArray2,
      filterArray: filterArray22,
      filterPrimitives: filterPrimitives2,
      filterString: filterString2,
      filterStringOrStringArray: filterStringOrStringArray2,
      filterType: filterType2,
      getTrailingOptions: getTrailingOptions2,
      trailingFunctionArgument: trailingFunctionArgument2,
      trailingOptionsArgument: trailingOptionsArgument2
    } = (init_utils2(), __toCommonJS(utils_exports));
    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS(apply_patch_exports));
    var {
      branchTask: branchTask2,
      branchLocalTask: branchLocalTask2,
      deleteBranchesTask: deleteBranchesTask2,
      deleteBranchTask: deleteBranchTask2
    } = (init_branch(), __toCommonJS(branch_exports));
    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS(check_ignore_exports));
    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS(check_is_repo_exports));
    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS(clone_exports));
    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS(clean_exports));
    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS(diff_exports));
    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS(fetch_exports));
    var { moveTask: moveTask2 } = (init_move(), __toCommonJS(move_exports));
    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS(pull_exports));
    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS(push_exports));
    var {
      addRemoteTask: addRemoteTask2,
      getRemotesTask: getRemotesTask2,
      listRemotesTask: listRemotesTask2,
      remoteTask: remoteTask2,
      removeRemoteTask: removeRemoteTask2
    } = (init_remote(), __toCommonJS(remote_exports));
    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS(reset_exports));
    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS(stash_list_exports));
    var {
      addSubModuleTask: addSubModuleTask2,
      initSubModuleTask: initSubModuleTask2,
      subModuleTask: subModuleTask2,
      updateSubModuleTask: updateSubModuleTask2
    } = (init_sub_module(), __toCommonJS(sub_module_exports));
    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS(tag_exports));
    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS(task_exports));
    function Git2(options, plugins) {
      this._plugins = plugins;
      this._executor = new GitExecutor2(
        options.baseDir,
        new Scheduler2(options.maxConcurrentProcesses),
        plugins
      );
      this._trimmed = options.trimmed;
    }
    __name(Git2, "Git2");
    (Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;
    Git2.prototype.customBinary = function(command) {
      this._plugins.reconfigure("binary", command);
      return this;
    };
    Git2.prototype.env = function(name, value) {
      if (arguments.length === 1 && typeof name === "object") {
        this._executor.env = name;
      } else {
        (this._executor.env = this._executor.env || {})[name] = value;
      }
      return this;
    };
    Git2.prototype.stashList = function(options) {
      return this._runTask(
        stashListTask2(
          trailingOptionsArgument2(arguments) || {},
          filterArray22(options) && options || []
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    function createCloneTask(api, task, repoPath, localPath) {
      if (typeof repoPath !== "string") {
        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);
      }
      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));
    }
    __name(createCloneTask, "createCloneTask");
    Git2.prototype.clone = function() {
      return this._runTask(
        createCloneTask("clone", cloneTask2, ...arguments),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.mirror = function() {
      return this._runTask(
        createCloneTask("mirror", cloneMirrorTask2, ...arguments),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.mv = function(from, to) {
      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.checkoutLatestTag = function(then) {
      var git = this;
      return this.pull(function() {
        git.tags(function(err, tags) {
          git.checkout(tags.latest, then);
        });
      });
    };
    Git2.prototype.pull = function(remote, branch, options, then) {
      return this._runTask(
        pullTask2(
          filterType2(remote, filterString2),
          filterType2(branch, filterString2),
          getTrailingOptions2(arguments)
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.fetch = function(remote, branch) {
      return this._runTask(
        fetchTask2(
          filterType2(remote, filterString2),
          filterType2(branch, filterString2),
          getTrailingOptions2(arguments)
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.silent = function(silence) {
      console.warn(
        "simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3"
      );
      return this;
    };
    Git2.prototype.tags = function(options, then) {
      return this._runTask(
        tagListTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.rebase = function() {
      return this._runTask(
        straightThroughStringTask2(["rebase", ...getTrailingOptions2(arguments)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.reset = function(mode) {
      return this._runTask(
        resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.revert = function(commit) {
      const next2 = trailingFunctionArgument2(arguments);
      if (typeof commit !== "string") {
        return this._runTask(configurationErrorTask2("Commit must be a string"), next2);
      }
      return this._runTask(
        straightThroughStringTask2(["revert", ...getTrailingOptions2(arguments, 0, true), commit]),
        next2
      );
    };
    Git2.prototype.addTag = function(name) {
      const task = typeof name === "string" ? addTagTask2(name) : configurationErrorTask2("Git.addTag requires a tag name");
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.addAnnotatedTag = function(tagName, tagMessage) {
      return this._runTask(
        addAnnotatedTagTask2(tagName, tagMessage),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {
      return this._runTask(
        deleteBranchTask2(branchName, typeof forceDelete === "boolean" ? forceDelete : false),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {
      return this._runTask(
        deleteBranchesTask2(branchNames, typeof forceDelete === "boolean" ? forceDelete : false),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.branch = function(options, then) {
      return this._runTask(
        branchTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.branchLocal = function(then) {
      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.raw = function(commands) {
      const createRestCommands = !Array.isArray(commands);
      const command = [].slice.call(createRestCommands ? arguments : commands, 0);
      for (let i = 0; i < command.length && createRestCommands; i++) {
        if (!filterPrimitives2(command[i])) {
          command.splice(i, command.length - i);
          break;
        }
      }
      command.push(...getTrailingOptions2(arguments, 0, true));
      var next2 = trailingFunctionArgument2(arguments);
      if (!command.length) {
        return this._runTask(
          configurationErrorTask2("Raw: must supply one or more command to execute"),
          next2
        );
      }
      return this._runTask(straightThroughStringTask2(command, this._trimmed), next2);
    };
    Git2.prototype.submoduleAdd = function(repo, path4, then) {
      return this._runTask(addSubModuleTask2(repo, path4), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.submoduleUpdate = function(args, then) {
      return this._runTask(
        updateSubModuleTask2(getTrailingOptions2(arguments, true)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.submoduleInit = function(args, then) {
      return this._runTask(
        initSubModuleTask2(getTrailingOptions2(arguments, true)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.subModule = function(options, then) {
      return this._runTask(
        subModuleTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.listRemote = function() {
      return this._runTask(
        listRemotesTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.addRemote = function(remoteName, remoteRepo, then) {
      return this._runTask(
        addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.removeRemote = function(remoteName, then) {
      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.getRemotes = function(verbose, then) {
      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.remote = function(options, then) {
      return this._runTask(
        remoteTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.tag = function(options, then) {
      const command = getTrailingOptions2(arguments);
      if (command[0] !== "tag") {
        command.unshift("tag");
      }
      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.updateServerInfo = function(then) {
      return this._runTask(
        straightThroughStringTask2(["update-server-info"]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.pushTags = function(remote, then) {
      const task = pushTagsTask2(
        { remote: filterType2(remote, filterString2) },
        getTrailingOptions2(arguments)
      );
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.rm = function(files) {
      return this._runTask(
        straightThroughStringTask2(["rm", "-f", ...asArray2(files)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.rmKeepLocal = function(files) {
      return this._runTask(
        straightThroughStringTask2(["rm", "--cached", ...asArray2(files)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.catFile = function(options, then) {
      return this._catFile("utf-8", arguments);
    };
    Git2.prototype.binaryCatFile = function() {
      return this._catFile("buffer", arguments);
    };
    Git2.prototype._catFile = function(format, args) {
      var handler = trailingFunctionArgument2(args);
      var command = ["cat-file"];
      var options = args[0];
      if (typeof options === "string") {
        return this._runTask(
          configurationErrorTask2("Git.catFile: options must be supplied as an array of strings"),
          handler
        );
      }
      if (Array.isArray(options)) {
        command.push.apply(command, options);
      }
      const task = format === "buffer" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);
      return this._runTask(task, handler);
    };
    Git2.prototype.diff = function(options, then) {
      const task = filterString2(options) ? configurationErrorTask2(
        "git.diff: supplying options as a single string is no longer supported, switch to an array of strings"
      ) : straightThroughStringTask2(["diff", ...getTrailingOptions2(arguments)]);
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.diffSummary = function() {
      return this._runTask(
        diffSummaryTask2(getTrailingOptions2(arguments, 1)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.applyPatch = function(patches) {
      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(
        `git.applyPatch requires one or more string patches as the first argument`
      ) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.revparse = function() {
      const commands = ["rev-parse", ...getTrailingOptions2(arguments, true)];
      return this._runTask(
        straightThroughStringTask2(commands, true),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.clean = function(mode, options, then) {
      const usingCleanOptionsArray = isCleanOptionsArray2(mode);
      const cleanMode = usingCleanOptionsArray && mode.join("") || filterType2(mode, filterString2) || "";
      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));
      return this._runTask(
        cleanWithOptionsTask2(cleanMode, customArgs),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.exec = function(then) {
      const task = {
        commands: [],
        format: "utf-8",
        parser() {
          if (typeof then === "function") {
            then();
          }
        }
      };
      return this._runTask(task);
    };
    Git2.prototype.clearQueue = function() {
      return this;
    };
    Git2.prototype.checkIgnore = function(pathnames, then) {
      return this._runTask(
        checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.checkIsRepo = function(checkType, then) {
      return this._runTask(
        checkIsRepoTask2(filterType2(checkType, filterString2)),
        trailingFunctionArgument2(arguments)
      );
    };
    module.exports = Git2;
  }
});
init_pathspec();
init_git_error();
var GitConstructError = class extends GitError {
  static {
    __name(this, "GitConstructError");
  }
  constructor(config2, message) {
    super(void 0, message);
    this.config = config2;
  }
};
init_git_error();
init_git_error();
var GitPluginError = class extends GitError {
  static {
    __name(this, "GitPluginError");
  }
  constructor(task, plugin, message) {
    super(task, message);
    this.task = task;
    this.plugin = plugin;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
init_git_response_error();
init_task_configuration_error();
init_check_is_repo();
init_clean();
init_config();
init_diff_name_status();
init_grep();
init_reset();
function abortPlugin(signal) {
  if (!signal) {
    return;
  }
  const onSpawnAfter = {
    type: "spawn.after",
    action(_data, context3) {
      function kill2() {
        context3.kill(new GitPluginError(void 0, "abort", "Abort signal received"));
      }
      __name(kill2, "kill");
      signal.addEventListener("abort", kill2);
      context3.spawned.on("close", () => signal.removeEventListener("abort", kill2));
    }
  };
  const onSpawnBefore = {
    type: "spawn.before",
    action(_data, context3) {
      if (signal.aborted) {
        context3.kill(new GitPluginError(void 0, "abort", "Abort already signaled"));
      }
    }
  };
  return [onSpawnBefore, onSpawnAfter];
}
__name(abortPlugin, "abortPlugin");
function isConfigSwitch(arg) {
  return typeof arg === "string" && arg.trim().toLowerCase() === "-c";
}
__name(isConfigSwitch, "isConfigSwitch");
function preventProtocolOverride(arg, next2) {
  if (!isConfigSwitch(arg)) {
    return;
  }
  if (!/^\s*protocol(.[a-z]+)?.allow/.test(next2)) {
    return;
  }
  throw new GitPluginError(
    void 0,
    "unsafe",
    "Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol"
  );
}
__name(preventProtocolOverride, "preventProtocolOverride");
function preventUploadPack(arg, method) {
  if (/^\s*--(upload|receive)-pack/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`
    );
  }
  if (method === "clone" && /^\s*-u\b/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of clone with option -u is not permitted without enabling allowUnsafePack`
    );
  }
  if (method === "push" && /^\s*--exec\b/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of push with option --exec is not permitted without enabling allowUnsafePack`
    );
  }
}
__name(preventUploadPack, "preventUploadPack");
function blockUnsafeOperationsPlugin({
  allowUnsafeProtocolOverride = false,
  allowUnsafePack = false
} = {}) {
  return {
    type: "spawn.args",
    action(args, context3) {
      args.forEach((current, index) => {
        const next2 = index < args.length ? args[index + 1] : "";
        allowUnsafeProtocolOverride || preventProtocolOverride(current, next2);
        allowUnsafePack || preventUploadPack(current, context3.method);
      });
      return args;
    }
  };
}
__name(blockUnsafeOperationsPlugin, "blockUnsafeOperationsPlugin");
init_utils2();
function commandConfigPrefixingPlugin(configuration) {
  const prefix = prefixedArray(configuration, "-c");
  return {
    type: "spawn.args",
    action(data) {
      return [...prefix, ...data];
    }
  };
}
__name(commandConfigPrefixingPlugin, "commandConfigPrefixingPlugin");
init_utils2();
var never = (0, import_promise_deferred2.deferred)().promise;
function completionDetectionPlugin({
  onClose = true,
  onExit = 50
} = {}) {
  function createEvents() {
    let exitCode2 = -1;
    const events = {
      close: (0, import_promise_deferred2.deferred)(),
      closeTimeout: (0, import_promise_deferred2.deferred)(),
      exit: (0, import_promise_deferred2.deferred)(),
      exitTimeout: (0, import_promise_deferred2.deferred)()
    };
    const result = Promise.race([
      onClose === false ? never : events.closeTimeout.promise,
      onExit === false ? never : events.exitTimeout.promise
    ]);
    configureTimeout(onClose, events.close, events.closeTimeout);
    configureTimeout(onExit, events.exit, events.exitTimeout);
    return {
      close(code) {
        exitCode2 = code;
        events.close.done();
      },
      exit(code) {
        exitCode2 = code;
        events.exit.done();
      },
      get exitCode() {
        return exitCode2;
      },
      result
    };
  }
  __name(createEvents, "createEvents");
  function configureTimeout(flag, event, timeout) {
    if (flag === false) {
      return;
    }
    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);
  }
  __name(configureTimeout, "configureTimeout");
  return {
    type: "spawn.after",
    async action(_data, { spawned, close: close2 }) {
      const events = createEvents();
      let deferClose = true;
      let quickClose = /* @__PURE__ */ __name(() => void (deferClose = false), "quickClose");
      spawned.stdout?.on("data", quickClose);
      spawned.stderr?.on("data", quickClose);
      spawned.on("error", quickClose);
      spawned.on("close", (code) => events.close(code));
      spawned.on("exit", (code) => events.exit(code));
      try {
        await events.result;
        if (deferClose) {
          await delay(50);
        }
        close2(events.exitCode);
      } catch (err) {
        close2(events.exitCode, err);
      }
    }
  };
}
__name(completionDetectionPlugin, "completionDetectionPlugin");
init_utils2();
var WRONG_NUMBER_ERR = `Invalid value supplied for custom binary, requires a single string or an array containing either one or two strings`;
var WRONG_CHARS_ERR = `Invalid value supplied for custom binary, restricted characters must be removed or supply the unsafe.allowUnsafeCustomBinary option`;
function isBadArgument(arg) {
  return !arg || !/^([a-z]:)?([a-z0-9/.\\_-]+)$/i.test(arg);
}
__name(isBadArgument, "isBadArgument");
function toBinaryConfig(input, allowUnsafe) {
  if (input.length < 1 || input.length > 2) {
    throw new GitPluginError(void 0, "binary", WRONG_NUMBER_ERR);
  }
  const isBad = input.some(isBadArgument);
  if (isBad) {
    if (allowUnsafe) {
      console.warn(WRONG_CHARS_ERR);
    } else {
      throw new GitPluginError(void 0, "binary", WRONG_CHARS_ERR);
    }
  }
  const [binary, prefix] = input;
  return {
    binary,
    prefix
  };
}
__name(toBinaryConfig, "toBinaryConfig");
function customBinaryPlugin(plugins, input = ["git"], allowUnsafe = false) {
  let config2 = toBinaryConfig(asArray(input), allowUnsafe);
  plugins.on("binary", (input2) => {
    config2 = toBinaryConfig(asArray(input2), allowUnsafe);
  });
  plugins.append("spawn.binary", () => {
    return config2.binary;
  });
  plugins.append("spawn.args", (data) => {
    return config2.prefix ? [config2.prefix, ...data] : data;
  });
}
__name(customBinaryPlugin, "customBinaryPlugin");
init_git_error();
function isTaskError(result) {
  return !!(result.exitCode && result.stdErr.length);
}
__name(isTaskError, "isTaskError");
function getErrorMessage(result) {
  return Buffer.concat([...result.stdOut, ...result.stdErr]);
}
__name(getErrorMessage, "getErrorMessage");
function errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {
  return (error4, result) => {
    if (!overwrite && error4 || !isError(result)) {
      return error4;
    }
    return errorMessage(result);
  };
}
__name(errorDetectionHandler, "errorDetectionHandler");
function errorDetectionPlugin(config2) {
  return {
    type: "task.error",
    action(data, context3) {
      const error4 = config2(data.error, {
        stdErr: context3.stdErr,
        stdOut: context3.stdOut,
        exitCode: context3.exitCode
      });
      if (Buffer.isBuffer(error4)) {
        return { error: new GitError(void 0, error4.toString("utf-8")) };
      }
      return {
        error: error4
      };
    }
  };
}
__name(errorDetectionPlugin, "errorDetectionPlugin");
init_utils2();
var PluginStore = class {
  static {
    __name(this, "PluginStore");
  }
  constructor() {
    this.plugins = /* @__PURE__ */ new Set();
    this.events = new EventEmitter2();
  }
  on(type, listener) {
    this.events.on(type, listener);
  }
  reconfigure(type, data) {
    this.events.emit(type, data);
  }
  append(type, action) {
    const plugin = append(this.plugins, { type, action });
    return () => this.plugins.delete(plugin);
  }
  add(plugin) {
    const plugins = [];
    asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append(plugins, plugin2)));
    return () => {
      plugins.forEach((plugin2) => this.plugins.delete(plugin2));
    };
  }
  exec(type, data, context3) {
    let output = data;
    const contextual = Object.freeze(Object.create(context3));
    for (const plugin of this.plugins) {
      if (plugin.type === type) {
        output = plugin.action(output, contextual);
      }
    }
    return output;
  }
};
init_utils2();
function progressMonitorPlugin(progress) {
  const progressCommand = "--progress";
  const progressMethods = ["checkout", "clone", "fetch", "pull", "push"];
  const onProgress = {
    type: "spawn.after",
    action(_data, context3) {
      if (!context3.commands.includes(progressCommand)) {
        return;
      }
      context3.spawned.stderr?.on("data", (chunk) => {
        const message = /^([\s\S]+?):\s*(\d+)% \((\d+)\/(\d+)\)/.exec(chunk.toString("utf8"));
        if (!message) {
          return;
        }
        progress({
          method: context3.method,
          stage: progressEventStage(message[1]),
          progress: asNumber(message[2]),
          processed: asNumber(message[3]),
          total: asNumber(message[4])
        });
      });
    }
  };
  const onArgs = {
    type: "spawn.args",
    action(args, context3) {
      if (!progressMethods.includes(context3.method)) {
        return args;
      }
      return including(args, progressCommand);
    }
  };
  return [onArgs, onProgress];
}
__name(progressMonitorPlugin, "progressMonitorPlugin");
function progressEventStage(input) {
  return String(input.toLowerCase().split(" ", 1)) || "unknown";
}
__name(progressEventStage, "progressEventStage");
init_utils2();
function spawnOptionsPlugin(spawnOptions) {
  const options = pick(spawnOptions, ["uid", "gid"]);
  return {
    type: "spawn.options",
    action(data) {
      return { ...options, ...data };
    }
  };
}
__name(spawnOptionsPlugin, "spawnOptionsPlugin");
function timeoutPlugin({
  block,
  stdErr = true,
  stdOut = true
}) {
  if (block > 0) {
    return {
      type: "spawn.after",
      action(_data, context3) {
        let timeout;
        function wait() {
          timeout && clearTimeout(timeout);
          timeout = setTimeout(kill2, block);
        }
        __name(wait, "wait");
        function stop() {
          context3.spawned.stdout?.off("data", wait);
          context3.spawned.stderr?.off("data", wait);
          context3.spawned.off("exit", stop);
          context3.spawned.off("close", stop);
          timeout && clearTimeout(timeout);
        }
        __name(stop, "stop");
        function kill2() {
          stop();
          context3.kill(new GitPluginError(void 0, "timeout", `block timeout reached`));
        }
        __name(kill2, "kill");
        stdOut && context3.spawned.stdout?.on("data", wait);
        stdErr && context3.spawned.stderr?.on("data", wait);
        context3.spawned.on("exit", stop);
        context3.spawned.on("close", stop);
        wait();
      }
    };
  }
}
__name(timeoutPlugin, "timeoutPlugin");
init_pathspec();
function suffixPathsPlugin() {
  return {
    type: "spawn.args",
    action(data) {
      const prefix = [];
      let suffix;
      function append2(args) {
        (suffix = suffix || []).push(...args);
      }
      __name(append2, "append2");
      for (let i = 0; i < data.length; i++) {
        const param = data[i];
        if (isPathSpec(param)) {
          append2(toPaths(param));
          continue;
        }
        if (param === "--") {
          append2(
            data.slice(i + 1).flatMap((item) => isPathSpec(item) && toPaths(item) || item)
          );
          break;
        }
        prefix.push(param);
      }
      return !suffix ? prefix : [...prefix, "--", ...suffix.map(String)];
    }
  };
}
__name(suffixPathsPlugin, "suffixPathsPlugin");
init_utils2();
var Git = require_git();
function gitInstanceFactory(baseDir, options) {
  const plugins = new PluginStore();
  const config2 = createInstanceConfig(
    baseDir && (typeof baseDir === "string" ? { baseDir } : baseDir) || {},
    options
  );
  if (!folderExists(config2.baseDir)) {
    throw new GitConstructError(
      config2,
      `Cannot use simple-git on a directory that does not exist`
    );
  }
  if (Array.isArray(config2.config)) {
    plugins.add(commandConfigPrefixingPlugin(config2.config));
  }
  plugins.add(blockUnsafeOperationsPlugin(config2.unsafe));
  plugins.add(suffixPathsPlugin());
  plugins.add(completionDetectionPlugin(config2.completion));
  config2.abort && plugins.add(abortPlugin(config2.abort));
  config2.progress && plugins.add(progressMonitorPlugin(config2.progress));
  config2.timeout && plugins.add(timeoutPlugin(config2.timeout));
  config2.spawnOptions && plugins.add(spawnOptionsPlugin(config2.spawnOptions));
  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));
  config2.errors && plugins.add(errorDetectionPlugin(config2.errors));
  customBinaryPlugin(plugins, config2.binary, config2.unsafe?.allowUnsafeCustomBinary);
  return new Git(config2, plugins);
}
__name(gitInstanceFactory, "gitInstanceFactory");
init_git_response_error();
var simpleGit = gitInstanceFactory;

// node_modules/braintrust/dist/index.mjs
var import_chalk = __toESM(require_source(), 1);
var import_pluralize = __toESM(require_pluralize(), 1);
var cliProgress = __toESM(require_cli_progress(), 1);
import { promisify } from "util";
import * as zlib from "zlib";
var import_slugify = __toESM(require_slugify(), 1);
import path2 from "path";
var __defProp3 = Object.defineProperty;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames3 = Object.getOwnPropertyNames;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __require2 = /* @__PURE__ */ ((x) => typeof __require !== "undefined" ? __require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: /* @__PURE__ */ __name((a, b) => (typeof __require !== "undefined" ? __require : a)[b], "get")
}) : x)(function(x) {
  if (typeof __require !== "undefined") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm3 = /* @__PURE__ */ __name((fn, res) => /* @__PURE__ */ __name(function __init() {
  return fn && (res = (0, fn[__getOwnPropNames3(fn)[0]])(fn = 0)), res;
}, "__init"), "__esm");
var __export3 = /* @__PURE__ */ __name((target, all) => {
  for (var name in all)
    __defProp3(target, name, { get: all[name], enumerable: true });
}, "__export");
var __copyProps3 = /* @__PURE__ */ __name((to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames3(from))
      if (!__hasOwnProp3.call(to, key) && key !== except)
        __defProp3(to, key, { get: /* @__PURE__ */ __name(() => from[key], "get"), enumerable: !(desc = __getOwnPropDesc3(from, key)) || desc.enumerable });
  }
  return to;
}, "__copyProps");
var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps3(__defProp3({}, "__esModule", { value: true }), mod), "__toCommonJS");
var DefaultAsyncLocalStorage;
var iso;
var isomorph_default;
var init_isomorph = __esm3({
  "src/isomorph.ts"() {
    "use strict";
    DefaultAsyncLocalStorage = class {
      static {
        __name(this, "DefaultAsyncLocalStorage");
      }
      constructor() {
      }
      enterWith(_) {
      }
      run(_, callback) {
        return callback();
      }
      getStore() {
        return void 0;
      }
    };
    iso = {
      getRepoInfo: /* @__PURE__ */ __name(async (_settings) => void 0, "getRepoInfo"),
      getPastNAncestors: /* @__PURE__ */ __name(async () => [], "getPastNAncestors"),
      getEnv: /* @__PURE__ */ __name((_name) => void 0, "getEnv"),
      getCallerLocation: /* @__PURE__ */ __name(() => void 0, "getCallerLocation"),
      newAsyncLocalStorage: /* @__PURE__ */ __name(() => new DefaultAsyncLocalStorage(), "newAsyncLocalStorage"),
      processOn: /* @__PURE__ */ __name((_0, _1) => {
      }, "processOn")
    };
    isomorph_default = iso;
  }
});
var DEFAULT_QUEUE_SIZE;
var Queue;
var init_queue = __esm3({
  "src/queue.ts"() {
    "use strict";
    DEFAULT_QUEUE_SIZE = 15e3;
    Queue = class {
      static {
        __name(this, "Queue");
      }
      items = [];
      maxSize;
      enforceSizeLimit = false;
      constructor(maxSize) {
        if (maxSize < 1) {
          console.warn(
            `maxSize ${maxSize} is <1, using default ${DEFAULT_QUEUE_SIZE}`
          );
          maxSize = DEFAULT_QUEUE_SIZE;
        }
        this.maxSize = maxSize;
      }
      /**
       * Set queue size limit enforcement. When enabled, the queue will drop new items
       * when it reaches maxSize. When disabled (default), the queue can grow unlimited.
       */
      enforceQueueSizeLimit(enforce) {
        this.enforceSizeLimit = enforce;
      }
      push(...items) {
        const dropped = [];
        for (const item of items) {
          if (!this.enforceSizeLimit) {
            this.items.push(item);
          } else {
            if (this.items.length >= this.maxSize) {
              dropped.push(item);
            } else {
              this.items.push(item);
            }
          }
        }
        return dropped;
      }
      peek() {
        return this.items[0];
      }
      drain() {
        const items = [...this.items];
        this.items = [];
        return items;
      }
      clear() {
        this.items = [];
      }
      length() {
        return this.items.length;
      }
      get capacity() {
        return this.maxSize;
      }
    };
  }
});
function generateHexId(bytes) {
  let result = "";
  for (let i = 0; i < bytes; i++) {
    result += Math.floor(Math.random() * 256).toString(16).padStart(2, "0");
  }
  return result;
}
__name(generateHexId, "generateHexId");
function getIdGenerator() {
  const useOtel = typeof process !== "undefined" && process.env?.BRAINTRUST_OTEL_COMPAT?.toLowerCase() === "true";
  return useOtel ? new OTELIDGenerator() : new UUIDGenerator();
}
__name(getIdGenerator, "getIdGenerator");
var IDGenerator;
var UUIDGenerator;
var OTELIDGenerator;
var init_id_gen = __esm3({
  "src/id-gen.ts"() {
    "use strict";
    IDGenerator = class {
      static {
        __name(this, "IDGenerator");
      }
    };
    UUIDGenerator = class extends IDGenerator {
      static {
        __name(this, "UUIDGenerator");
      }
      getSpanId() {
        return v4_default();
      }
      getTraceId() {
        return v4_default();
      }
      shareRootSpanId() {
        return true;
      }
    };
    OTELIDGenerator = class extends IDGenerator {
      static {
        __name(this, "OTELIDGenerator");
      }
      getSpanId() {
        return generateHexId(8);
      }
      getTraceId() {
        return generateHexId(16);
      }
      shareRootSpanId() {
        return false;
      }
    };
  }
});
var TRANSACTION_ID_FIELD;
var IS_MERGE_FIELD;
var AUDIT_SOURCE_FIELD;
var AUDIT_METADATA_FIELD;
var VALID_SOURCES;
var PARENT_ID_FIELD;
var init_db_fields = __esm3({
  "util/db_fields.ts"() {
    "use strict";
    TRANSACTION_ID_FIELD = "_xact_id";
    IS_MERGE_FIELD = "_is_merge";
    AUDIT_SOURCE_FIELD = "_audit_source";
    AUDIT_METADATA_FIELD = "_audit_metadata";
    VALID_SOURCES = ["app", "api", "external"];
    PARENT_ID_FIELD = "_parent_id";
  }
});
function tryMakeUuid(s) {
  try {
    const ret = parse_default(s);
    if (ret.length !== 16) {
      throw new Error();
    }
    return { bytes: Buffer.from(ret), isUUID: true };
  } catch (e) {
    return { bytes: Buffer.from(s, "utf-8"), isUUID: false };
  }
}
__name(tryMakeUuid, "tryMakeUuid");
var ENCODING_VERSION_NUMBER;
var INVALID_ENCODING_ERRMSG;
var SpanObjectTypeV1;
var SpanObjectTypeV1EnumSchema;
var SpanRowIdsV1;
var SpanComponentsV1;
var init_span_identifier_v1 = __esm3({
  "util/span_identifier_v1.ts"() {
    "use strict";
    ENCODING_VERSION_NUMBER = 1;
    INVALID_ENCODING_ERRMSG = "SpanComponents string is not properly encoded. This may be due to a version mismatch between the SDK library used to export the span and the library used to decode it. Please make sure you are using the same SDK version across the board";
    SpanObjectTypeV1 = /* @__PURE__ */ ((SpanObjectTypeV12) => {
      SpanObjectTypeV12[SpanObjectTypeV12["EXPERIMENT"] = 1] = "EXPERIMENT";
      SpanObjectTypeV12[SpanObjectTypeV12["PROJECT_LOGS"] = 2] = "PROJECT_LOGS";
      return SpanObjectTypeV12;
    })(SpanObjectTypeV1 || {});
    SpanObjectTypeV1EnumSchema = external_exports.nativeEnum(SpanObjectTypeV1);
    SpanRowIdsV1 = class {
      static {
        __name(this, "SpanRowIdsV1");
      }
      rowId;
      spanId;
      rootSpanId;
      constructor(args) {
        this.rowId = args.rowId;
        this.spanId = args.spanId;
        this.rootSpanId = args.rootSpanId;
        if (!this.rowId) {
          throw new Error("rowId must be nonempty string");
        }
        if (!this.spanId) {
          throw new Error("spanId must be nonempty string");
        }
        if (!this.rootSpanId) {
          throw new Error("rootSpanId must be nonempty string");
        }
      }
      toObject() {
        return {
          rowId: this.rowId,
          spanId: this.spanId,
          rootSpanId: this.rootSpanId
        };
      }
    };
    SpanComponentsV1 = class _SpanComponentsV1 {
      static {
        __name(this, "_SpanComponentsV1");
      }
      objectType;
      objectId;
      rowIds;
      constructor(args) {
        this.objectType = args.objectType;
        this.objectId = args.objectId;
        this.rowIds = args.rowIds;
      }
      toStr() {
        const allBuffers = [];
        const { bytes: rowIdBytes, isUUID: rowIdIsUUID } = this.rowIds ? tryMakeUuid(this.rowIds.rowId) : { bytes: Buffer.from(""), isUUID: false };
        allBuffers.push(
          Buffer.from([
            ENCODING_VERSION_NUMBER,
            this.objectType,
            this.rowIds ? 1 : 0,
            rowIdIsUUID ? 1 : 0
          ])
        );
        const { bytes: objectIdBytes, isUUID: objectIdIsUUID } = tryMakeUuid(
          this.objectId
        );
        if (!objectIdIsUUID) {
          throw new Error("object_id component must be a valid UUID");
        }
        allBuffers.push(objectIdBytes);
        if (this.rowIds) {
          const { bytes: spanIdBytes, isUUID: spanIdIsUUID } = tryMakeUuid(
            this.rowIds.spanId
          );
          if (!spanIdIsUUID) {
            throw new Error("span_id component must be a valid UUID");
          }
          const { bytes: rootSpanIdBytes, isUUID: rootSpanIdIsUUID } = tryMakeUuid(
            this.rowIds.rootSpanId
          );
          if (!rootSpanIdIsUUID) {
            throw new Error("root_span_id component must be a valid UUID");
          }
          allBuffers.push(spanIdBytes, rootSpanIdBytes, rowIdBytes);
        }
        return Buffer.concat(allBuffers).toString("base64");
      }
      static fromStr(s) {
        try {
          const rawBytes = Buffer.from(s, "base64");
          if (rawBytes[0] !== ENCODING_VERSION_NUMBER) {
            throw new Error();
          }
          const objectType2 = SpanObjectTypeV1EnumSchema.parse(rawBytes[1]);
          if (![0, 1].includes(rawBytes[2])) {
            throw new Error();
          }
          if (![0, 1].includes(rawBytes[3])) {
            throw new Error();
          }
          const hasRowId = rawBytes[2] == 1;
          const rowIdIsUUID = rawBytes[3] == 1;
          const objectId = stringify_default(rawBytes.subarray(4, 20));
          const rowIds = (() => {
            if (!hasRowId) {
              return void 0;
            }
            const spanId = stringify_default(rawBytes.subarray(20, 36));
            const rootSpanId = stringify_default(rawBytes.subarray(36, 52));
            const rowId = rowIdIsUUID ? stringify_default(rawBytes.subarray(52)) : rawBytes.subarray(52).toString("utf-8");
            return new SpanRowIdsV1({ rowId, spanId, rootSpanId });
          })();
          return new _SpanComponentsV1({ objectType: objectType2, objectId, rowIds });
        } catch (e) {
          throw new Error(INVALID_ENCODING_ERRMSG);
        }
      }
      objectIdFields() {
        switch (this.objectType) {
          case 1:
            return { experiment_id: this.objectId };
          case 2:
            return { project_id: this.objectId, log_id: "g" };
          default:
            throw new Error("Impossible");
        }
      }
      toObject() {
        return {
          objectType: this.objectType,
          objectId: this.objectId,
          rowIds: this.rowIds?.toObject()
        };
      }
    };
  }
});
function tryMakeUuid2(s) {
  try {
    const ret = parse_default(s);
    if (ret.length !== 16) {
      throw new Error();
    }
    return { bytes: Buffer.from(ret), isUUID: true };
  } catch (e) {
    return { bytes: Buffer.from(s, "utf-8"), isUUID: false };
  }
}
__name(tryMakeUuid2, "tryMakeUuid2");
var ENCODING_VERSION_NUMBER2;
var INVALID_ENCODING_ERRMSG2;
var INTEGER_ENCODING_NUM_BYTES;
var SpanObjectTypeV2;
var SpanObjectTypeV2EnumSchema;
var SpanRowIdsV2;
var SpanComponentsV2;
var init_span_identifier_v2 = __esm3({
  "util/span_identifier_v2.ts"() {
    "use strict";
    init_span_identifier_v1();
    ENCODING_VERSION_NUMBER2 = 2;
    INVALID_ENCODING_ERRMSG2 = `SpanComponents string is not properly encoded. This library only supports encoding versions up to ${ENCODING_VERSION_NUMBER2}. Please make sure the SDK library used to decode the SpanComponents is at least as new as any library used to encode it.`;
    INTEGER_ENCODING_NUM_BYTES = 4;
    SpanObjectTypeV2 = /* @__PURE__ */ ((SpanObjectTypeV22) => {
      SpanObjectTypeV22[SpanObjectTypeV22["EXPERIMENT"] = 1] = "EXPERIMENT";
      SpanObjectTypeV22[SpanObjectTypeV22["PROJECT_LOGS"] = 2] = "PROJECT_LOGS";
      return SpanObjectTypeV22;
    })(SpanObjectTypeV2 || {});
    SpanObjectTypeV2EnumSchema = external_exports.nativeEnum(SpanObjectTypeV2);
    SpanRowIdsV2 = class {
      static {
        __name(this, "SpanRowIdsV2");
      }
      rowId;
      spanId;
      rootSpanId;
      constructor(args) {
        this.rowId = args.rowId;
        this.spanId = args.spanId;
        this.rootSpanId = args.rootSpanId;
        if (!this.rowId) {
          throw new Error("rowId must be nonempty string");
        }
        if (!this.spanId) {
          throw new Error("spanId must be nonempty string");
        }
        if (!this.rootSpanId) {
          throw new Error("rootSpanId must be nonempty string");
        }
      }
      toObject() {
        return {
          rowId: this.rowId,
          spanId: this.spanId,
          rootSpanId: this.rootSpanId
        };
      }
    };
    SpanComponentsV2 = class _SpanComponentsV2 {
      static {
        __name(this, "_SpanComponentsV2");
      }
      objectType;
      objectId;
      computeObjectMetadataArgs;
      rowIds;
      constructor(args) {
        this.objectType = args.objectType;
        this.objectId = args.objectId;
        this.computeObjectMetadataArgs = args.computeObjectMetadataArgs;
        this.rowIds = args.rowIds;
        if (!(this.objectId || this.computeObjectMetadataArgs)) {
          throw new Error(
            "Must provide either objectId or computeObjectMetadataArgs"
          );
        }
      }
      toStr() {
        const allBuffers = [];
        const { bytes: rowIdBytes, isUUID: rowIdIsUUID } = this.rowIds ? tryMakeUuid2(this.rowIds.rowId) : { bytes: Buffer.from(""), isUUID: false };
        allBuffers.push(
          Buffer.from([
            ENCODING_VERSION_NUMBER2,
            this.objectType,
            this.objectId ? 1 : 0,
            this.computeObjectMetadataArgs ? 1 : 0,
            this.rowIds ? 1 : 0,
            rowIdIsUUID ? 1 : 0
          ])
        );
        if (this.objectId) {
          const { bytes: objectIdBytes, isUUID: objectIdIsUUID } = tryMakeUuid2(
            this.objectId
          );
          if (!objectIdIsUUID) {
            throw new Error("object_id component must be a valid UUID");
          }
          allBuffers.push(objectIdBytes);
        }
        if (this.computeObjectMetadataArgs) {
          const computeObjectMetadataBytes = Buffer.from(
            JSON.stringify(this.computeObjectMetadataArgs),
            "utf-8"
          );
          const serializedLenBytes = Buffer.alloc(INTEGER_ENCODING_NUM_BYTES);
          serializedLenBytes.writeInt32BE(computeObjectMetadataBytes.length);
          allBuffers.push(serializedLenBytes, computeObjectMetadataBytes);
        }
        if (this.rowIds) {
          const { bytes: spanIdBytes, isUUID: spanIdIsUUID } = tryMakeUuid2(
            this.rowIds.spanId
          );
          if (!spanIdIsUUID) {
            throw new Error("span_id component must be a valid UUID");
          }
          const { bytes: rootSpanIdBytes, isUUID: rootSpanIdIsUUID } = tryMakeUuid2(
            this.rowIds.rootSpanId
          );
          if (!rootSpanIdIsUUID) {
            throw new Error("root_span_id component must be a valid UUID");
          }
          allBuffers.push(spanIdBytes, rootSpanIdBytes, rowIdBytes);
        }
        return Buffer.concat(allBuffers).toString("base64");
      }
      static fromStr(s) {
        try {
          const rawBytes = Buffer.from(s, "base64");
          if (rawBytes[0] < ENCODING_VERSION_NUMBER2) {
            const spanComponentsOld = SpanComponentsV1.fromStr(s);
            return new _SpanComponentsV2({
              objectType: SpanObjectTypeV2EnumSchema.parse(
                spanComponentsOld.objectType
              ),
              objectId: spanComponentsOld.objectId,
              rowIds: spanComponentsOld.rowIds ? new SpanRowIdsV2({
                rowId: spanComponentsOld.rowIds.rowId,
                spanId: spanComponentsOld.rowIds.spanId,
                rootSpanId: spanComponentsOld.rowIds.rootSpanId
              }) : void 0
            });
          }
          if (rawBytes[0] !== ENCODING_VERSION_NUMBER2) {
            throw new Error();
          }
          const objectType2 = SpanObjectTypeV2EnumSchema.parse(rawBytes[1]);
          for (let i = 2; i < 6; ++i) {
            if (![0, 1].includes(rawBytes[i])) {
              throw new Error();
            }
          }
          const hasObjectId = rawBytes[2] == 1;
          const hasComputeObjectMetadataArgs = rawBytes[3] == 1;
          const hasRowId = rawBytes[4] == 1;
          const rowIdIsUUID = rawBytes[5] == 1;
          let byteCursor = 6;
          let objectId = void 0;
          if (hasObjectId) {
            const nextByteCursor = byteCursor + 16;
            objectId = stringify_default(
              rawBytes.subarray(byteCursor, nextByteCursor)
            );
            byteCursor = nextByteCursor;
          }
          let computeObjectMetadataArgs;
          if (hasComputeObjectMetadataArgs) {
            let nextByteCursor = byteCursor + INTEGER_ENCODING_NUM_BYTES;
            const serializedLenBytes = rawBytes.readInt32BE(byteCursor);
            byteCursor = nextByteCursor;
            nextByteCursor = byteCursor + serializedLenBytes;
            computeObjectMetadataArgs = JSON.parse(
              rawBytes.subarray(byteCursor, nextByteCursor).toString("utf-8")
            );
            byteCursor = nextByteCursor;
          }
          const rowIds = (() => {
            if (!hasRowId) {
              return void 0;
            }
            let nextByteCursor = byteCursor + 16;
            const spanId = stringify_default(
              rawBytes.subarray(byteCursor, nextByteCursor)
            );
            byteCursor = nextByteCursor;
            nextByteCursor = byteCursor + 16;
            const rootSpanId = stringify_default(
              rawBytes.subarray(byteCursor, nextByteCursor)
            );
            byteCursor = nextByteCursor;
            const rowId = rowIdIsUUID ? stringify_default(rawBytes.subarray(byteCursor)) : rawBytes.subarray(byteCursor).toString("utf-8");
            return new SpanRowIdsV2({ rowId, spanId, rootSpanId });
          })();
          return new _SpanComponentsV2({
            objectType: objectType2,
            objectId,
            computeObjectMetadataArgs,
            rowIds
          });
        } catch (e) {
          throw new Error(INVALID_ENCODING_ERRMSG2);
        }
      }
      objectIdFields() {
        if (!this.objectId) {
          throw new Error(
            "Impossible: cannot invoke `object_id_fields` unless SpanComponentsV2 is initialized with an `object_id`"
          );
        }
        switch (this.objectType) {
          case 1:
            return { experiment_id: this.objectId };
          case 2:
            return { project_id: this.objectId, log_id: "g" };
          default:
            throw new Error("Impossible");
        }
      }
      toObject() {
        return {
          objectType: this.objectType,
          objectId: this.objectId,
          computeObjectMetadataArgs: this.computeObjectMetadataArgs,
          rowIds: this.rowIds?.toObject()
        };
      }
    };
  }
});
function concatUint8Arrays(...arrays) {
  const totalLength = arrays.reduce((acc, arr) => acc + arr.length, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const arr of arrays) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
__name(concatUint8Arrays, "concatUint8Arrays");
function uint8ArrayToBase64(uint8Array) {
  let binary = "";
  for (let i = 0; i < uint8Array.length; i++) {
    binary += String.fromCharCode(uint8Array[i]);
  }
  return btoa(binary);
}
__name(uint8ArrayToBase64, "uint8ArrayToBase64");
function base64ToUint8Array(base64) {
  const binary = atob(base64);
  const uint8Array = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    uint8Array[i] = binary.charCodeAt(i);
  }
  return uint8Array;
}
__name(base64ToUint8Array, "base64ToUint8Array");
function uint8ArrayToString(uint8Array) {
  const decoder = new TextDecoder("utf-8");
  return decoder.decode(uint8Array);
}
__name(uint8ArrayToString, "uint8ArrayToString");
function stringToUint8Array(str2) {
  const encoder = new TextEncoder();
  return encoder.encode(str2);
}
__name(stringToUint8Array, "stringToUint8Array");
var init_bytes = __esm3({
  "util/bytes.ts"() {
    "use strict";
  }
});
function tryMakeUuid3(s) {
  try {
    const ret = parse_default(s);
    if (ret.length !== 16) {
      throw new Error();
    }
    return { bytes: new Uint8Array(ret), isUUID: true };
  } catch {
    return { bytes: void 0, isUUID: false };
  }
}
__name(tryMakeUuid3, "tryMakeUuid3");
function spanObjectTypeV3ToString(objectType2) {
  switch (objectType2) {
    case 1:
      return "experiment";
    case 2:
      return "project_logs";
    case 3:
      return "playground_logs";
    default:
      const x = objectType2;
      throw new Error(`Unknown SpanObjectTypeV3: ${x}`);
  }
}
__name(spanObjectTypeV3ToString, "spanObjectTypeV3ToString");
var ENCODING_VERSION_NUMBER3;
var INVALID_ENCODING_ERRMSG3;
var SpanObjectTypeV3;
var spanObjectTypeV3EnumSchema;
var InternalSpanComponentUUIDFields;
var internalSpanComponentUUIDFieldsEnumSchema;
var _INTERNAL_SPAN_COMPONENT_UUID_FIELDS_ID_TO_NAME;
var spanComponentsV3Schema;
var SpanComponentsV3;
var init_span_identifier_v3 = __esm3({
  "util/span_identifier_v3.ts"() {
    "use strict";
    init_span_identifier_v2();
    init_bytes();
    ENCODING_VERSION_NUMBER3 = 3;
    INVALID_ENCODING_ERRMSG3 = `SpanComponents string is not properly encoded. This library only supports encoding versions up to ${ENCODING_VERSION_NUMBER3}. Please make sure the SDK library used to decode the SpanComponents is at least as new as any library used to encode it.`;
    SpanObjectTypeV3 = /* @__PURE__ */ ((SpanObjectTypeV32) => {
      SpanObjectTypeV32[SpanObjectTypeV32["EXPERIMENT"] = 1] = "EXPERIMENT";
      SpanObjectTypeV32[SpanObjectTypeV32["PROJECT_LOGS"] = 2] = "PROJECT_LOGS";
      SpanObjectTypeV32[SpanObjectTypeV32["PLAYGROUND_LOGS"] = 3] = "PLAYGROUND_LOGS";
      return SpanObjectTypeV32;
    })(SpanObjectTypeV3 || {});
    spanObjectTypeV3EnumSchema = external_exports.nativeEnum(SpanObjectTypeV3);
    InternalSpanComponentUUIDFields = /* @__PURE__ */ ((InternalSpanComponentUUIDFields2) => {
      InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["OBJECT_ID"] = 1] = "OBJECT_ID";
      InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["ROW_ID"] = 2] = "ROW_ID";
      InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["SPAN_ID"] = 3] = "SPAN_ID";
      InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["ROOT_SPAN_ID"] = 4] = "ROOT_SPAN_ID";
      return InternalSpanComponentUUIDFields2;
    })(InternalSpanComponentUUIDFields || {});
    internalSpanComponentUUIDFieldsEnumSchema = external_exports.nativeEnum(
      InternalSpanComponentUUIDFields
    );
    _INTERNAL_SPAN_COMPONENT_UUID_FIELDS_ID_TO_NAME = {
      [
        1
        /* OBJECT_ID */
      ]: "object_id",
      [
        2
        /* ROW_ID */
      ]: "row_id",
      [
        3
        /* SPAN_ID */
      ]: "span_id",
      [
        4
        /* ROOT_SPAN_ID */
      ]: "root_span_id"
    };
    spanComponentsV3Schema = external_exports.object({
      object_type: spanObjectTypeV3EnumSchema,
      // TODO(manu): We should have a more elaborate zod schema for
      // `propagated_event`. This will required zod-ifying the contents of
      // sdk/js/util/object.ts.
      propagated_event: external_exports.record(external_exports.unknown()).nullish()
    }).and(
      external_exports.union([
        // Must provide one or the other.
        external_exports.object({
          object_id: external_exports.string().nullish(),
          compute_object_metadata_args: external_exports.optional(external_exports.null())
        }),
        external_exports.object({
          object_id: external_exports.optional(external_exports.null()),
          compute_object_metadata_args: external_exports.record(external_exports.unknown())
        })
      ])
    ).and(
      external_exports.union([
        // Either all of these must be provided or none.
        external_exports.object({
          row_id: external_exports.string(),
          span_id: external_exports.string(),
          root_span_id: external_exports.string()
        }),
        external_exports.object({
          row_id: external_exports.optional(external_exports.null()),
          span_id: external_exports.optional(external_exports.null()),
          root_span_id: external_exports.optional(external_exports.null())
        })
      ])
    );
    SpanComponentsV3 = class _SpanComponentsV3 {
      static {
        __name(this, "_SpanComponentsV3");
      }
      constructor(data) {
        this.data = data;
      }
      toStr() {
        const jsonObj = {
          compute_object_metadata_args: this.data.compute_object_metadata_args || void 0,
          propagated_event: this.data.propagated_event || void 0
        };
        const allBuffers = [];
        allBuffers.push(
          new Uint8Array([ENCODING_VERSION_NUMBER3, this.data.object_type])
        );
        const uuidEntries = [];
        function addUuidField(origVal, fieldId) {
          const ret = tryMakeUuid3(origVal);
          if (ret.isUUID) {
            uuidEntries.push(
              concatUint8Arrays(new Uint8Array([fieldId]), ret.bytes)
            );
          } else {
            jsonObj[_INTERNAL_SPAN_COMPONENT_UUID_FIELDS_ID_TO_NAME[fieldId]] = origVal;
          }
        }
        __name(addUuidField, "addUuidField");
        if (this.data.object_id) {
          addUuidField(
            this.data.object_id,
            1
            /* OBJECT_ID */
          );
        }
        if (this.data.row_id) {
          addUuidField(
            this.data.row_id,
            2
            /* ROW_ID */
          );
        }
        if (this.data.span_id) {
          addUuidField(
            this.data.span_id,
            3
            /* SPAN_ID */
          );
        }
        if (this.data.root_span_id) {
          addUuidField(
            this.data.root_span_id,
            4
            /* ROOT_SPAN_ID */
          );
        }
        if (uuidEntries.length > 255) {
          throw new Error("Impossible: too many UUID entries to encode");
        }
        allBuffers.push(new Uint8Array([uuidEntries.length]));
        allBuffers.push(...uuidEntries);
        if (Object.keys(jsonObj).length > 0) {
          allBuffers.push(stringToUint8Array(JSON.stringify(jsonObj)));
        }
        return uint8ArrayToBase64(concatUint8Arrays(...allBuffers));
      }
      static fromStr(s) {
        try {
          const rawBytes = base64ToUint8Array(s);
          const jsonObj = {};
          if (rawBytes[0] < ENCODING_VERSION_NUMBER3) {
            const spanComponentsOld = SpanComponentsV2.fromStr(s);
            jsonObj["object_type"] = spanComponentsOld.objectType;
            jsonObj["object_id"] = spanComponentsOld.objectId;
            jsonObj["compute_object_metadata_args"] = spanComponentsOld.computeObjectMetadataArgs;
            if (spanComponentsOld.rowIds) {
              jsonObj["row_id"] = spanComponentsOld.rowIds.rowId;
              jsonObj["span_id"] = spanComponentsOld.rowIds.spanId;
              jsonObj["root_span_id"] = spanComponentsOld.rowIds.rootSpanId;
            }
          } else {
            jsonObj["object_type"] = rawBytes[1];
            const numUuidEntries = rawBytes[2];
            let byteOffset = 3;
            for (let i = 0; i < numUuidEntries; ++i) {
              const fieldId = internalSpanComponentUUIDFieldsEnumSchema.parse(
                rawBytes[byteOffset]
              );
              const fieldBytes = rawBytes.subarray(byteOffset + 1, byteOffset + 17);
              byteOffset += 17;
              jsonObj[_INTERNAL_SPAN_COMPONENT_UUID_FIELDS_ID_TO_NAME[fieldId]] = stringify_default(fieldBytes);
            }
            if (byteOffset < rawBytes.length) {
              const remainingJsonObj = JSON.parse(
                uint8ArrayToString(rawBytes.subarray(byteOffset))
              );
              Object.assign(jsonObj, remainingJsonObj);
            }
          }
          return _SpanComponentsV3.fromJsonObj(jsonObj);
        } catch {
          throw new Error(INVALID_ENCODING_ERRMSG3);
        }
      }
      objectIdFields() {
        if (!this.data.object_id) {
          throw new Error(
            "Impossible: cannot invoke `objectIdFields` unless SpanComponentsV3 is initialized with an `object_id`"
          );
        }
        switch (this.data.object_type) {
          case 1:
            return { experiment_id: this.data.object_id };
          case 2:
            return { project_id: this.data.object_id, log_id: "g" };
          case 3:
            return { prompt_session_id: this.data.object_id, log_id: "x" };
          default:
            const _ = this.data.object_type;
            throw new Error("Impossible");
        }
      }
      async export() {
        return this.toStr();
      }
      static fromJsonObj(jsonObj) {
        return new _SpanComponentsV3(spanComponentsV3Schema.parse(jsonObj));
      }
    };
  }
});
var init_http_headers = __esm3({
  "util/http_headers.ts"() {
    "use strict";
    init_span_identifier_v3();
  }
});
function isObject(value) {
  return value instanceof Object && !(value instanceof Array);
}
__name(isObject, "isObject");
function isArray2(value) {
  return value instanceof Array;
}
__name(isArray2, "isArray");
function isObjectOrArray(value) {
  return value instanceof Object;
}
__name(isObjectOrArray, "isObjectOrArray");
var init_type_util = __esm3({
  "util/type_util.ts"() {
    "use strict";
  }
});
function mergeDictsWithPaths({
  mergeInto,
  mergeFrom,
  mergePaths
}) {
  const mergePathsSerialized = new Set(
    mergePaths.map((p) => JSON.stringify(p))
  );
  return mergeDictsWithPathsHelper({
    mergeInto,
    mergeFrom,
    path: [],
    mergePaths: mergePathsSerialized
  });
}
__name(mergeDictsWithPaths, "mergeDictsWithPaths");
function mergeDictsWithPathsHelper({
  mergeInto,
  mergeFrom,
  path: path32,
  mergePaths
}) {
  Object.entries(mergeFrom).forEach(([k, mergeFromV]) => {
    const fullPath = path32.concat([k]);
    const fullPathSerialized = JSON.stringify(fullPath);
    const mergeIntoV = recordFind(mergeInto, k);
    if (isObject(mergeIntoV) && isObject(mergeFromV) && !mergePaths.has(fullPathSerialized)) {
      mergeDictsWithPathsHelper({
        mergeInto: mergeIntoV,
        mergeFrom: mergeFromV,
        path: fullPath,
        mergePaths
      });
    } else {
      mergeInto[k] = mergeFromV;
    }
  });
  return mergeInto;
}
__name(mergeDictsWithPathsHelper, "mergeDictsWithPathsHelper");
function mergeDicts(mergeInto, mergeFrom) {
  return mergeDictsWithPaths({ mergeInto, mergeFrom, mergePaths: [] });
}
__name(mergeDicts, "mergeDicts");
function mapAt(m, k) {
  const ret = m.get(k);
  if (ret === void 0) {
    throw new Error(`Map does not contain key ${k}`);
  }
  return ret;
}
__name(mapAt, "mapAt");
function recordFind(m, k) {
  return m[k];
}
__name(recordFind, "recordFind");
function getObjValueByPath(row, path32) {
  let curr = row;
  for (const p of path32) {
    if (!isObjectOrArray(curr)) {
      return null;
    }
    curr = curr[p];
  }
  return curr;
}
__name(getObjValueByPath, "getObjValueByPath");
var init_object_util = __esm3({
  "util/object_util.ts"() {
    "use strict";
    init_type_util();
  }
});
function depthFirstSearch(args) {
  const { graph, firstVisitF, lastVisitF } = args;
  for (const vs of graph.values()) {
    for (const v of vs.values()) {
      if (!graph.has(v)) {
        throw new Error(`Outgoing vertex ${v} must be a key in the graph`);
      }
    }
  }
  const firstVisitedVertices = /* @__PURE__ */ new Set();
  const visitationOrder = args.visitationOrder ?? [...graph.keys()];
  const events = visitationOrder.map((vertex) => ({ eventType: "first", vertex, extras: {} })).reverse();
  while (events.length) {
    const { eventType, vertex, extras } = events.pop();
    if (eventType === "last") {
      lastVisitF?.(vertex);
      continue;
    }
    if (firstVisitedVertices.has(vertex)) {
      continue;
    }
    firstVisitedVertices.add(vertex);
    firstVisitF?.(vertex, { parentVertex: extras.parentVertex });
    events.push({ eventType: "last", vertex, extras: {} });
    mapAt(graph, vertex).forEach((child) => {
      events.push({
        eventType: "first",
        vertex: child,
        extras: { parentVertex: vertex }
      });
    });
  }
}
__name(depthFirstSearch, "depthFirstSearch");
function undirectedConnectedComponents(graph) {
  const directedGraph = new Map(
    [...graph.vertices].map((v) => [v, /* @__PURE__ */ new Set()])
  );
  for (const [i, j] of graph.edges) {
    mapAt(directedGraph, i).add(j);
    mapAt(directedGraph, j).add(i);
  }
  let labelCounter = 0;
  const vertexLabels = /* @__PURE__ */ new Map();
  const firstVisitF = /* @__PURE__ */ __name((vertex, args) => {
    const label = args?.parentVertex !== void 0 ? mapAt(vertexLabels, args?.parentVertex) : labelCounter++;
    vertexLabels.set(vertex, label);
  }, "firstVisitF");
  depthFirstSearch({ graph: directedGraph, firstVisitF });
  const output = Array.from({ length: labelCounter }).map(() => []);
  for (const [vertex, label] of vertexLabels.entries()) {
    output[label].push(vertex);
  }
  return output;
}
__name(undirectedConnectedComponents, "undirectedConnectedComponents");
function topologicalSort(graph, visitationOrder) {
  const reverseOrdering = [];
  const lastVisitF = /* @__PURE__ */ __name((vertex) => {
    reverseOrdering.push(vertex);
  }, "lastVisitF");
  depthFirstSearch({ graph, lastVisitF, visitationOrder });
  return reverseOrdering.reverse();
}
__name(topologicalSort, "topologicalSort");
var init_graph_util = __esm3({
  "util/graph_util.ts"() {
    "use strict";
    init_object_util();
  }
});
function generateMergedRowKey(row, useParentIdForId) {
  return JSON.stringify(
    [
      "org_id",
      "project_id",
      "experiment_id",
      "dataset_id",
      "prompt_session_id",
      "log_id",
      useParentIdForId ?? false ? PARENT_ID_FIELD : "id"
    ].map((k) => row[k])
  );
}
__name(generateMergedRowKey, "generateMergedRowKey");
function popMergeRowSkipFields(row) {
  const popped = {};
  for (const field of MERGE_ROW_SKIP_FIELDS) {
    if (field in row) {
      popped[field] = row[field];
      delete row[field];
    }
  }
  return popped;
}
__name(popMergeRowSkipFields, "popMergeRowSkipFields");
function restoreMergeRowSkipFields(row, skipFields) {
  for (const field of MERGE_ROW_SKIP_FIELDS) {
    delete row[field];
    if (field in skipFields) {
      row[field] = skipFields[field];
    }
  }
}
__name(restoreMergeRowSkipFields, "restoreMergeRowSkipFields");
function mergeRowBatch(rows) {
  for (const row of rows) {
    if (row.id === void 0) {
      throw new Error(
        "Logged row is missing an id. This is an internal braintrust error. Please contact us at info@braintrust.dev for help"
      );
    }
  }
  const rowGroups = /* @__PURE__ */ new Map();
  for (const row of rows) {
    const key = generateMergedRowKey(row);
    const existingRow = rowGroups.get(key);
    if (existingRow !== void 0 && row[IS_MERGE_FIELD]) {
      const skipFields = popMergeRowSkipFields(existingRow);
      const preserveNoMerge = !existingRow[IS_MERGE_FIELD];
      mergeDicts(existingRow, row);
      restoreMergeRowSkipFields(existingRow, skipFields);
      if (preserveNoMerge) {
        delete existingRow[IS_MERGE_FIELD];
      }
    } else {
      rowGroups.set(key, row);
    }
  }
  const merged = [...rowGroups.values()];
  const rowToLabel = new Map(
    merged.map((r, i) => [generateMergedRowKey(r), i])
  );
  const graph = new Map(
    Array.from({ length: merged.length }).map((_, i) => [i, /* @__PURE__ */ new Set()])
  );
  merged.forEach((r, i) => {
    const parentId = r[PARENT_ID_FIELD];
    if (!parentId) {
      return;
    }
    const parentRowKey = generateMergedRowKey(
      r,
      true
      /* useParentIdForId */
    );
    const parentLabel = rowToLabel.get(parentRowKey);
    if (parentLabel !== void 0) {
      mapAt(graph, parentLabel).add(i);
    }
  });
  const connectedComponents = undirectedConnectedComponents({
    vertices: new Set(graph.keys()),
    edges: new Set(
      [...graph.entries()].flatMap(
        ([k, vs]) => [...vs].map((v) => {
          const ret = [k, v];
          return ret;
        })
      )
    )
  });
  const buckets = connectedComponents.map(
    (cc) => topologicalSort(
      graph,
      cc
      /* visitationOrder */
    )
  );
  return buckets.map((bucket) => bucket.map((i) => merged[i]));
}
__name(mergeRowBatch, "mergeRowBatch");
function batchItems(args) {
  let { items } = args;
  const batchMaxNumItems = args.batchMaxNumItems ?? Number.POSITIVE_INFINITY;
  const batchMaxNumBytes = args.batchMaxNumBytes ?? Number.POSITIVE_INFINITY;
  const output = [];
  let nextItems = [];
  let batchSet = [];
  let batch = [];
  let batchLen = 0;
  function addToBatch(item) {
    batch.push(item);
    batchLen += item.length;
  }
  __name(addToBatch, "addToBatch");
  function flushBatch() {
    batchSet.push(batch);
    batch = [];
    batchLen = 0;
  }
  __name(flushBatch, "flushBatch");
  while (items.length) {
    for (const bucket of items) {
      let i = 0;
      for (const item of bucket) {
        if (batch.length === 0 || item.length + batchLen < batchMaxNumBytes && batch.length < batchMaxNumItems) {
          addToBatch(item);
        } else if (i === 0) {
          flushBatch();
          addToBatch(item);
        } else {
          break;
        }
        ++i;
      }
      if (i < bucket.length) {
        nextItems.push(bucket.slice(i));
      }
      if (batchLen >= batchMaxNumBytes || batch.length > batchMaxNumItems) {
        flushBatch();
      }
    }
    if (batch.length) {
      flushBatch();
    }
    if (batchSet.length) {
      output.push(batchSet);
      batchSet = [];
    }
    items = nextItems;
    nextItems = [];
  }
  return output;
}
__name(batchItems, "batchItems");
var MERGE_ROW_SKIP_FIELDS;
var init_merge_row_batch = __esm3({
  "util/merge_row_batch.ts"() {
    "use strict";
    init_db_fields();
    init_object_util();
    init_graph_util();
    MERGE_ROW_SKIP_FIELDS = [
      "created",
      "span_id",
      "root_span_id",
      "span_parents",
      "_parent_id"
      // TODO: handle merge paths.
    ];
  }
});
function ensureDatasetRecord(r, legacy) {
  if (legacy) {
    return ensureLegacyDatasetRecord(r);
  } else {
    return ensureNewDatasetRecord(r);
  }
}
__name(ensureDatasetRecord, "ensureDatasetRecord");
function ensureLegacyDatasetRecord(r) {
  if ("output" in r) {
    return r;
  }
  const row = {
    ...r,
    output: r.expected
  };
  delete row.expected;
  return row;
}
__name(ensureLegacyDatasetRecord, "ensureLegacyDatasetRecord");
function ensureNewDatasetRecord(r) {
  if ("expected" in r) {
    return r;
  }
  const row = {
    ...r,
    tags: null,
    expected: r.output
  };
  delete row.output;
  return row;
}
__name(ensureNewDatasetRecord, "ensureNewDatasetRecord");
var DEFAULT_IS_LEGACY_DATASET;
var init_object = __esm3({
  "util/object.ts"() {
    "use strict";
    DEFAULT_IS_LEGACY_DATASET = false;
  }
});
var init_score = __esm3({
  "util/score.ts"() {
    "use strict";
  }
});
function constructJsonArray(items) {
  return `[${items.join(",")}]`;
}
__name(constructJsonArray, "constructJsonArray");
var init_json_util = __esm3({
  "util/json_util.ts"() {
    "use strict";
  }
});
function _urljoin(...parts) {
  return parts.map(
    (x, i) => x.replace(/^\//, "").replace(i < parts.length - 1 ? /\/$/ : "", "")
  ).filter((x) => x.trim() !== "").join("/");
}
__name(_urljoin, "_urljoin");
var init_string_util = __esm3({
  "util/string_util.ts"() {
    "use strict";
  }
});
function tryMakeHexTraceId(s) {
  try {
    if (typeof s === "string" && s.length === 32) {
      const bytes = new Uint8Array(16);
      for (let i = 0; i < 16; i++) {
        const hex = s.substr(i * 2, 2);
        const byte = parseInt(hex, 16);
        if (isNaN(byte)) throw new Error();
        bytes[i] = byte;
      }
      return { bytes, isHex: true };
    }
  } catch {
  }
  return { bytes: void 0, isHex: false };
}
__name(tryMakeHexTraceId, "tryMakeHexTraceId");
function tryMakeHexSpanId(s) {
  try {
    if (typeof s === "string" && s.length === 16) {
      const bytes = new Uint8Array(8);
      for (let i = 0; i < 8; i++) {
        const hex = s.substr(i * 2, 2);
        const byte = parseInt(hex, 16);
        if (isNaN(byte)) throw new Error();
        bytes[i] = byte;
      }
      return { bytes, isHex: true };
    }
  } catch {
  }
  return { bytes: void 0, isHex: false };
}
__name(tryMakeHexSpanId, "tryMakeHexSpanId");
var ENCODING_VERSION_NUMBER_V4;
var INVALID_ENCODING_ERRMSG_V4;
var FIELDS_ID_TO_NAME;
var spanComponentsV4Schema;
var SpanComponentsV4;
var init_span_identifier_v4 = __esm3({
  "util/span_identifier_v4.ts"() {
    "use strict";
    init_span_identifier_v3();
    init_bytes();
    ENCODING_VERSION_NUMBER_V4 = 4;
    INVALID_ENCODING_ERRMSG_V4 = `SpanComponents string is not properly encoded. This library only supports encoding versions up to ${ENCODING_VERSION_NUMBER_V4}. Please make sure the SDK library used to decode the SpanComponents is at least as new as any library used to encode it.`;
    FIELDS_ID_TO_NAME = {
      [
        1
        /* OBJECT_ID */
      ]: "object_id",
      [
        2
        /* ROW_ID */
      ]: "row_id",
      [
        3
        /* SPAN_ID */
      ]: "span_id",
      [
        4
        /* ROOT_SPAN_ID */
      ]: "root_span_id"
    };
    spanComponentsV4Schema = external_exports.object({
      object_type: spanObjectTypeV3EnumSchema,
      propagated_event: external_exports.record(external_exports.unknown()).nullish()
    }).and(
      external_exports.union([
        // Must provide one or the other.
        external_exports.object({
          object_id: external_exports.string().nullish(),
          compute_object_metadata_args: external_exports.optional(external_exports.null())
        }),
        external_exports.object({
          object_id: external_exports.optional(external_exports.null()),
          compute_object_metadata_args: external_exports.record(external_exports.unknown())
        })
      ])
    ).and(
      external_exports.union([
        // Either all of these must be provided or none.
        external_exports.object({
          row_id: external_exports.string(),
          span_id: external_exports.string(),
          root_span_id: external_exports.string()
        }),
        external_exports.object({
          row_id: external_exports.optional(external_exports.null()),
          span_id: external_exports.optional(external_exports.null()),
          root_span_id: external_exports.optional(external_exports.null())
        })
      ])
    );
    SpanComponentsV4 = class _SpanComponentsV4 {
      static {
        __name(this, "_SpanComponentsV4");
      }
      constructor(data) {
        this.data = data;
      }
      toStr() {
        const jsonObj = {
          compute_object_metadata_args: this.data.compute_object_metadata_args || void 0,
          propagated_event: this.data.propagated_event || void 0
        };
        Object.keys(jsonObj).forEach((key) => {
          if (jsonObj[key] === void 0) {
            delete jsonObj[key];
          }
        });
        const allBuffers = [];
        allBuffers.push(
          new Uint8Array([ENCODING_VERSION_NUMBER_V4, this.data.object_type])
        );
        const hexEntries = [];
        function addHexField(origVal, fieldId) {
          let hexResult;
          if (fieldId === 3) {
            hexResult = tryMakeHexSpanId(origVal);
          } else if (fieldId === 4) {
            hexResult = tryMakeHexTraceId(origVal);
          } else {
            hexResult = { bytes: void 0, isHex: false };
          }
          if (hexResult.isHex) {
            hexEntries.push(
              concatUint8Arrays(new Uint8Array([fieldId]), hexResult.bytes)
            );
          } else {
            jsonObj[FIELDS_ID_TO_NAME[fieldId]] = origVal;
          }
        }
        __name(addHexField, "addHexField");
        if (this.data.object_id) {
          addHexField(
            this.data.object_id,
            1
            /* OBJECT_ID */
          );
        }
        if (this.data.row_id) {
          addHexField(
            this.data.row_id,
            2
            /* ROW_ID */
          );
        }
        if (this.data.span_id) {
          addHexField(
            this.data.span_id,
            3
            /* SPAN_ID */
          );
        }
        if (this.data.root_span_id) {
          addHexField(
            this.data.root_span_id,
            4
            /* ROOT_SPAN_ID */
          );
        }
        if (hexEntries.length > 255) {
          throw new Error("Impossible: too many hex entries to encode");
        }
        allBuffers.push(new Uint8Array([hexEntries.length]));
        allBuffers.push(...hexEntries);
        if (Object.keys(jsonObj).length > 0) {
          allBuffers.push(stringToUint8Array(JSON.stringify(jsonObj)));
        }
        return uint8ArrayToBase64(concatUint8Arrays(...allBuffers));
      }
      static fromStr(s) {
        try {
          const rawBytes = base64ToUint8Array(s);
          const jsonObj = {};
          if (rawBytes[0] < ENCODING_VERSION_NUMBER_V4) {
            const v3Components = SpanComponentsV3.fromStr(s);
            jsonObj["object_type"] = v3Components.data.object_type;
            jsonObj["object_id"] = v3Components.data.object_id;
            jsonObj["compute_object_metadata_args"] = v3Components.data.compute_object_metadata_args;
            jsonObj["row_id"] = v3Components.data.row_id;
            jsonObj["span_id"] = v3Components.data.span_id;
            jsonObj["root_span_id"] = v3Components.data.root_span_id;
            jsonObj["propagated_event"] = v3Components.data.propagated_event;
          } else {
            jsonObj["object_type"] = rawBytes[1];
            const numHexEntries = rawBytes[2];
            let byteOffset = 3;
            for (let i = 0; i < numHexEntries; i++) {
              const fieldId = rawBytes[byteOffset];
              if (fieldId === 3) {
                const hexBytes = rawBytes.subarray(byteOffset + 1, byteOffset + 9);
                byteOffset += 9;
                jsonObj[FIELDS_ID_TO_NAME[fieldId]] = Array.from(
                  hexBytes,
                  (b) => b.toString(16).padStart(2, "0")
                ).join("");
              } else if (fieldId === 4) {
                const hexBytes = rawBytes.subarray(byteOffset + 1, byteOffset + 17);
                byteOffset += 17;
                jsonObj[FIELDS_ID_TO_NAME[fieldId]] = Array.from(
                  hexBytes,
                  (b) => b.toString(16).padStart(2, "0")
                ).join("");
              } else {
                const hexBytes = rawBytes.subarray(byteOffset + 1, byteOffset + 17);
                byteOffset += 17;
                jsonObj[FIELDS_ID_TO_NAME[fieldId]] = Array.from(
                  hexBytes,
                  (b) => b.toString(16).padStart(2, "0")
                ).join("");
              }
            }
            if (byteOffset < rawBytes.length) {
              const remainingJsonObj = JSON.parse(
                uint8ArrayToString(rawBytes.subarray(byteOffset))
              );
              Object.assign(jsonObj, remainingJsonObj);
            }
          }
          return _SpanComponentsV4.fromJsonObj(jsonObj);
        } catch {
          throw new Error(INVALID_ENCODING_ERRMSG_V4);
        }
      }
      objectIdFields() {
        if (!this.data.object_id) {
          throw new Error(
            "Impossible: cannot invoke `objectIdFields` unless SpanComponentsV4 is initialized with an `object_id`"
          );
        }
        switch (this.data.object_type) {
          case 1:
            return { experiment_id: this.data.object_id };
          case 2:
            return { project_id: this.data.object_id, log_id: "g" };
          case 3:
            return { prompt_session_id: this.data.object_id, log_id: "x" };
          default:
            const _ = this.data.object_type;
            throw new Error(`Invalid object_type ${this.data.object_type}`);
        }
      }
      async export() {
        return this.toStr();
      }
      static fromJsonObj(jsonObj) {
        return new _SpanComponentsV4(spanComponentsV4Schema.parse(jsonObj));
      }
    };
  }
});
var init_span_types = __esm3({
  "util/span_types.ts"() {
    "use strict";
  }
});
function mergeGitMetadataSettings(s1, s2) {
  if (s1.collect === "all") {
    return s2;
  } else if (s2.collect === "all") {
    return s1;
  } else if (s1.collect === "none") {
    return s1;
  } else if (s2.collect === "none") {
    return s2;
  }
  const fields = (s1.fields ?? []).filter((f) => (s2.fields ?? []).includes(f));
  const collect = fields.length > 0 ? "some" : "none";
  return { collect, fields };
}
__name(mergeGitMetadataSettings, "mergeGitMetadataSettings");
var init_git_fields = __esm3({
  "util/git_fields.ts"() {
    "use strict";
  }
});
function modularMultiply(value, prime) {
  return value * prime % MOD;
}
__name(modularMultiply, "modularMultiply");
function prettifyXact(valueString) {
  const value = BigInt(valueString);
  const encoded = modularMultiply(value, COPRIME);
  return encoded.toString(16).padStart(16, "0");
}
__name(prettifyXact, "prettifyXact");
function loadPrettyXact(encodedHex) {
  if (encodedHex.length !== 16) {
    return encodedHex;
  }
  const value = BigInt(`0x${encodedHex}`);
  const multipliedInverse = modularMultiply(value, COPRIME_INVERSE);
  const withTopBits = TOP_BITS | multipliedInverse;
  return withTopBits.toString();
}
__name(loadPrettyXact, "loadPrettyXact");
var TOP_BITS;
var MOD;
var COPRIME;
var COPRIME_INVERSE;
var init_xact_ids = __esm3({
  "util/xact-ids.ts"() {
    "use strict";
    TOP_BITS = BigInt("0x0DE1") << BigInt(48);
    MOD = BigInt(1) << BigInt(64);
    COPRIME = BigInt("205891132094649");
    COPRIME_INVERSE = BigInt("1522336535492693385");
  }
});
var init_zod_util = __esm3({
  "util/zod_util.ts"() {
    "use strict";
    init_object_util();
  }
});
var init_util2 = __esm3({
  "util/index.ts"() {
    "use strict";
    init_db_fields();
    init_http_headers();
    init_merge_row_batch();
    init_object();
    init_score();
    init_json_util();
    init_object_util();
    init_string_util();
    init_type_util();
    init_span_identifier_v1();
    init_span_identifier_v2();
    init_span_identifier_v3();
    init_span_identifier_v4();
    init_span_types();
    init_git_fields();
    init_xact_ids();
    init_zod_util();
    init_bytes();
  }
});
var AclObjectType;
var Permission;
var Acl;
var AISecret;
var ResponseFormatJsonSchema;
var ResponseFormatNullish;
var AnyModelParams;
var ApiKey;
var AsyncScoringState;
var AsyncScoringControl;
var BraintrustAttachmentReference;
var ExternalAttachmentReference;
var AttachmentReference;
var UploadStatus;
var AttachmentStatus;
var BraintrustModelParams;
var CallEvent;
var ChatCompletionContentPartTextWithTitle;
var ChatCompletionContentPartImageWithTitle;
var ChatCompletionContentPart;
var ChatCompletionContentPartText;
var ChatCompletionMessageToolCall;
var ChatCompletionMessageReasoning;
var ChatCompletionMessageParam;
var ChatCompletionOpenAIMessageParam;
var ChatCompletionTool;
var CodeBundle;
var Dataset;
var ObjectReferenceNullish;
var DatasetEvent;
var EnvVar;
var RepoInfo;
var Experiment;
var SpanType;
var SpanAttributes;
var ExperimentEvent;
var ExtendedSavedFunctionId;
var PromptBlockDataNullish;
var ModelParams;
var PromptOptionsNullish;
var PromptParserNullish;
var SavedFunctionId;
var PromptDataNullish;
var FunctionTypeEnumNullish;
var FunctionIdRef;
var PromptBlockData;
var GraphNode;
var GraphEdge;
var GraphData;
var FunctionData;
var Function2;
var FunctionFormat;
var PromptData;
var FunctionTypeEnum;
var FunctionId;
var FunctionObjectType;
var FunctionOutputType;
var GitMetadataSettings;
var Group;
var IfExists;
var InvokeParent;
var StreamingMode;
var InvokeFunction;
var MessageRole;
var ObjectReference;
var OnlineScoreConfig;
var Organization;
var ProjectSettings;
var Project;
var RetentionObjectType;
var ProjectAutomation;
var ProjectLogsEvent;
var ProjectScoreType;
var ProjectScoreCategory;
var ProjectScoreCategories;
var ProjectScoreConfig;
var ProjectScore;
var ProjectTag;
var Prompt;
var PromptOptions;
var PromptSessionEvent;
var ResponseFormat;
var Role;
var RunEval;
var ServiceToken;
var SpanIFrame;
var SSEConsoleEventData;
var SSEProgressEventData;
var ToolFunctionDefinition;
var User;
var ViewDataSearch;
var ViewData;
var ViewOptions;
var View;
var init_generated_types = __esm3({
  "src/generated_types.ts"() {
    "use strict";
    AclObjectType = external_exports.union([
      external_exports.enum([
        "organization",
        "project",
        "experiment",
        "dataset",
        "prompt",
        "prompt_session",
        "group",
        "role",
        "org_member",
        "project_log",
        "org_project"
      ]),
      external_exports.null()
    ]);
    Permission = external_exports.enum([
      "create",
      "read",
      "update",
      "delete",
      "create_acls",
      "read_acls",
      "update_acls",
      "delete_acls"
    ]);
    Acl = external_exports.object({
      id: external_exports.string().uuid(),
      object_type: AclObjectType.and(external_exports.string()),
      object_id: external_exports.string().uuid(),
      user_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      group_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      permission: Permission.and(external_exports.union([external_exports.string(), external_exports.null()])).optional(),
      restrict_object_type: AclObjectType.and(external_exports.unknown()).optional(),
      role_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      _object_org_id: external_exports.string().uuid(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional()
    });
    AISecret = external_exports.object({
      id: external_exports.string().uuid(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      updated_at: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      org_id: external_exports.string().uuid(),
      name: external_exports.string(),
      type: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      metadata: external_exports.union([external_exports.object({}).partial().passthrough(), external_exports.null()]).optional(),
      preview_secret: external_exports.union([external_exports.string(), external_exports.null()]).optional()
    });
    ResponseFormatJsonSchema = external_exports.object({
      name: external_exports.string(),
      description: external_exports.string().optional(),
      schema: external_exports.union([external_exports.object({}).partial().passthrough(), external_exports.string()]).optional(),
      strict: external_exports.union([external_exports.boolean(), external_exports.null()]).optional()
    });
    ResponseFormatNullish = external_exports.union([
      external_exports.object({ type: external_exports.literal("json_object") }),
      external_exports.object({
        type: external_exports.literal("json_schema"),
        json_schema: ResponseFormatJsonSchema
      }),
      external_exports.object({ type: external_exports.literal("text") }),
      external_exports.null()
    ]);
    AnyModelParams = external_exports.object({
      temperature: external_exports.number().optional(),
      top_p: external_exports.number().optional(),
      max_tokens: external_exports.number(),
      max_completion_tokens: external_exports.number().optional(),
      frequency_penalty: external_exports.number().optional(),
      presence_penalty: external_exports.number().optional(),
      response_format: ResponseFormatNullish.optional(),
      tool_choice: external_exports.union([
        external_exports.literal("auto"),
        external_exports.literal("none"),
        external_exports.literal("required"),
        external_exports.object({
          type: external_exports.literal("function"),
          function: external_exports.object({ name: external_exports.string() })
        })
      ]).optional(),
      function_call: external_exports.union([
        external_exports.literal("auto"),
        external_exports.literal("none"),
        external_exports.object({ name: external_exports.string() })
      ]).optional(),
      n: external_exports.number().optional(),
      stop: external_exports.array(external_exports.string()).optional(),
      reasoning_effort: external_exports.enum(["minimal", "low", "medium", "high"]).optional(),
      verbosity: external_exports.enum(["low", "medium", "high"]).optional(),
      top_k: external_exports.number().optional(),
      stop_sequences: external_exports.array(external_exports.string()).optional(),
      max_tokens_to_sample: external_exports.number().optional(),
      maxOutputTokens: external_exports.number().optional(),
      topP: external_exports.number().optional(),
      topK: external_exports.number().optional(),
      use_cache: external_exports.boolean().optional()
    });
    ApiKey = external_exports.object({
      id: external_exports.string().uuid(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      name: external_exports.string(),
      preview_name: external_exports.string(),
      user_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      user_email: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      user_given_name: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      user_family_name: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      org_id: external_exports.union([external_exports.string(), external_exports.null()]).optional()
    });
    AsyncScoringState = external_exports.union([
      external_exports.object({
        status: external_exports.literal("enabled"),
        token: external_exports.string(),
        function_ids: external_exports.array(external_exports.unknown()).min(1),
        skip_logging: external_exports.union([external_exports.boolean(), external_exports.null()]).optional()
      }),
      external_exports.object({ status: external_exports.literal("disabled") }),
      external_exports.null(),
      external_exports.null()
    ]);
    AsyncScoringControl = external_exports.union([
      external_exports.object({ kind: external_exports.literal("score_update"), token: external_exports.string() }),
      external_exports.object({ kind: external_exports.literal("state_override"), state: AsyncScoringState }),
      external_exports.object({ kind: external_exports.literal("state_force_reselect") }),
      external_exports.object({ kind: external_exports.literal("state_enabled_force_rescore") })
    ]);
    BraintrustAttachmentReference = external_exports.object({
      type: external_exports.literal("braintrust_attachment"),
      filename: external_exports.string().min(1),
      content_type: external_exports.string().min(1),
      key: external_exports.string().min(1)
    });
    ExternalAttachmentReference = external_exports.object({
      type: external_exports.literal("external_attachment"),
      filename: external_exports.string().min(1),
      content_type: external_exports.string().min(1),
      url: external_exports.string().min(1)
    });
    AttachmentReference = external_exports.discriminatedUnion("type", [
      BraintrustAttachmentReference,
      ExternalAttachmentReference
    ]);
    UploadStatus = external_exports.enum(["uploading", "done", "error"]);
    AttachmentStatus = external_exports.object({
      upload_status: UploadStatus,
      error_message: external_exports.string().optional()
    });
    BraintrustModelParams = external_exports.object({ use_cache: external_exports.boolean() }).partial();
    CallEvent = external_exports.union([
      external_exports.object({
        id: external_exports.string().optional(),
        data: external_exports.string(),
        event: external_exports.literal("text_delta")
      }),
      external_exports.object({
        id: external_exports.string().optional(),
        data: external_exports.string(),
        event: external_exports.literal("reasoning_delta")
      }),
      external_exports.object({
        id: external_exports.string().optional(),
        data: external_exports.string(),
        event: external_exports.literal("json_delta")
      }),
      external_exports.object({
        id: external_exports.string().optional(),
        data: external_exports.string(),
        event: external_exports.literal("progress")
      }),
      external_exports.object({
        id: external_exports.string().optional(),
        data: external_exports.string(),
        event: external_exports.literal("error")
      }),
      external_exports.object({
        id: external_exports.string().optional(),
        data: external_exports.string(),
        event: external_exports.literal("console")
      }),
      external_exports.object({
        id: external_exports.string().optional(),
        event: external_exports.literal("start"),
        data: external_exports.literal("")
      }),
      external_exports.object({
        id: external_exports.string().optional(),
        event: external_exports.literal("done"),
        data: external_exports.literal("")
      })
    ]);
    ChatCompletionContentPartTextWithTitle = external_exports.object({
      text: external_exports.string().default(""),
      type: external_exports.literal("text"),
      cache_control: external_exports.object({ type: external_exports.literal("ephemeral") }).optional()
    });
    ChatCompletionContentPartImageWithTitle = external_exports.object({
      image_url: external_exports.object({
        url: external_exports.string(),
        detail: external_exports.union([external_exports.literal("auto"), external_exports.literal("low"), external_exports.literal("high")]).optional()
      }),
      type: external_exports.literal("image_url")
    });
    ChatCompletionContentPart = external_exports.union([
      ChatCompletionContentPartTextWithTitle,
      ChatCompletionContentPartImageWithTitle
    ]);
    ChatCompletionContentPartText = external_exports.object({
      text: external_exports.string().default(""),
      type: external_exports.literal("text"),
      cache_control: external_exports.object({ type: external_exports.literal("ephemeral") }).optional()
    });
    ChatCompletionMessageToolCall = external_exports.object({
      id: external_exports.string(),
      function: external_exports.object({ arguments: external_exports.string(), name: external_exports.string() }),
      type: external_exports.literal("function")
    });
    ChatCompletionMessageReasoning = external_exports.object({ id: external_exports.string(), content: external_exports.string() }).partial();
    ChatCompletionMessageParam = external_exports.union([
      external_exports.object({
        content: external_exports.union([external_exports.string(), external_exports.array(ChatCompletionContentPartText)]),
        role: external_exports.literal("system"),
        name: external_exports.string().optional()
      }),
      external_exports.object({
        content: external_exports.union([external_exports.string(), external_exports.array(ChatCompletionContentPart)]),
        role: external_exports.literal("user"),
        name: external_exports.string().optional()
      }),
      external_exports.object({
        role: external_exports.literal("assistant"),
        content: external_exports.union([external_exports.string(), external_exports.array(ChatCompletionContentPartText), external_exports.null()]).optional(),
        function_call: external_exports.object({ arguments: external_exports.string(), name: external_exports.string() }).optional(),
        name: external_exports.string().optional(),
        tool_calls: external_exports.array(ChatCompletionMessageToolCall).optional(),
        reasoning: external_exports.array(ChatCompletionMessageReasoning).optional()
      }),
      external_exports.object({
        content: external_exports.union([external_exports.string(), external_exports.array(ChatCompletionContentPartText)]),
        role: external_exports.literal("tool"),
        tool_call_id: external_exports.string().default("")
      }),
      external_exports.object({
        content: external_exports.union([external_exports.string(), external_exports.null()]),
        name: external_exports.string(),
        role: external_exports.literal("function")
      }),
      external_exports.object({
        content: external_exports.union([external_exports.string(), external_exports.array(ChatCompletionContentPartText)]),
        role: external_exports.literal("developer"),
        name: external_exports.string().optional()
      }),
      external_exports.object({
        role: external_exports.literal("model"),
        content: external_exports.union([external_exports.string(), external_exports.null()]).optional()
      })
    ]);
    ChatCompletionOpenAIMessageParam = external_exports.union([
      external_exports.object({
        content: external_exports.union([external_exports.string(), external_exports.array(ChatCompletionContentPartText)]),
        role: external_exports.literal("system"),
        name: external_exports.string().optional()
      }),
      external_exports.object({
        content: external_exports.union([external_exports.string(), external_exports.array(ChatCompletionContentPart)]),
        role: external_exports.literal("user"),
        name: external_exports.string().optional()
      }),
      external_exports.object({
        role: external_exports.literal("assistant"),
        content: external_exports.union([external_exports.string(), external_exports.array(ChatCompletionContentPartText), external_exports.null()]).optional(),
        function_call: external_exports.object({ arguments: external_exports.string(), name: external_exports.string() }).optional(),
        name: external_exports.string().optional(),
        tool_calls: external_exports.array(ChatCompletionMessageToolCall).optional(),
        reasoning: external_exports.array(ChatCompletionMessageReasoning).optional()
      }),
      external_exports.object({
        content: external_exports.union([external_exports.string(), external_exports.array(ChatCompletionContentPartText)]),
        role: external_exports.literal("tool"),
        tool_call_id: external_exports.string().default("")
      }),
      external_exports.object({
        content: external_exports.union([external_exports.string(), external_exports.null()]),
        name: external_exports.string(),
        role: external_exports.literal("function")
      }),
      external_exports.object({
        content: external_exports.union([external_exports.string(), external_exports.array(ChatCompletionContentPartText)]),
        role: external_exports.literal("developer"),
        name: external_exports.string().optional()
      })
    ]);
    ChatCompletionTool = external_exports.object({
      function: external_exports.object({
        name: external_exports.string(),
        description: external_exports.string().optional(),
        parameters: external_exports.object({}).partial().passthrough().optional()
      }),
      type: external_exports.literal("function")
    });
    CodeBundle = external_exports.object({
      runtime_context: external_exports.object({
        runtime: external_exports.enum(["node", "python"]),
        version: external_exports.string()
      }),
      location: external_exports.union([
        external_exports.object({
          type: external_exports.literal("experiment"),
          eval_name: external_exports.string(),
          position: external_exports.union([
            external_exports.object({ type: external_exports.literal("task") }),
            external_exports.object({ type: external_exports.literal("scorer"), index: external_exports.number().int().gte(0) })
          ])
        }),
        external_exports.object({ type: external_exports.literal("function"), index: external_exports.number().int().gte(0) })
      ]),
      bundle_id: external_exports.string(),
      preview: external_exports.union([external_exports.string(), external_exports.null()]).optional()
    });
    Dataset = external_exports.object({
      id: external_exports.string().uuid(),
      project_id: external_exports.string().uuid(),
      name: external_exports.string(),
      description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      deleted_at: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      user_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      metadata: external_exports.union([external_exports.object({}).partial().passthrough(), external_exports.null()]).optional()
    });
    ObjectReferenceNullish = external_exports.union([
      external_exports.object({
        object_type: external_exports.enum([
          "project_logs",
          "experiment",
          "dataset",
          "prompt",
          "function",
          "prompt_session"
        ]),
        object_id: external_exports.string().uuid(),
        id: external_exports.string(),
        _xact_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
        created: external_exports.union([external_exports.string(), external_exports.null()]).optional()
      }),
      external_exports.null()
    ]);
    DatasetEvent = external_exports.object({
      id: external_exports.string(),
      _xact_id: external_exports.string(),
      created: external_exports.string().datetime({ offset: true }),
      _pagination_key: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      project_id: external_exports.string().uuid(),
      dataset_id: external_exports.string().uuid(),
      input: external_exports.unknown().optional(),
      expected: external_exports.unknown().optional(),
      metadata: external_exports.union([
        external_exports.object({ model: external_exports.union([external_exports.string(), external_exports.null()]) }).partial().passthrough(),
        external_exports.null()
      ]).optional(),
      tags: external_exports.union([external_exports.array(external_exports.string()), external_exports.null()]).optional(),
      span_id: external_exports.string(),
      root_span_id: external_exports.string(),
      is_root: external_exports.union([external_exports.boolean(), external_exports.null()]).optional(),
      origin: ObjectReferenceNullish.optional()
    });
    EnvVar = external_exports.object({
      id: external_exports.string().uuid(),
      object_type: external_exports.enum(["organization", "project", "function"]),
      object_id: external_exports.string().uuid(),
      name: external_exports.string(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      used: external_exports.union([external_exports.string(), external_exports.null()]).optional()
    });
    RepoInfo = external_exports.union([
      external_exports.object({
        commit: external_exports.union([external_exports.string(), external_exports.null()]),
        branch: external_exports.union([external_exports.string(), external_exports.null()]),
        tag: external_exports.union([external_exports.string(), external_exports.null()]),
        dirty: external_exports.union([external_exports.boolean(), external_exports.null()]),
        author_name: external_exports.union([external_exports.string(), external_exports.null()]),
        author_email: external_exports.union([external_exports.string(), external_exports.null()]),
        commit_message: external_exports.union([external_exports.string(), external_exports.null()]),
        commit_time: external_exports.union([external_exports.string(), external_exports.null()]),
        git_diff: external_exports.union([external_exports.string(), external_exports.null()])
      }).partial(),
      external_exports.null()
    ]);
    Experiment = external_exports.object({
      id: external_exports.string().uuid(),
      project_id: external_exports.string().uuid(),
      name: external_exports.string(),
      description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      repo_info: RepoInfo.optional(),
      commit: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      base_exp_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      deleted_at: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      dataset_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      dataset_version: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      public: external_exports.boolean(),
      user_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      metadata: external_exports.union([external_exports.object({}).partial().passthrough(), external_exports.null()]).optional(),
      tags: external_exports.union([external_exports.array(external_exports.string()), external_exports.null()]).optional()
    });
    SpanType = external_exports.union([
      external_exports.enum(["llm", "score", "function", "eval", "task", "tool"]),
      external_exports.null()
    ]);
    SpanAttributes = external_exports.union([
      external_exports.object({ name: external_exports.union([external_exports.string(), external_exports.null()]), type: SpanType }).partial().passthrough(),
      external_exports.null()
    ]);
    ExperimentEvent = external_exports.object({
      id: external_exports.string(),
      _xact_id: external_exports.string(),
      created: external_exports.string().datetime({ offset: true }),
      _pagination_key: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      project_id: external_exports.string().uuid(),
      experiment_id: external_exports.string().uuid(),
      input: external_exports.unknown().optional(),
      output: external_exports.unknown().optional(),
      expected: external_exports.unknown().optional(),
      error: external_exports.unknown().optional(),
      scores: external_exports.union([external_exports.record(external_exports.union([external_exports.number(), external_exports.null()])), external_exports.null()]).optional(),
      metadata: external_exports.union([
        external_exports.object({ model: external_exports.union([external_exports.string(), external_exports.null()]) }).partial().passthrough(),
        external_exports.null()
      ]).optional(),
      tags: external_exports.union([external_exports.array(external_exports.string()), external_exports.null()]).optional(),
      metrics: external_exports.union([external_exports.record(external_exports.number()), external_exports.null()]).optional(),
      context: external_exports.union([
        external_exports.object({
          caller_functionname: external_exports.union([external_exports.string(), external_exports.null()]),
          caller_filename: external_exports.union([external_exports.string(), external_exports.null()]),
          caller_lineno: external_exports.union([external_exports.number(), external_exports.null()])
        }).partial().passthrough(),
        external_exports.null()
      ]).optional(),
      span_id: external_exports.string(),
      span_parents: external_exports.union([external_exports.array(external_exports.string()), external_exports.null()]).optional(),
      root_span_id: external_exports.string(),
      span_attributes: SpanAttributes.optional(),
      is_root: external_exports.union([external_exports.boolean(), external_exports.null()]).optional(),
      origin: ObjectReferenceNullish.optional()
    });
    ExtendedSavedFunctionId = external_exports.union([
      external_exports.object({ type: external_exports.literal("function"), id: external_exports.string() }),
      external_exports.object({ type: external_exports.literal("global"), name: external_exports.string() }),
      external_exports.object({
        type: external_exports.literal("slug"),
        project_id: external_exports.string(),
        slug: external_exports.string()
      })
    ]);
    PromptBlockDataNullish = external_exports.union([
      external_exports.object({ type: external_exports.literal("completion"), content: external_exports.string() }),
      external_exports.object({
        type: external_exports.literal("chat"),
        messages: external_exports.array(ChatCompletionMessageParam),
        tools: external_exports.string().optional()
      }),
      external_exports.null()
    ]);
    ModelParams = external_exports.union([
      external_exports.object({
        use_cache: external_exports.boolean(),
        temperature: external_exports.number(),
        top_p: external_exports.number(),
        max_tokens: external_exports.number(),
        max_completion_tokens: external_exports.number(),
        frequency_penalty: external_exports.number(),
        presence_penalty: external_exports.number(),
        response_format: ResponseFormatNullish,
        tool_choice: external_exports.union([
          external_exports.literal("auto"),
          external_exports.literal("none"),
          external_exports.literal("required"),
          external_exports.object({
            type: external_exports.literal("function"),
            function: external_exports.object({ name: external_exports.string() })
          })
        ]),
        function_call: external_exports.union([
          external_exports.literal("auto"),
          external_exports.literal("none"),
          external_exports.object({ name: external_exports.string() })
        ]),
        n: external_exports.number(),
        stop: external_exports.array(external_exports.string()),
        reasoning_effort: external_exports.enum(["minimal", "low", "medium", "high"]),
        verbosity: external_exports.enum(["low", "medium", "high"])
      }).partial().passthrough(),
      external_exports.object({
        use_cache: external_exports.boolean().optional(),
        max_tokens: external_exports.number(),
        temperature: external_exports.number(),
        top_p: external_exports.number().optional(),
        top_k: external_exports.number().optional(),
        stop_sequences: external_exports.array(external_exports.string()).optional(),
        max_tokens_to_sample: external_exports.number().optional()
      }).passthrough(),
      external_exports.object({
        use_cache: external_exports.boolean(),
        temperature: external_exports.number(),
        maxOutputTokens: external_exports.number(),
        topP: external_exports.number(),
        topK: external_exports.number()
      }).partial().passthrough(),
      external_exports.object({
        use_cache: external_exports.boolean(),
        temperature: external_exports.number(),
        topK: external_exports.number()
      }).partial().passthrough(),
      external_exports.object({ use_cache: external_exports.boolean() }).partial().passthrough()
    ]);
    PromptOptionsNullish = external_exports.union([
      external_exports.object({ model: external_exports.string(), params: ModelParams, position: external_exports.string() }).partial(),
      external_exports.null()
    ]);
    PromptParserNullish = external_exports.union([
      external_exports.object({
        type: external_exports.literal("llm_classifier"),
        use_cot: external_exports.boolean(),
        choice_scores: external_exports.record(external_exports.number().gte(0).lte(1))
      }),
      external_exports.null()
    ]);
    SavedFunctionId = external_exports.union([
      external_exports.object({ type: external_exports.literal("function"), id: external_exports.string() }),
      external_exports.object({ type: external_exports.literal("global"), name: external_exports.string() })
    ]);
    PromptDataNullish = external_exports.union([
      external_exports.object({
        prompt: PromptBlockDataNullish,
        options: PromptOptionsNullish,
        parser: PromptParserNullish,
        tool_functions: external_exports.union([external_exports.array(SavedFunctionId), external_exports.null()]),
        origin: external_exports.union([
          external_exports.object({
            prompt_id: external_exports.string(),
            project_id: external_exports.string(),
            prompt_version: external_exports.string()
          }).partial(),
          external_exports.null()
        ])
      }).partial(),
      external_exports.null()
    ]);
    FunctionTypeEnumNullish = external_exports.union([
      external_exports.enum(["llm", "scorer", "task", "tool"]),
      external_exports.null()
    ]);
    FunctionIdRef = external_exports.object({}).partial().passthrough();
    PromptBlockData = external_exports.union([
      external_exports.object({ type: external_exports.literal("completion"), content: external_exports.string() }),
      external_exports.object({
        type: external_exports.literal("chat"),
        messages: external_exports.array(ChatCompletionMessageParam),
        tools: external_exports.string().optional()
      })
    ]);
    GraphNode = external_exports.union([
      external_exports.object({
        description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
        position: external_exports.union([external_exports.object({ x: external_exports.number(), y: external_exports.number() }), external_exports.null()]).optional(),
        type: external_exports.literal("function"),
        function: FunctionIdRef
      }),
      external_exports.object({
        description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
        position: external_exports.union([external_exports.object({ x: external_exports.number(), y: external_exports.number() }), external_exports.null()]).optional(),
        type: external_exports.literal("input")
      }),
      external_exports.object({
        description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
        position: external_exports.union([external_exports.object({ x: external_exports.number(), y: external_exports.number() }), external_exports.null()]).optional(),
        type: external_exports.literal("output")
      }),
      external_exports.object({
        description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
        position: external_exports.union([external_exports.object({ x: external_exports.number(), y: external_exports.number() }), external_exports.null()]).optional(),
        type: external_exports.literal("literal"),
        value: external_exports.unknown().optional()
      }),
      external_exports.object({
        description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
        position: external_exports.union([external_exports.object({ x: external_exports.number(), y: external_exports.number() }), external_exports.null()]).optional(),
        type: external_exports.literal("btql"),
        expr: external_exports.string()
      }),
      external_exports.object({
        description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
        position: external_exports.union([external_exports.object({ x: external_exports.number(), y: external_exports.number() }), external_exports.null()]).optional(),
        type: external_exports.literal("gate"),
        condition: external_exports.union([external_exports.string(), external_exports.null()]).optional()
      }),
      external_exports.object({
        description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
        position: external_exports.union([external_exports.object({ x: external_exports.number(), y: external_exports.number() }), external_exports.null()]).optional(),
        type: external_exports.literal("aggregator")
      }),
      external_exports.object({
        description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
        position: external_exports.union([external_exports.object({ x: external_exports.number(), y: external_exports.number() }), external_exports.null()]).optional(),
        type: external_exports.literal("prompt_template"),
        prompt: PromptBlockData
      })
    ]);
    GraphEdge = external_exports.object({
      source: external_exports.object({ node: external_exports.string().max(1024), variable: external_exports.string() }),
      target: external_exports.object({ node: external_exports.string().max(1024), variable: external_exports.string() }),
      purpose: external_exports.enum(["control", "data", "messages"])
    });
    GraphData = external_exports.object({
      type: external_exports.literal("graph"),
      nodes: external_exports.record(GraphNode),
      edges: external_exports.record(GraphEdge)
    });
    FunctionData = external_exports.union([
      external_exports.object({ type: external_exports.literal("prompt") }),
      external_exports.object({
        type: external_exports.literal("code"),
        data: external_exports.union([
          external_exports.object({ type: external_exports.literal("bundle") }).and(CodeBundle),
          external_exports.object({
            type: external_exports.literal("inline"),
            runtime_context: external_exports.object({
              runtime: external_exports.enum(["node", "python"]),
              version: external_exports.string()
            }),
            code: external_exports.string()
          })
        ])
      }),
      GraphData,
      external_exports.object({
        type: external_exports.literal("remote_eval"),
        endpoint: external_exports.string(),
        eval_name: external_exports.string(),
        parameters: external_exports.object({}).partial().passthrough()
      }),
      external_exports.object({ type: external_exports.literal("global"), name: external_exports.string() })
    ]);
    Function2 = external_exports.object({
      id: external_exports.string().uuid(),
      _xact_id: external_exports.string(),
      project_id: external_exports.string().uuid(),
      log_id: external_exports.literal("p"),
      org_id: external_exports.string().uuid(),
      name: external_exports.string(),
      slug: external_exports.string(),
      description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      prompt_data: PromptDataNullish.optional(),
      tags: external_exports.union([external_exports.array(external_exports.string()), external_exports.null()]).optional(),
      metadata: external_exports.union([external_exports.object({}).partial().passthrough(), external_exports.null()]).optional(),
      function_type: FunctionTypeEnumNullish.optional(),
      function_data: FunctionData,
      origin: external_exports.union([
        external_exports.object({
          object_type: AclObjectType.and(external_exports.string()),
          object_id: external_exports.string().uuid(),
          internal: external_exports.union([external_exports.boolean(), external_exports.null()]).optional()
        }),
        external_exports.null()
      ]).optional(),
      function_schema: external_exports.union([
        external_exports.object({ parameters: external_exports.unknown(), returns: external_exports.unknown() }).partial(),
        external_exports.null()
      ]).optional()
    });
    FunctionFormat = external_exports.enum(["llm", "code", "global", "graph"]);
    PromptData = external_exports.object({
      prompt: PromptBlockDataNullish,
      options: PromptOptionsNullish,
      parser: PromptParserNullish,
      tool_functions: external_exports.union([external_exports.array(SavedFunctionId), external_exports.null()]),
      origin: external_exports.union([
        external_exports.object({
          prompt_id: external_exports.string(),
          project_id: external_exports.string(),
          prompt_version: external_exports.string()
        }).partial(),
        external_exports.null()
      ])
    }).partial();
    FunctionTypeEnum = external_exports.enum(["llm", "scorer", "task", "tool"]);
    FunctionId = external_exports.union([
      external_exports.object({ function_id: external_exports.string(), version: external_exports.string().optional() }),
      external_exports.object({
        project_name: external_exports.string(),
        slug: external_exports.string(),
        version: external_exports.string().optional()
      }),
      external_exports.object({ global_function: external_exports.string() }),
      external_exports.object({
        prompt_session_id: external_exports.string(),
        prompt_session_function_id: external_exports.string(),
        version: external_exports.string().optional()
      }),
      external_exports.object({
        inline_context: external_exports.object({
          runtime: external_exports.enum(["node", "python"]),
          version: external_exports.string()
        }),
        code: external_exports.string(),
        name: external_exports.union([external_exports.string(), external_exports.null()]).optional()
      }),
      external_exports.object({
        inline_prompt: PromptData.optional(),
        inline_function: external_exports.object({}).partial().passthrough(),
        function_type: FunctionTypeEnum.optional(),
        name: external_exports.union([external_exports.string(), external_exports.null()]).optional()
      }),
      external_exports.object({
        inline_prompt: PromptData,
        function_type: FunctionTypeEnum.optional(),
        name: external_exports.union([external_exports.string(), external_exports.null()]).optional()
      })
    ]);
    FunctionObjectType = external_exports.enum([
      "prompt",
      "tool",
      "scorer",
      "task",
      "agent"
    ]);
    FunctionOutputType = external_exports.enum(["completion", "score", "any"]);
    GitMetadataSettings = external_exports.object({
      collect: external_exports.enum(["all", "none", "some"]),
      fields: external_exports.array(
        external_exports.enum([
          "commit",
          "branch",
          "tag",
          "dirty",
          "author_name",
          "author_email",
          "commit_message",
          "commit_time",
          "git_diff"
        ])
      ).optional()
    });
    Group = external_exports.object({
      id: external_exports.string().uuid(),
      org_id: external_exports.string().uuid(),
      user_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      name: external_exports.string(),
      description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      deleted_at: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      member_users: external_exports.union([external_exports.array(external_exports.string().uuid()), external_exports.null()]).optional(),
      member_groups: external_exports.union([external_exports.array(external_exports.string().uuid()), external_exports.null()]).optional()
    });
    IfExists = external_exports.enum(["error", "ignore", "replace"]);
    InvokeParent = external_exports.union([
      external_exports.object({
        object_type: external_exports.enum(["project_logs", "experiment", "playground_logs"]),
        object_id: external_exports.string(),
        row_ids: external_exports.union([
          external_exports.object({
            id: external_exports.string(),
            span_id: external_exports.string(),
            root_span_id: external_exports.string()
          }),
          external_exports.null()
        ]).optional(),
        propagated_event: external_exports.union([external_exports.object({}).partial().passthrough(), external_exports.null()]).optional()
      }),
      external_exports.string()
    ]);
    StreamingMode = external_exports.union([external_exports.enum(["auto", "parallel"]), external_exports.null()]);
    InvokeFunction = FunctionId.and(
      external_exports.object({
        input: external_exports.unknown(),
        expected: external_exports.unknown(),
        metadata: external_exports.union([external_exports.object({}).partial().passthrough(), external_exports.null()]),
        tags: external_exports.union([external_exports.array(external_exports.string()), external_exports.null()]),
        messages: external_exports.array(ChatCompletionMessageParam),
        parent: InvokeParent,
        stream: external_exports.union([external_exports.boolean(), external_exports.null()]),
        mode: StreamingMode,
        strict: external_exports.union([external_exports.boolean(), external_exports.null()])
      }).partial()
    );
    MessageRole = external_exports.enum([
      "system",
      "user",
      "assistant",
      "function",
      "tool",
      "model",
      "developer"
    ]);
    ObjectReference = external_exports.object({
      object_type: external_exports.enum([
        "project_logs",
        "experiment",
        "dataset",
        "prompt",
        "function",
        "prompt_session"
      ]),
      object_id: external_exports.string().uuid(),
      id: external_exports.string(),
      _xact_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional()
    });
    OnlineScoreConfig = external_exports.union([
      external_exports.object({
        sampling_rate: external_exports.number().gte(0).lte(1),
        scorers: external_exports.array(SavedFunctionId),
        btql_filter: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
        apply_to_root_span: external_exports.union([external_exports.boolean(), external_exports.null()]).optional(),
        apply_to_span_names: external_exports.union([external_exports.array(external_exports.string()), external_exports.null()]).optional(),
        skip_logging: external_exports.union([external_exports.boolean(), external_exports.null()]).optional()
      }),
      external_exports.null()
    ]);
    Organization = external_exports.object({
      id: external_exports.string().uuid(),
      name: external_exports.string(),
      api_url: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      is_universal_api: external_exports.union([external_exports.boolean(), external_exports.null()]).optional(),
      proxy_url: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      realtime_url: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional()
    });
    ProjectSettings = external_exports.union([
      external_exports.object({
        comparison_key: external_exports.union([external_exports.string(), external_exports.null()]),
        baseline_experiment_id: external_exports.union([external_exports.string(), external_exports.null()]),
        spanFieldOrder: external_exports.union([
          external_exports.array(
            external_exports.object({
              object_type: external_exports.string(),
              column_id: external_exports.string(),
              position: external_exports.string(),
              layout: external_exports.union([external_exports.literal("full"), external_exports.literal("two_column"), external_exports.null()]).optional()
            })
          ),
          external_exports.null()
        ]),
        remote_eval_sources: external_exports.union([
          external_exports.array(
            external_exports.object({
              url: external_exports.string(),
              name: external_exports.string(),
              description: external_exports.union([external_exports.string(), external_exports.null()]).optional()
            })
          ),
          external_exports.null()
        ])
      }).partial(),
      external_exports.null()
    ]);
    Project = external_exports.object({
      id: external_exports.string().uuid(),
      org_id: external_exports.string().uuid(),
      name: external_exports.string(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      deleted_at: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      user_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      settings: ProjectSettings.optional()
    });
    RetentionObjectType = external_exports.enum([
      "project_logs",
      "experiment",
      "dataset"
    ]);
    ProjectAutomation = external_exports.object({
      id: external_exports.string().uuid(),
      project_id: external_exports.string().uuid(),
      user_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      name: external_exports.string(),
      description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      config: external_exports.union([
        external_exports.object({
          event_type: external_exports.literal("logs"),
          btql_filter: external_exports.string(),
          interval_seconds: external_exports.number().gte(1).lte(2592e3),
          action: external_exports.object({ type: external_exports.literal("webhook"), url: external_exports.string() })
        }),
        external_exports.object({
          event_type: external_exports.literal("btql_export"),
          export_definition: external_exports.union([
            external_exports.object({ type: external_exports.literal("log_traces") }),
            external_exports.object({ type: external_exports.literal("log_spans") }),
            external_exports.object({ type: external_exports.literal("btql_query"), btql_query: external_exports.string() })
          ]),
          export_path: external_exports.string(),
          format: external_exports.enum(["jsonl", "parquet"]),
          interval_seconds: external_exports.number().gte(1).lte(2592e3),
          credentials: external_exports.object({
            type: external_exports.literal("aws_iam"),
            role_arn: external_exports.string(),
            external_id: external_exports.string()
          }),
          batch_size: external_exports.union([external_exports.number(), external_exports.null()]).optional()
        }),
        external_exports.object({
          event_type: external_exports.literal("retention"),
          object_type: RetentionObjectType,
          retention_days: external_exports.number().gte(0)
        })
      ])
    });
    ProjectLogsEvent = external_exports.object({
      id: external_exports.string(),
      _xact_id: external_exports.string(),
      _pagination_key: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      created: external_exports.string().datetime({ offset: true }),
      org_id: external_exports.string().uuid(),
      project_id: external_exports.string().uuid(),
      log_id: external_exports.literal("g"),
      input: external_exports.unknown().optional(),
      output: external_exports.unknown().optional(),
      expected: external_exports.unknown().optional(),
      error: external_exports.unknown().optional(),
      scores: external_exports.union([external_exports.record(external_exports.union([external_exports.number(), external_exports.null()])), external_exports.null()]).optional(),
      metadata: external_exports.union([
        external_exports.object({ model: external_exports.union([external_exports.string(), external_exports.null()]) }).partial().passthrough(),
        external_exports.null()
      ]).optional(),
      tags: external_exports.union([external_exports.array(external_exports.string()), external_exports.null()]).optional(),
      metrics: external_exports.union([external_exports.record(external_exports.number()), external_exports.null()]).optional(),
      context: external_exports.union([
        external_exports.object({
          caller_functionname: external_exports.union([external_exports.string(), external_exports.null()]),
          caller_filename: external_exports.union([external_exports.string(), external_exports.null()]),
          caller_lineno: external_exports.union([external_exports.number(), external_exports.null()])
        }).partial().passthrough(),
        external_exports.null()
      ]).optional(),
      span_id: external_exports.string(),
      span_parents: external_exports.union([external_exports.array(external_exports.string()), external_exports.null()]).optional(),
      root_span_id: external_exports.string(),
      is_root: external_exports.union([external_exports.boolean(), external_exports.null()]).optional(),
      span_attributes: SpanAttributes.optional(),
      origin: ObjectReferenceNullish.optional()
    });
    ProjectScoreType = external_exports.enum([
      "slider",
      "categorical",
      "weighted",
      "minimum",
      "maximum",
      "online",
      "free-form"
    ]);
    ProjectScoreCategory = external_exports.object({
      name: external_exports.string(),
      value: external_exports.number()
    });
    ProjectScoreCategories = external_exports.union([
      external_exports.array(ProjectScoreCategory),
      external_exports.record(external_exports.number()),
      external_exports.array(external_exports.string()),
      external_exports.null()
    ]);
    ProjectScoreConfig = external_exports.union([
      external_exports.object({
        multi_select: external_exports.union([external_exports.boolean(), external_exports.null()]),
        destination: external_exports.union([external_exports.string(), external_exports.null()]),
        online: OnlineScoreConfig
      }).partial(),
      external_exports.null()
    ]);
    ProjectScore = external_exports.object({
      id: external_exports.string().uuid(),
      project_id: external_exports.string().uuid(),
      user_id: external_exports.string().uuid(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      name: external_exports.string(),
      description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      score_type: ProjectScoreType,
      categories: ProjectScoreCategories.optional(),
      config: ProjectScoreConfig.optional(),
      position: external_exports.union([external_exports.string(), external_exports.null()]).optional()
    });
    ProjectTag = external_exports.object({
      id: external_exports.string().uuid(),
      project_id: external_exports.string().uuid(),
      user_id: external_exports.string().uuid(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      name: external_exports.string(),
      description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      color: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      position: external_exports.union([external_exports.string(), external_exports.null()]).optional()
    });
    Prompt = external_exports.object({
      id: external_exports.string().uuid(),
      _xact_id: external_exports.string(),
      project_id: external_exports.string().uuid(),
      log_id: external_exports.literal("p"),
      org_id: external_exports.string().uuid(),
      name: external_exports.string(),
      slug: external_exports.string(),
      description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      prompt_data: PromptDataNullish.optional(),
      tags: external_exports.union([external_exports.array(external_exports.string()), external_exports.null()]).optional(),
      metadata: external_exports.union([external_exports.object({}).partial().passthrough(), external_exports.null()]).optional(),
      function_type: FunctionTypeEnumNullish.optional()
    });
    PromptOptions = external_exports.object({ model: external_exports.string(), params: ModelParams, position: external_exports.string() }).partial();
    PromptSessionEvent = external_exports.object({
      id: external_exports.string(),
      _xact_id: external_exports.string(),
      created: external_exports.string().datetime({ offset: true }),
      _pagination_key: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      project_id: external_exports.string().uuid(),
      prompt_session_id: external_exports.string().uuid(),
      prompt_session_data: external_exports.unknown().optional(),
      prompt_data: external_exports.unknown().optional(),
      function_data: external_exports.unknown().optional(),
      function_type: FunctionTypeEnumNullish.optional(),
      object_data: external_exports.unknown().optional(),
      completion: external_exports.unknown().optional(),
      tags: external_exports.union([external_exports.array(external_exports.string()), external_exports.null()]).optional()
    });
    ResponseFormat = external_exports.union([
      external_exports.object({ type: external_exports.literal("json_object") }),
      external_exports.object({
        type: external_exports.literal("json_schema"),
        json_schema: ResponseFormatJsonSchema
      }),
      external_exports.object({ type: external_exports.literal("text") })
    ]);
    Role = external_exports.object({
      id: external_exports.string().uuid(),
      org_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      user_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      name: external_exports.string(),
      description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      deleted_at: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      member_permissions: external_exports.union([
        external_exports.array(
          external_exports.object({
            permission: Permission,
            restrict_object_type: AclObjectType.optional()
          })
        ),
        external_exports.null()
      ]).optional(),
      member_roles: external_exports.union([external_exports.array(external_exports.string().uuid()), external_exports.null()]).optional()
    });
    RunEval = external_exports.object({
      project_id: external_exports.string(),
      data: external_exports.union([
        external_exports.object({
          dataset_id: external_exports.string(),
          _internal_btql: external_exports.union([external_exports.object({}).partial().passthrough(), external_exports.null()]).optional()
        }),
        external_exports.object({
          project_name: external_exports.string(),
          dataset_name: external_exports.string(),
          _internal_btql: external_exports.union([external_exports.object({}).partial().passthrough(), external_exports.null()]).optional()
        }),
        external_exports.object({ data: external_exports.array(external_exports.unknown()) })
      ]),
      task: FunctionId.and(external_exports.unknown()),
      scores: external_exports.array(FunctionId),
      experiment_name: external_exports.string().optional(),
      metadata: external_exports.object({}).partial().passthrough().optional(),
      parent: InvokeParent.and(external_exports.unknown()).optional(),
      stream: external_exports.boolean().optional(),
      trial_count: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
      is_public: external_exports.union([external_exports.boolean(), external_exports.null()]).optional(),
      timeout: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
      max_concurrency: external_exports.union([external_exports.number(), external_exports.null()]).optional().default(10),
      base_experiment_name: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      base_experiment_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      git_metadata_settings: GitMetadataSettings.and(
        external_exports.union([external_exports.object({}).partial(), external_exports.null()])
      ).optional(),
      repo_info: RepoInfo.and(external_exports.unknown()).optional(),
      strict: external_exports.union([external_exports.boolean(), external_exports.null()]).optional(),
      stop_token: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      extra_messages: external_exports.string().optional(),
      tags: external_exports.array(external_exports.string()).optional()
    });
    ServiceToken = external_exports.object({
      id: external_exports.string().uuid(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      name: external_exports.string(),
      preview_name: external_exports.string(),
      service_account_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      service_account_email: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      service_account_name: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      org_id: external_exports.union([external_exports.string(), external_exports.null()]).optional()
    });
    SpanIFrame = external_exports.object({
      id: external_exports.string().uuid(),
      project_id: external_exports.string().uuid(),
      user_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      deleted_at: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      name: external_exports.string(),
      description: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      url: external_exports.string(),
      post_message: external_exports.union([external_exports.boolean(), external_exports.null()]).optional()
    });
    SSEConsoleEventData = external_exports.object({
      stream: external_exports.enum(["stderr", "stdout"]),
      message: external_exports.string()
    });
    SSEProgressEventData = external_exports.object({
      id: external_exports.string(),
      object_type: FunctionObjectType,
      origin: ObjectReferenceNullish.and(external_exports.unknown()).optional(),
      format: FunctionFormat,
      output_type: FunctionOutputType,
      name: external_exports.string(),
      event: external_exports.enum([
        "reasoning_delta",
        "text_delta",
        "json_delta",
        "error",
        "console",
        "start",
        "done",
        "progress"
      ]),
      data: external_exports.string()
    });
    ToolFunctionDefinition = external_exports.object({
      type: external_exports.literal("function"),
      function: external_exports.object({
        name: external_exports.string(),
        description: external_exports.string().optional(),
        parameters: external_exports.object({}).partial().passthrough().optional(),
        strict: external_exports.union([external_exports.boolean(), external_exports.null()]).optional()
      })
    });
    User = external_exports.object({
      id: external_exports.string().uuid(),
      given_name: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      family_name: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      email: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      avatar_url: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional()
    });
    ViewDataSearch = external_exports.union([
      external_exports.object({
        filter: external_exports.union([external_exports.array(external_exports.unknown()), external_exports.null()]),
        tag: external_exports.union([external_exports.array(external_exports.unknown()), external_exports.null()]),
        match: external_exports.union([external_exports.array(external_exports.unknown()), external_exports.null()]),
        sort: external_exports.union([external_exports.array(external_exports.unknown()), external_exports.null()])
      }).partial(),
      external_exports.null()
    ]);
    ViewData = external_exports.union([
      external_exports.object({ search: ViewDataSearch }).partial(),
      external_exports.null()
    ]);
    ViewOptions = external_exports.union([
      external_exports.object({
        viewType: external_exports.literal("monitor"),
        options: external_exports.object({
          spanType: external_exports.union([external_exports.enum(["range", "frame"]), external_exports.null()]),
          rangeValue: external_exports.union([external_exports.string(), external_exports.null()]),
          frameStart: external_exports.union([external_exports.string(), external_exports.null()]),
          frameEnd: external_exports.union([external_exports.string(), external_exports.null()]),
          tzUTC: external_exports.union([external_exports.boolean(), external_exports.null()]),
          chartVisibility: external_exports.union([external_exports.record(external_exports.boolean()), external_exports.null()]),
          projectId: external_exports.union([external_exports.string(), external_exports.null()]),
          type: external_exports.union([external_exports.enum(["project", "experiment"]), external_exports.null()]),
          groupBy: external_exports.union([external_exports.string(), external_exports.null()])
        }).partial()
      }),
      external_exports.object({
        columnVisibility: external_exports.union([external_exports.record(external_exports.boolean()), external_exports.null()]),
        columnOrder: external_exports.union([external_exports.array(external_exports.string()), external_exports.null()]),
        columnSizing: external_exports.union([external_exports.record(external_exports.number()), external_exports.null()]),
        grouping: external_exports.union([external_exports.string(), external_exports.null()]),
        rowHeight: external_exports.union([external_exports.string(), external_exports.null()]),
        tallGroupRows: external_exports.union([external_exports.boolean(), external_exports.null()]),
        layout: external_exports.union([external_exports.string(), external_exports.null()]),
        chartHeight: external_exports.union([external_exports.number(), external_exports.null()]),
        excludedMeasures: external_exports.union([
          external_exports.array(
            external_exports.object({
              type: external_exports.enum(["none", "score", "metric", "metadata"]),
              value: external_exports.string()
            })
          ),
          external_exports.null()
        ]),
        yMetric: external_exports.union([
          external_exports.object({
            type: external_exports.enum(["none", "score", "metric", "metadata"]),
            value: external_exports.string()
          }),
          external_exports.null()
        ]),
        xAxis: external_exports.union([
          external_exports.object({
            type: external_exports.enum(["none", "score", "metric", "metadata"]),
            value: external_exports.string()
          }),
          external_exports.null()
        ]),
        symbolGrouping: external_exports.union([
          external_exports.object({
            type: external_exports.enum(["none", "score", "metric", "metadata"]),
            value: external_exports.string()
          }),
          external_exports.null()
        ]),
        xAxisAggregation: external_exports.union([external_exports.string(), external_exports.null()]),
        chartAnnotations: external_exports.union([
          external_exports.array(external_exports.object({ id: external_exports.string(), text: external_exports.string() })),
          external_exports.null()
        ]),
        timeRangeFilter: external_exports.union([
          external_exports.string(),
          external_exports.object({ from: external_exports.string(), to: external_exports.string() }),
          external_exports.null()
        ])
      }).partial(),
      external_exports.null()
    ]);
    View = external_exports.object({
      id: external_exports.string().uuid(),
      object_type: AclObjectType.and(external_exports.string()),
      object_id: external_exports.string().uuid(),
      view_type: external_exports.enum([
        "projects",
        "experiments",
        "experiment",
        "playgrounds",
        "playground",
        "datasets",
        "dataset",
        "prompts",
        "tools",
        "scorers",
        "logs",
        "agents",
        "monitor"
      ]),
      name: external_exports.string(),
      created: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      view_data: ViewData.optional(),
      options: ViewOptions.optional(),
      user_id: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
      deleted_at: external_exports.union([external_exports.string(), external_exports.null()]).optional()
    });
  }
});
function btStreamParser() {
  const decoder = new TextDecoder();
  let parser4;
  return new TransformStream({
    async start(controller) {
      parser4 = createParser((event) => {
        if (event.type === "reconnect-interval") {
          return;
        }
        const parsed = CallEvent.safeParse(event);
        if (!parsed.success) {
          throw new Error(`Failed to parse event: ${parsed.error}`);
        }
        controller.enqueue(BraintrustStream.parseRawEvent(parsed.data));
      });
    },
    async transform(chunk, controller) {
      if (chunk instanceof Uint8Array) {
        parser4.feed(decoder.decode(chunk));
      } else if (typeof chunk === "string") {
        parser4.feed(chunk);
      } else {
        controller.enqueue(chunk);
      }
    },
    async flush(controller) {
      controller.terminate();
    }
  });
}
__name(btStreamParser, "btStreamParser");
function createFinalValuePassThroughStream(onFinal, onError2) {
  const decoder = new TextDecoder();
  const textChunks = [];
  const jsonChunks = [];
  const reasoningChunks = [];
  const transformStream = new TransformStream({
    transform(chunk, controller) {
      if (typeof chunk === "string") {
        textChunks.push(chunk);
        controller.enqueue({
          type: "text_delta",
          data: chunk
        });
      } else if (chunk instanceof Uint8Array) {
        textChunks.push(decoder.decode(chunk));
        controller.enqueue({
          type: "text_delta",
          data: decoder.decode(chunk)
        });
      } else if (braintrustStreamChunkSchema.safeParse(chunk).success) {
        const chunkType = chunk.type;
        switch (chunkType) {
          case "text_delta":
            textChunks.push(chunk.data);
            break;
          case "json_delta":
            jsonChunks.push(chunk.data);
            break;
          case "reasoning_delta":
            reasoningChunks.push(chunk.data);
            break;
          case "error":
            onError2(chunk.data);
            break;
          case "progress":
          case "start":
          case "done":
          case "console":
            break;
          default:
            const _type = chunkType;
            onError2(`Unknown chunk type: ${_type}`);
        }
        controller.enqueue(chunk);
      } else {
        onError2(`Unknown chunk type ${JSON.stringify(chunk)}`);
      }
    },
    flush(controller) {
      if (jsonChunks.length > 0) {
        onFinal(JSON.parse(jsonChunks.join("")));
      } else if (textChunks.length > 0) {
        onFinal(textChunks.join(""));
      } else if (reasoningChunks.length > 0) {
        onFinal(reasoningChunks.join(""));
      } else {
        onFinal(void 0);
      }
      controller.terminate();
    }
  });
  return transformStream;
}
__name(createFinalValuePassThroughStream, "createFinalValuePassThroughStream");
function devNullWritableStream() {
  return new WritableStream({
    write(chunk) {
    },
    close() {
    },
    abort(reason) {
    },
    start(controller) {
    }
  });
}
__name(devNullWritableStream, "devNullWritableStream");
var braintrustStreamChunkSchema;
var BraintrustStream;
var init_stream = __esm3({
  "src/functions/stream.ts"() {
    "use strict";
    init_generated_types();
    braintrustStreamChunkSchema = external_exports.union([
      external_exports.object({
        type: external_exports.literal("text_delta"),
        data: external_exports.string()
      }),
      external_exports.object({
        type: external_exports.literal("reasoning_delta"),
        data: external_exports.string()
      }),
      external_exports.object({
        type: external_exports.literal("json_delta"),
        data: external_exports.string()
      }),
      external_exports.object({
        type: external_exports.literal("error"),
        data: external_exports.string()
      }),
      external_exports.object({
        type: external_exports.literal("console"),
        data: SSEConsoleEventData
      }),
      external_exports.object({
        type: external_exports.literal("progress"),
        data: SSEProgressEventData
      }),
      external_exports.object({
        type: external_exports.literal("start"),
        data: external_exports.string()
      }),
      external_exports.object({
        type: external_exports.literal("done"),
        data: external_exports.string()
      })
    ]);
    BraintrustStream = class _BraintrustStream {
      static {
        __name(this, "_BraintrustStream");
      }
      stream;
      memoizedFinalValue;
      signal;
      constructor(baseStream, { signal } = {}) {
        this.signal = signal;
        this.stream = baseStream.pipeThrough(btStreamParser(), { signal });
      }
      /**
       * Copy the stream. This returns a new stream that shares the same underlying
       * stream (via `tee`). Since streams are consumed in Javascript, use `copy()` if you
       * need to use the stream multiple times.
       *
       * @returns A new stream that you can independently consume.
       */
      copy() {
        const [newStream, copyStream] = this.stream.tee();
        this.stream = copyStream;
        return new _BraintrustStream(newStream, { signal: this.signal });
      }
      /**
       * Get the underlying ReadableStream.
       *
       * @returns The underlying ReadableStream<BraintrustStreamChunk>.
       */
      toReadableStream() {
        return this.stream;
      }
      /**
       * Returns an async iterator for the BraintrustStream.
       * This allows for easy consumption of the stream using a for-await...of loop.
       *
       * @returns An async iterator that yields BraintrustStreamChunk objects.
       */
      [Symbol.asyncIterator]() {
        const reader = this.stream.getReader();
        return {
          async next() {
            const { done, value } = await reader.read();
            if (done) {
              reader.releaseLock();
              return { done: true, value: void 0 };
            }
            return { done: false, value };
          },
          async return() {
            reader.releaseLock();
            return { done: true, value: void 0 };
          },
          async throw(error22) {
            reader.releaseLock();
            throw error22;
          }
        };
      }
      /**
       * Get the final value of the stream. The final value is the concatenation of all
       * the chunks in the stream, deserialized into a string or JSON object, depending on
       * the value's type.
       *
       * This function returns a promise that resolves when the stream is closed, and
       * contains the final value. Multiple calls to `finalValue()` will return the same
       * promise, so it is safe to call this multiple times.
       *
       * This function consumes the stream, so if you need to use the stream multiple
       * times, you should call `copy()` first.
       *
       * @returns A promise that resolves with the final value of the stream or `undefined` if the stream is empty.
       */
      finalValue() {
        if (this.memoizedFinalValue) {
          return this.memoizedFinalValue;
        }
        this.memoizedFinalValue = new Promise((resolve, reject2) => {
          this.stream.pipeThrough(createFinalValuePassThroughStream(resolve, reject2), {
            signal: this.signal
          }).pipeTo(devNullWritableStream(), { signal: this.signal }).catch(reject2);
        });
        return this.memoizedFinalValue;
      }
      static parseRawEvent(event) {
        switch (event.event) {
          case "text_delta":
            return {
              type: "text_delta",
              data: JSON.parse(event.data)
            };
          case "reasoning_delta":
            return {
              type: "reasoning_delta",
              data: JSON.parse(event.data)
            };
          case "json_delta":
            return {
              type: "json_delta",
              data: event.data
            };
          case "error":
            return {
              type: "error",
              data: JSON.parse(event.data)
            };
          case "progress":
            return {
              type: "progress",
              data: SSEProgressEventData.parse(JSON.parse(event.data))
            };
          case "console":
            return {
              type: "console",
              data: SSEConsoleEventData.parse(JSON.parse(event.data))
            };
          case "start":
            return {
              type: "start",
              data: ""
            };
          case "done":
            return {
              type: "done",
              data: ""
            };
          default: {
            const _event = event;
            throw new Error(`Unknown event type ${JSON.stringify(_event)}`);
          }
        }
      }
      static serializeRawEvent(event) {
        switch (event.type) {
          case "text_delta":
            return {
              event: "text_delta",
              data: JSON.stringify(event.data)
            };
          case "reasoning_delta":
            return {
              event: "reasoning_delta",
              data: JSON.stringify(event.data)
            };
          case "json_delta":
            return {
              event: "json_delta",
              data: event.data
            };
          case "error":
            return {
              event: "error",
              data: JSON.stringify(event.data)
            };
          case "progress":
            return {
              event: "progress",
              data: JSON.stringify(event.data)
            };
          case "console":
            return {
              event: "console",
              data: JSON.stringify(event.data)
            };
          case "start":
            return {
              event: "start",
              data: ""
            };
          case "done":
            return {
              event: "done",
              data: ""
            };
          default: {
            const _event = event;
            throw new Error(`Unknown event type ${JSON.stringify(_event)}`);
          }
        }
      }
    };
  }
});
function canUseDiskCache() {
  return !!(isomorph_default.hash && isomorph_default.gunzip && isomorph_default.gzip && isomorph_default.stat && isomorph_default.readFile && isomorph_default.writeFile && isomorph_default.utimes && isomorph_default.readdir && isomorph_default.mkdir && isomorph_default.unlink && isomorph_default.homedir);
}
__name(canUseDiskCache, "canUseDiskCache");
var DiskCache;
var init_disk_cache = __esm3({
  "src/prompt-cache/disk-cache.ts"() {
    "use strict";
    init_isomorph();
    DiskCache = class {
      static {
        __name(this, "DiskCache");
      }
      dir;
      max;
      mkdir;
      logWarnings;
      /**
       * Creates a new DiskCache instance.
       * @param options - Configuration options for the cache.
       */
      constructor(options) {
        if (!canUseDiskCache()) {
          throw new Error("Disk cache is not supported on this platform");
        }
        this.dir = options.cacheDir;
        this.max = options.max;
        this.logWarnings = options.logWarnings ?? true;
        this.mkdir = options.mkdir ?? true;
      }
      getEntryPath(key) {
        const hashed = isomorph_default.hash(key);
        return isomorph_default.pathJoin(this.dir, hashed);
      }
      /**
       * Retrieves a value from the cache.
       * Updates the entry's access time when read.
       *
       * @param key - The key to look up in the cache.
       * @returns The cached value if found, undefined otherwise.
       */
      async get(key) {
        try {
          const filePath = this.getEntryPath(key);
          const data = await isomorph_default.gunzip(await isomorph_default.readFile(filePath));
          await isomorph_default.utimes(filePath, /* @__PURE__ */ new Date(), /* @__PURE__ */ new Date());
          return JSON.parse(data.toString());
        } catch (e) {
          if (e.code === "ENOENT") {
            return void 0;
          }
          if (this.logWarnings) {
            console.warn("Failed to read from disk cache", e);
          }
          return void 0;
        }
      }
      /**
       * Stores a value in the cache.
       * If the cache is at its maximum size, the least recently used entries will be evicted.
       *
       * @param key - The key to store the value under.
       * @param value - The value to store in the cache.
       */
      async set(key, value) {
        try {
          if (this.mkdir) {
            await isomorph_default.mkdir(this.dir, { recursive: true });
          }
          const filePath = this.getEntryPath(key);
          const data = await isomorph_default.gzip(JSON.stringify(value));
          await isomorph_default.writeFile(filePath, data);
          await this.evictOldestIfFull();
        } catch (e) {
          if (this.logWarnings) {
            console.warn("Failed to write to disk cache", e);
          }
          return;
        }
      }
      async evictOldestIfFull() {
        if (!this.max) {
          return;
        }
        const files = await isomorph_default.readdir(this.dir);
        const paths = files.map((file) => isomorph_default.pathJoin(this.dir, file));
        if (paths.length <= this.max) {
          return;
        }
        const stats = await Promise.all(
          paths.map(async (path32) => {
            const stat22 = await isomorph_default.stat(path32);
            return {
              path: path32,
              mtime: stat22.mtime.getTime()
            };
          })
        );
        stats.sort((a, b) => a.mtime - b.mtime);
        const toRemove = stats.slice(0, stats.length - this.max);
        await Promise.all(toRemove.map((stat22) => isomorph_default.unlink(stat22.path)));
      }
    };
  }
});
var LRUCache;
var init_lru_cache = __esm3({
  "src/prompt-cache/lru-cache.ts"() {
    "use strict";
    LRUCache = class {
      static {
        __name(this, "LRUCache");
      }
      cache;
      maxSize;
      constructor(options = {}) {
        this.cache = /* @__PURE__ */ new Map();
        this.maxSize = options.max;
      }
      /**
       * Retrieves a value from the cache.
       * If the key exists, the item is marked as most recently used.
       *
       * @param key - The key to look up.
       * @returns The cached value if found, undefined otherwise.
       */
      get(key) {
        const value = this.cache.get(key);
        if (value === void 0) {
          return void 0;
        }
        this.cache.delete(key);
        this.cache.set(key, value);
        return value;
      }
      /**
       * Stores a value in the cache.
       * If the key already exists, the value is updated and marked as most recently used.
       * If the cache is at its maximum size, the least recently used item is evicted.
       *
       * @param key - The key to store.
       * @param value - The value to store.
       */
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.delete(key);
        } else if (this.maxSize && this.cache.size >= this.maxSize) {
          const first2 = this.cache.keys().next().value;
          this.cache.delete(first2);
        }
        this.cache.set(key, value);
      }
      /**
       * Removes all items from the cache.
       */
      clear() {
        this.cache.clear();
      }
    };
  }
});
function createCacheKey(key) {
  if (key.id) {
    return `id:${key.id}`;
  }
  const prefix = key.projectId ?? key.projectName;
  if (!prefix) {
    throw new Error("Either projectId or projectName must be provided");
  }
  if (!key.slug) {
    throw new Error("Slug must be provided when not using ID");
  }
  return `${prefix}:${key.slug}:${key.version ?? "latest"}`;
}
__name(createCacheKey, "createCacheKey");
var PromptCache;
var init_prompt_cache = __esm3({
  "src/prompt-cache/prompt-cache.ts"() {
    "use strict";
    PromptCache = class {
      static {
        __name(this, "PromptCache");
      }
      memoryCache;
      diskCache;
      constructor(options) {
        this.memoryCache = options.memoryCache;
        this.diskCache = options.diskCache;
      }
      /**
       * Retrieves a prompt from the cache.
       * First checks the in-memory LRU cache, then falls back to checking the disk cache if available.
       */
      async get(key) {
        const cacheKey = createCacheKey(key);
        const memoryPrompt = this.memoryCache.get(cacheKey);
        if (memoryPrompt !== void 0) {
          return memoryPrompt;
        }
        if (this.diskCache) {
          const diskPrompt = await this.diskCache.get(cacheKey);
          if (!diskPrompt) {
            return void 0;
          }
          this.memoryCache.set(cacheKey, diskPrompt);
          return diskPrompt;
        }
        return void 0;
      }
      /**
       * Stores a prompt in the cache.
       * Writes to the in-memory cache and the disk cache if available.
       *
       * @param key - The key to store the value under.
       * @param value - The value to store in the cache.
       * @throws If there is an error writing to the disk cache.
       */
      async set(key, value) {
        const cacheKey = createCacheKey(key);
        this.memoryCache.set(cacheKey, value);
        if (this.diskCache) {
          await this.diskCache.set(cacheKey, value);
        }
      }
    };
  }
});
function runCatchFinally(f, catchF, finallyF) {
  let runSyncCleanup = true;
  try {
    const ret = f();
    if (ret instanceof Promise) {
      runSyncCleanup = false;
      return ret.catch(catchF).finally(finallyF);
    } else {
      return ret;
    }
  } catch (e) {
    return catchF(e);
  } finally {
    if (runSyncCleanup) {
      finallyF();
    }
  }
}
__name(runCatchFinally, "runCatchFinally");
function getCurrentUnixTimestamp() {
  return (/* @__PURE__ */ new Date()).getTime() / 1e3;
}
__name(getCurrentUnixTimestamp, "getCurrentUnixTimestamp");
function isEmpty(a) {
  return a === void 0 || a === null;
}
__name(isEmpty, "isEmpty");
function addAzureBlobHeaders(headers, url) {
  if (url.includes("blob.core.windows.net")) {
    headers["x-ms-blob-type"] = "BlockBlob";
  }
}
__name(addAzureBlobHeaders, "addAzureBlobHeaders");
function filterFrom(record, keys) {
  const out = {};
  for (const k of Object.keys(record)) {
    if (!keys.includes(k)) {
      out[k] = record[k];
    }
  }
  return out;
}
__name(filterFrom, "filterFrom");
function objectIsEmpty(obj) {
  return !obj || Object.keys(obj).length === 0;
}
__name(objectIsEmpty, "objectIsEmpty");
var GLOBAL_PROJECT;
var LazyValue;
var SyncLazyValue;
var InternalAbortError;
var init_util22 = __esm3({
  "src/util.ts"() {
    "use strict";
    GLOBAL_PROJECT = "Global";
    LazyValue = class {
      static {
        __name(this, "LazyValue");
      }
      callable;
      resolvedValue = void 0;
      value = {
        computedState: "uninitialized"
      };
      constructor(callable) {
        this.callable = callable;
      }
      get() {
        if (this.value.computedState !== "uninitialized") {
          return this.value.val;
        }
        this.value = {
          computedState: "in_progress",
          val: this.callable().then((x) => {
            this.value.computedState = "succeeded";
            this.resolvedValue = x;
            return x;
          })
        };
        return this.value.val;
      }
      getSync() {
        return {
          resolved: this.value.computedState === "succeeded",
          value: this.resolvedValue
        };
      }
      // If this is true, the caller should be able to obtain the LazyValue without
      // it throwing.
      get hasSucceeded() {
        return this.value.computedState === "succeeded";
      }
    };
    SyncLazyValue = class {
      static {
        __name(this, "SyncLazyValue");
      }
      callable;
      value = {
        computedState: "uninitialized"
      };
      constructor(callable) {
        this.callable = callable;
      }
      get() {
        if (this.value.computedState !== "uninitialized") {
          return this.value.val;
        }
        const result = this.callable();
        this.value = { computedState: "succeeded", val: result };
        return result;
      }
      // If this is true, the caller should be able to obtain the SyncLazyValue without
      // it throwing.
      get hasSucceeded() {
        return this.value.computedState === "succeeded";
      }
    };
    InternalAbortError = class extends Error {
      static {
        __name(this, "InternalAbortError");
      }
      constructor(message) {
        super(message);
        this.name = "InternalAbortError";
      }
    };
  }
});
function lintTemplate(template, context22) {
  const variables = getMustacheVars(template);
  for (const variable of variables) {
    const arrPathsReplaced = variable[1].replaceAll(/\.\d+/g, ".0");
    const fieldExists = getObjValueByPath(context22, arrPathsReplaced.split(".")) !== void 0;
    if (!fieldExists) {
      throw new Error(`Variable '${variable[1]}' does not exist.`);
    }
  }
}
__name(lintTemplate, "lintTemplate");
function getMustacheVars(prompt) {
  try {
    return mustache_default.parse(prompt).filter(
      (span) => span[0] === "name" || span[0] === "&"
    );
  } catch {
    return [];
  }
}
__name(getMustacheVars, "getMustacheVars");
var init_mustache_utils = __esm3({
  "src/mustache-utils.ts"() {
    "use strict";
    init_util2();
  }
});
var _globalThis;
var init_globalThis = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js"() {
    "use strict";
    _globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});
var init_node = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/platform/node/index.js"() {
    "use strict";
    init_globalThis();
  }
});
var init_platform = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/platform/index.js"() {
    "use strict";
    init_node();
  }
});
var VERSION;
var init_version2 = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/version.js"() {
    "use strict";
    VERSION = "1.9.0";
  }
});
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return /* @__PURE__ */ __name(function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    }, "isExactmatch");
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  __name(_reject, "_reject");
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  __name(_accept, "_accept");
  return /* @__PURE__ */ __name(function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  }, "isCompatible2");
}
__name(_makeCompatibilityCheck, "_makeCompatibilityCheck");
var re;
var isCompatible;
var init_semver = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/internal/semver.js"() {
    "use strict";
    init_version2();
    re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    isCompatible = _makeCompatibilityCheck(VERSION);
  }
});
function registerGlobal(type, instance, diag3, allowOverride) {
  var _a4;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a4 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a4 !== void 0 ? _a4 : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag3.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag3.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
__name(registerGlobal, "registerGlobal");
function getGlobal(type) {
  var _a4, _b;
  var globalVersion = (_a4 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a4 === void 0 ? void 0 : _a4.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
__name(getGlobal, "getGlobal");
function unregisterGlobal(type, diag3) {
  diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}
__name(unregisterGlobal, "unregisterGlobal");
var major;
var GLOBAL_OPENTELEMETRY_API_KEY;
var _global;
var init_global_utils = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/internal/global-utils.js"() {
    "use strict";
    init_platform();
    init_version2();
    init_semver();
    major = VERSION.split(".")[0];
    GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    _global = _globalThis;
  }
});
function logProxy(funcName, namespace, args) {
  var logger = getGlobal("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
}
__name(logProxy, "logProxy");
var __read;
var __spreadArray;
var DiagComponentLogger;
var init_ComponentLogger = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js"() {
    "use strict";
    init_global_utils();
    __read = /* @__PURE__ */ __name(function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error22) {
        e = { error: error22 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    }, "__read");
    __spreadArray = /* @__PURE__ */ __name(function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    }, "__spreadArray");
    DiagComponentLogger = /** @class */
    function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      __name(DiagComponentLogger2, "DiagComponentLogger2");
      DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
      };
      return DiagComponentLogger2;
    }();
  }
});
var DiagLogLevel;
var init_types = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/diag/types.js"() {
    "use strict";
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
  }
});
function createLogLevelDiagLogger(maxLevel, logger) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  __name(_filterFunc, "_filterFunc");
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
__name(createLogLevelDiagLogger, "createLogLevelDiagLogger");
var init_logLevelLogger = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js"() {
    "use strict";
    init_types();
  }
});
var __read2;
var __spreadArray2;
var API_NAME;
var DiagAPI;
var init_diag = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/api/diag.js"() {
    "use strict";
    init_ComponentLogger();
    init_logLevelLogger();
    init_types();
    init_global_utils();
    __read2 = /* @__PURE__ */ __name(function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error22) {
        e = { error: error22 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    }, "__read2");
    __spreadArray2 = /* @__PURE__ */ __name(function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    }, "__spreadArray2");
    API_NAME = "diag";
    DiagAPI = /** @class */
    function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger = getGlobal("diag");
            if (!logger)
              return;
            return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));
          };
        }
        __name(_logProxy, "_logProxy");
        var self = this;
        var setLogger = /* @__PURE__ */ __name(function(logger, optionsOrLogLevel) {
          var _a4, _b, _c;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
          }
          if (logger === self) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self.error((_a4 = err.stack) !== null && _a4 !== void 0 ? _a4 : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self, true);
        }, "setLogger");
        self.setLogger = setLogger;
        self.disable = function() {
          unregisterGlobal(API_NAME, self);
        };
        self.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy("verbose");
        self.debug = _logProxy("debug");
        self.info = _logProxy("info");
        self.warn = _logProxy("warn");
        self.error = _logProxy("error");
      }
      __name(DiagAPI2, "DiagAPI2");
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    }();
  }
});
var __read3;
var __values;
var BaggageImpl;
var init_baggage_impl = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js"() {
    "use strict";
    __read3 = /* @__PURE__ */ __name(function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error22) {
        e = { error: error22 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    }, "__read3");
    __values = /* @__PURE__ */ __name(function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: /* @__PURE__ */ __name(function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }, "next")
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }, "__values");
    BaggageImpl = /** @class */
    function() {
      function BaggageImpl2(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      __name(BaggageImpl2, "BaggageImpl2");
      BaggageImpl2.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      };
      BaggageImpl2.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a4) {
          var _b = __read3(_a4, 2), k = _b[0], v = _b[1];
          return [k, v];
        });
      };
      BaggageImpl2.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntries = function() {
        var e_1, _a4;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl2(this._entries);
        try {
          for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            newBaggage._entries.delete(key);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (keys_1_1 && !keys_1_1.done && (_a4 = keys_1.return)) _a4.call(keys_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return newBaggage;
      };
      BaggageImpl2.prototype.clear = function() {
        return new BaggageImpl2();
      };
      return BaggageImpl2;
    }();
  }
});
var baggageEntryMetadataSymbol;
var init_symbol = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js"() {
    "use strict";
    baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}
__name(createBaggage, "createBaggage");
function baggageEntryMetadataFromString(str2) {
  if (typeof str2 !== "string") {
    diag.error("Cannot create baggage metadata from unknown type: " + typeof str2);
    str2 = "";
  }
  return {
    __TYPE__: baggageEntryMetadataSymbol,
    toString: /* @__PURE__ */ __name(function() {
      return str2;
    }, "toString")
  };
}
__name(baggageEntryMetadataFromString, "baggageEntryMetadataFromString");
var diag;
var init_utils3 = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/baggage/utils.js"() {
    "use strict";
    init_diag();
    init_baggage_impl();
    init_symbol();
    diag = DiagAPI.instance();
  }
});
function createContextKey(description) {
  return Symbol.for(description);
}
__name(createContextKey, "createContextKey");
var BaseContext;
var ROOT_CONTEXT;
var init_context = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/context/context.js"() {
    "use strict";
    BaseContext = /** @class */
    /* @__PURE__ */ function() {
      function BaseContext2(parentContext) {
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self.getValue = function(key) {
          return self._currentContext.get(key);
        };
        self.setValue = function(key, value) {
          var context22 = new BaseContext2(self._currentContext);
          context22._currentContext.set(key, value);
          return context22;
        };
        self.deleteValue = function(key) {
          var context22 = new BaseContext2(self._currentContext);
          context22._currentContext.delete(key);
          return context22;
        };
      }
      __name(BaseContext2, "BaseContext2");
      return BaseContext2;
    }();
    ROOT_CONTEXT = new BaseContext();
  }
});
var consoleMap;
var DiagConsoleLogger;
var init_consoleLogger = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js"() {
    "use strict";
    consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    DiagConsoleLogger = /** @class */
    /* @__PURE__ */ function() {
      function DiagConsoleLogger2() {
        function _consoleFunc(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (console) {
              var theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        __name(_consoleFunc, "_consoleFunc");
        for (var i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
      __name(DiagConsoleLogger2, "DiagConsoleLogger2");
      return DiagConsoleLogger2;
    }();
  }
});
function createNoopMeter() {
  return NOOP_METER;
}
__name(createNoopMeter, "createNoopMeter");
var __extends;
var NoopMeter;
var NoopMetric;
var NoopCounterMetric;
var NoopUpDownCounterMetric;
var NoopGaugeMetric;
var NoopHistogramMetric;
var NoopObservableMetric;
var NoopObservableCounterMetric;
var NoopObservableGaugeMetric;
var NoopObservableUpDownCounterMetric;
var NOOP_METER;
var NOOP_COUNTER_METRIC;
var NOOP_GAUGE_METRIC;
var NOOP_HISTOGRAM_METRIC;
var NOOP_UP_DOWN_COUNTER_METRIC;
var NOOP_OBSERVABLE_COUNTER_METRIC;
var NOOP_OBSERVABLE_GAUGE_METRIC;
var NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
var init_NoopMeter = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js"() {
    "use strict";
    __extends = /* @__PURE__ */ function() {
      var extendStatics = /* @__PURE__ */ __name(function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      }, "extendStatics");
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        __name(__, "__");
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    NoopMeter = /** @class */
    function() {
      function NoopMeter2() {
      }
      __name(NoopMeter2, "NoopMeter2");
      NoopMeter2.prototype.createGauge = function(_name, _options) {
        return NOOP_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createHistogram = function(_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
      };
      NoopMeter2.prototype.createCounter = function(_name, _options) {
        return NOOP_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
      };
      NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
      };
      return NoopMeter2;
    }();
    NoopMetric = /** @class */
    /* @__PURE__ */ function() {
      function NoopMetric2() {
      }
      __name(NoopMetric2, "NoopMetric2");
      return NoopMetric2;
    }();
    NoopCounterMetric = /** @class */
    function(_super) {
      __extends(NoopCounterMetric2, _super);
      function NoopCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(NoopCounterMetric2, "NoopCounterMetric2");
      NoopCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopCounterMetric2;
    }(NoopMetric);
    NoopUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopUpDownCounterMetric2, _super);
      function NoopUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(NoopUpDownCounterMetric2, "NoopUpDownCounterMetric2");
      NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopUpDownCounterMetric2;
    }(NoopMetric);
    NoopGaugeMetric = /** @class */
    function(_super) {
      __extends(NoopGaugeMetric2, _super);
      function NoopGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(NoopGaugeMetric2, "NoopGaugeMetric2");
      NoopGaugeMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopGaugeMetric2;
    }(NoopMetric);
    NoopHistogramMetric = /** @class */
    function(_super) {
      __extends(NoopHistogramMetric2, _super);
      function NoopHistogramMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(NoopHistogramMetric2, "NoopHistogramMetric2");
      NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopHistogramMetric2;
    }(NoopMetric);
    NoopObservableMetric = /** @class */
    function() {
      function NoopObservableMetric2() {
      }
      __name(NoopObservableMetric2, "NoopObservableMetric2");
      NoopObservableMetric2.prototype.addCallback = function(_callback) {
      };
      NoopObservableMetric2.prototype.removeCallback = function(_callback) {
      };
      return NoopObservableMetric2;
    }();
    NoopObservableCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableCounterMetric2, _super);
      function NoopObservableCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(NoopObservableCounterMetric2, "NoopObservableCounterMetric2");
      return NoopObservableCounterMetric2;
    }(NoopObservableMetric);
    NoopObservableGaugeMetric = /** @class */
    function(_super) {
      __extends(NoopObservableGaugeMetric2, _super);
      function NoopObservableGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(NoopObservableGaugeMetric2, "NoopObservableGaugeMetric2");
      return NoopObservableGaugeMetric2;
    }(NoopObservableMetric);
    NoopObservableUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableUpDownCounterMetric2, _super);
      function NoopObservableUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(NoopObservableUpDownCounterMetric2, "NoopObservableUpDownCounterMetric2");
      return NoopObservableUpDownCounterMetric2;
    }(NoopObservableMetric);
    NOOP_METER = new NoopMeter();
    NOOP_COUNTER_METRIC = new NoopCounterMetric();
    NOOP_GAUGE_METRIC = new NoopGaugeMetric();
    NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
  }
});
var ValueType;
var init_Metric = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/metrics/Metric.js"() {
    "use strict";
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType || (ValueType = {}));
  }
});
var defaultTextMapGetter;
var defaultTextMapSetter;
var init_TextMapPropagator = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js"() {
    "use strict";
    defaultTextMapGetter = {
      get: /* @__PURE__ */ __name(function(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      }, "get"),
      keys: /* @__PURE__ */ __name(function(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }, "keys")
    };
    defaultTextMapSetter = {
      set: /* @__PURE__ */ __name(function(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }, "set")
    };
  }
});
var __read4;
var __spreadArray3;
var NoopContextManager;
var init_NoopContextManager = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js"() {
    "use strict";
    init_context();
    __read4 = /* @__PURE__ */ __name(function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error22) {
        e = { error: error22 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    }, "__read4");
    __spreadArray3 = /* @__PURE__ */ __name(function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    }, "__spreadArray3");
    NoopContextManager = /** @class */
    function() {
      function NoopContextManager2() {
      }
      __name(NoopContextManager2, "NoopContextManager2");
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray3([thisArg], __read4(args), false));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    }();
  }
});
var __read5;
var __spreadArray4;
var API_NAME2;
var NOOP_CONTEXT_MANAGER;
var ContextAPI;
var init_context2 = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/api/context.js"() {
    "use strict";
    init_NoopContextManager();
    init_global_utils();
    init_diag();
    __read5 = /* @__PURE__ */ __name(function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error22) {
        e = { error: error22 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    }, "__read5");
    __spreadArray4 = /* @__PURE__ */ __name(function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    }, "__spreadArray4");
    API_NAME2 = "context";
    NOOP_CONTEXT_MANAGER = new NoopContextManager();
    ContextAPI = /** @class */
    function() {
      function ContextAPI2() {
      }
      __name(ContextAPI2, "ContextAPI2");
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context22, fn, thisArg) {
        var _a4;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a4 = this._getContextManager()).with.apply(_a4, __spreadArray4([context22, fn, thisArg], __read5(args), false));
      };
      ContextAPI2.prototype.bind = function(context22, target) {
        return this._getContextManager().bind(context22, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
      };
      return ContextAPI2;
    }();
  }
});
var TraceFlags;
var init_trace_flags = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js"() {
    "use strict";
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
  }
});
var INVALID_SPANID;
var INVALID_TRACEID;
var INVALID_SPAN_CONTEXT;
var init_invalid_span_constants = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js"() {
    "use strict";
    init_trace_flags();
    INVALID_SPANID = "0000000000000000";
    INVALID_TRACEID = "00000000000000000000000000000000";
    INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
  }
});
var NonRecordingSpan;
var init_NonRecordingSpan = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js"() {
    "use strict";
    init_invalid_span_constants();
    NonRecordingSpan = /** @class */
    function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      __name(NonRecordingSpan2, "NonRecordingSpan2");
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addLink = function(_link) {
        return this;
      };
      NonRecordingSpan2.prototype.addLinks = function(_links) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    }();
  }
});
function getSpan(context22) {
  return context22.getValue(SPAN_KEY) || void 0;
}
__name(getSpan, "getSpan");
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
__name(getActiveSpan, "getActiveSpan");
function setSpan(context22, span) {
  return context22.setValue(SPAN_KEY, span);
}
__name(setSpan, "setSpan");
function deleteSpan(context22) {
  return context22.deleteValue(SPAN_KEY);
}
__name(deleteSpan, "deleteSpan");
function setSpanContext(context22, spanContext) {
  return setSpan(context22, new NonRecordingSpan(spanContext));
}
__name(setSpanContext, "setSpanContext");
function getSpanContext(context22) {
  var _a4;
  return (_a4 = getSpan(context22)) === null || _a4 === void 0 ? void 0 : _a4.spanContext();
}
__name(getSpanContext, "getSpanContext");
var SPAN_KEY;
var init_context_utils = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace/context-utils.js"() {
    "use strict";
    init_context();
    init_NonRecordingSpan();
    init_context2();
    SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
  }
});
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
__name(isValidTraceId, "isValidTraceId");
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
__name(isValidSpanId, "isValidSpanId");
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
__name(isSpanContextValid, "isSpanContextValid");
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
__name(wrapSpanContext, "wrapSpanContext");
var VALID_TRACEID_REGEX;
var VALID_SPANID_REGEX;
var init_spancontext_utils = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js"() {
    "use strict";
    init_invalid_span_constants();
    init_NonRecordingSpan();
    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  }
});
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
__name(isSpanContext, "isSpanContext");
var contextApi;
var NoopTracer;
var init_NoopTracer = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js"() {
    "use strict";
    init_context2();
    init_context_utils();
    init_NonRecordingSpan();
    init_spancontext_utils();
    contextApi = ContextAPI.getInstance();
    NoopTracer = /** @class */
    function() {
      function NoopTracer2() {
      }
      __name(NoopTracer2, "NoopTracer2");
      NoopTracer2.prototype.startSpan = function(name, options, context22) {
        if (context22 === void 0) {
          context22 = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context22 && getSpanContext(context22);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    }();
  }
});
var NOOP_TRACER;
var ProxyTracer;
var init_ProxyTracer = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js"() {
    "use strict";
    init_NoopTracer();
    NOOP_TRACER = new NoopTracer();
    ProxyTracer = /** @class */
    function() {
      function ProxyTracer2(_provider, name, version2, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version2;
        this.options = options;
      }
      __name(ProxyTracer2, "ProxyTracer2");
      ProxyTracer2.prototype.startSpan = function(name, options, context22) {
        return this._getTracer().startSpan(name, options, context22);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      };
      return ProxyTracer2;
    }();
  }
});
var NoopTracerProvider;
var init_NoopTracerProvider = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js"() {
    "use strict";
    init_NoopTracer();
    NoopTracerProvider = /** @class */
    function() {
      function NoopTracerProvider2() {
      }
      __name(NoopTracerProvider2, "NoopTracerProvider2");
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    }();
  }
});
var NOOP_TRACER_PROVIDER;
var ProxyTracerProvider;
var init_ProxyTracerProvider = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js"() {
    "use strict";
    init_ProxyTracer();
    init_NoopTracerProvider();
    NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    ProxyTracerProvider = /** @class */
    function() {
      function ProxyTracerProvider2() {
      }
      __name(ProxyTracerProvider2, "ProxyTracerProvider2");
      ProxyTracerProvider2.prototype.getTracer = function(name, version2, options) {
        var _a4;
        return (_a4 = this.getDelegateTracer(name, version2, options)) !== null && _a4 !== void 0 ? _a4 : new ProxyTracer(this, name, version2, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a4;
        return (_a4 = this._delegate) !== null && _a4 !== void 0 ? _a4 : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version2, options) {
        var _a4;
        return (_a4 = this._delegate) === null || _a4 === void 0 ? void 0 : _a4.getTracer(name, version2, options);
      };
      return ProxyTracerProvider2;
    }();
  }
});
var SamplingDecision;
var init_SamplingResult = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js"() {
    "use strict";
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));
  }
});
var SpanKind;
var init_span_kind = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace/span_kind.js"() {
    "use strict";
    (function(SpanKind2) {
      SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
      SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
      SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
      SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
      SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));
  }
});
var SpanStatusCode;
var init_status2 = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace/status.js"() {
    "use strict";
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
      SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
      SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
  }
});
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
__name(validateKey, "validateKey");
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}
__name(validateValue, "validateValue");
var VALID_KEY_CHAR_RANGE;
var VALID_KEY;
var VALID_VENDOR_KEY;
var VALID_KEY_REGEX;
var VALID_VALUE_BASE_REGEX;
var INVALID_VALUE_COMMA_EQUAL_REGEX;
var init_tracestate_validators = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js"() {
    "use strict";
    VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
    VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
    VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
    VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  }
});
var MAX_TRACE_STATE_ITEMS;
var MAX_TRACE_STATE_LEN;
var LIST_MEMBERS_SEPARATOR;
var LIST_MEMBER_KEY_VALUE_SPLITTER;
var TraceStateImpl;
var init_tracestate_impl = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js"() {
    "use strict";
    init_tracestate_validators();
    MAX_TRACE_STATE_ITEMS = 32;
    MAX_TRACE_STATE_LEN = 512;
    LIST_MEMBERS_SEPARATOR = ",";
    LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    TraceStateImpl = /** @class */
    function() {
      function TraceStateImpl2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      __name(TraceStateImpl2, "TraceStateImpl2");
      TraceStateImpl2.prototype.set = function(key, value) {
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceStateImpl2.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceStateImpl2.prototype.get = function(key) {
        return this._internalState.get(key);
      };
      TraceStateImpl2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      };
      TraceStateImpl2.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
          var listMember = part.trim();
          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            var key = listMember.slice(0, i);
            var value = listMember.slice(i + 1, part.length);
            if (validateKey(key) && validateValue(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      };
      TraceStateImpl2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceStateImpl2.prototype._clone = function() {
        var traceState = new TraceStateImpl2();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceStateImpl2;
    }();
  }
});
function createTraceState(rawTraceState) {
  return new TraceStateImpl(rawTraceState);
}
__name(createTraceState, "createTraceState");
var init_utils22 = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js"() {
    "use strict";
    init_tracestate_impl();
  }
});
var context2;
var init_context_api = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/context-api.js"() {
    "use strict";
    init_context2();
    context2 = ContextAPI.getInstance();
  }
});
var diag2;
var init_diag_api = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/diag-api.js"() {
    "use strict";
    init_diag();
    diag2 = DiagAPI.instance();
  }
});
var NoopMeterProvider;
var NOOP_METER_PROVIDER;
var init_NoopMeterProvider = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js"() {
    "use strict";
    init_NoopMeter();
    NoopMeterProvider = /** @class */
    function() {
      function NoopMeterProvider2() {
      }
      __name(NoopMeterProvider2, "NoopMeterProvider2");
      NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
        return NOOP_METER;
      };
      return NoopMeterProvider2;
    }();
    NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});
var API_NAME3;
var MetricsAPI;
var init_metrics = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/api/metrics.js"() {
    "use strict";
    init_NoopMeterProvider();
    init_global_utils();
    init_diag();
    API_NAME3 = "metrics";
    MetricsAPI = /** @class */
    function() {
      function MetricsAPI2() {
      }
      __name(MetricsAPI2, "MetricsAPI2");
      MetricsAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new MetricsAPI2();
        }
        return this._instance;
      };
      MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
        return registerGlobal(API_NAME3, provider, DiagAPI.instance());
      };
      MetricsAPI2.prototype.getMeterProvider = function() {
        return getGlobal(API_NAME3) || NOOP_METER_PROVIDER;
      };
      MetricsAPI2.prototype.getMeter = function(name, version2, options) {
        return this.getMeterProvider().getMeter(name, version2, options);
      };
      MetricsAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
      };
      return MetricsAPI2;
    }();
  }
});
var metrics;
var init_metrics_api = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/metrics-api.js"() {
    "use strict";
    init_metrics();
    metrics = MetricsAPI.getInstance();
  }
});
var NoopTextMapPropagator;
var init_NoopTextMapPropagator = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js"() {
    "use strict";
    NoopTextMapPropagator = /** @class */
    function() {
      function NoopTextMapPropagator2() {
      }
      __name(NoopTextMapPropagator2, "NoopTextMapPropagator2");
      NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
      };
      NoopTextMapPropagator2.prototype.extract = function(context22, _carrier) {
        return context22;
      };
      NoopTextMapPropagator2.prototype.fields = function() {
        return [];
      };
      return NoopTextMapPropagator2;
    }();
  }
});
function getBaggage(context22) {
  return context22.getValue(BAGGAGE_KEY) || void 0;
}
__name(getBaggage, "getBaggage");
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
__name(getActiveBaggage, "getActiveBaggage");
function setBaggage(context22, baggage) {
  return context22.setValue(BAGGAGE_KEY, baggage);
}
__name(setBaggage, "setBaggage");
function deleteBaggage(context22) {
  return context22.deleteValue(BAGGAGE_KEY);
}
__name(deleteBaggage, "deleteBaggage");
var BAGGAGE_KEY;
var init_context_helpers = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js"() {
    "use strict";
    init_context2();
    init_context();
    BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
  }
});
var API_NAME4;
var NOOP_TEXT_MAP_PROPAGATOR;
var PropagationAPI;
var init_propagation = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/api/propagation.js"() {
    "use strict";
    init_global_utils();
    init_NoopTextMapPropagator();
    init_TextMapPropagator();
    init_context_helpers();
    init_utils3();
    init_diag();
    API_NAME4 = "propagation";
    NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
    PropagationAPI = /** @class */
    function() {
      function PropagationAPI2() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
      }
      __name(PropagationAPI2, "PropagationAPI2");
      PropagationAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new PropagationAPI2();
        }
        return this._instance;
      };
      PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
        return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
      };
      PropagationAPI2.prototype.inject = function(context22, carrier, setter) {
        if (setter === void 0) {
          setter = defaultTextMapSetter;
        }
        return this._getGlobalPropagator().inject(context22, carrier, setter);
      };
      PropagationAPI2.prototype.extract = function(context22, carrier, getter) {
        if (getter === void 0) {
          getter = defaultTextMapGetter;
        }
        return this._getGlobalPropagator().extract(context22, carrier, getter);
      };
      PropagationAPI2.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      };
      PropagationAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME4, DiagAPI.instance());
      };
      PropagationAPI2.prototype._getGlobalPropagator = function() {
        return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
      };
      return PropagationAPI2;
    }();
  }
});
var propagation;
var init_propagation_api = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/propagation-api.js"() {
    "use strict";
    init_propagation();
    propagation = PropagationAPI.getInstance();
  }
});
var API_NAME5;
var TraceAPI;
var init_trace = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/api/trace.js"() {
    "use strict";
    init_global_utils();
    init_ProxyTracerProvider();
    init_spancontext_utils();
    init_context_utils();
    init_diag();
    API_NAME5 = "trace";
    TraceAPI = /** @class */
    function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      __name(TraceAPI2, "TraceAPI2");
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME5, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME5) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name, version2) {
        return this.getTracerProvider().getTracer(name, version2);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME5, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    }();
  }
});
var trace3;
var init_trace_api = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/trace-api.js"() {
    "use strict";
    init_trace();
    trace3 = TraceAPI.getInstance();
  }
});
var esm_exports = {};
__export3(esm_exports, {
  DiagConsoleLogger: /* @__PURE__ */ __name(() => DiagConsoleLogger, "DiagConsoleLogger"),
  DiagLogLevel: /* @__PURE__ */ __name(() => DiagLogLevel, "DiagLogLevel"),
  INVALID_SPANID: /* @__PURE__ */ __name(() => INVALID_SPANID, "INVALID_SPANID"),
  INVALID_SPAN_CONTEXT: /* @__PURE__ */ __name(() => INVALID_SPAN_CONTEXT, "INVALID_SPAN_CONTEXT"),
  INVALID_TRACEID: /* @__PURE__ */ __name(() => INVALID_TRACEID, "INVALID_TRACEID"),
  ProxyTracer: /* @__PURE__ */ __name(() => ProxyTracer, "ProxyTracer"),
  ProxyTracerProvider: /* @__PURE__ */ __name(() => ProxyTracerProvider, "ProxyTracerProvider"),
  ROOT_CONTEXT: /* @__PURE__ */ __name(() => ROOT_CONTEXT, "ROOT_CONTEXT"),
  SamplingDecision: /* @__PURE__ */ __name(() => SamplingDecision, "SamplingDecision"),
  SpanKind: /* @__PURE__ */ __name(() => SpanKind, "SpanKind"),
  SpanStatusCode: /* @__PURE__ */ __name(() => SpanStatusCode, "SpanStatusCode"),
  TraceFlags: /* @__PURE__ */ __name(() => TraceFlags, "TraceFlags"),
  ValueType: /* @__PURE__ */ __name(() => ValueType, "ValueType"),
  baggageEntryMetadataFromString: /* @__PURE__ */ __name(() => baggageEntryMetadataFromString, "baggageEntryMetadataFromString"),
  context: /* @__PURE__ */ __name(() => context2, "context"),
  createContextKey: /* @__PURE__ */ __name(() => createContextKey, "createContextKey"),
  createNoopMeter: /* @__PURE__ */ __name(() => createNoopMeter, "createNoopMeter"),
  createTraceState: /* @__PURE__ */ __name(() => createTraceState, "createTraceState"),
  default: /* @__PURE__ */ __name(() => esm_default, "default"),
  defaultTextMapGetter: /* @__PURE__ */ __name(() => defaultTextMapGetter, "defaultTextMapGetter"),
  defaultTextMapSetter: /* @__PURE__ */ __name(() => defaultTextMapSetter, "defaultTextMapSetter"),
  diag: /* @__PURE__ */ __name(() => diag2, "diag"),
  isSpanContextValid: /* @__PURE__ */ __name(() => isSpanContextValid, "isSpanContextValid"),
  isValidSpanId: /* @__PURE__ */ __name(() => isValidSpanId, "isValidSpanId"),
  isValidTraceId: /* @__PURE__ */ __name(() => isValidTraceId, "isValidTraceId"),
  metrics: /* @__PURE__ */ __name(() => metrics, "metrics"),
  propagation: /* @__PURE__ */ __name(() => propagation, "propagation"),
  trace: /* @__PURE__ */ __name(() => trace3, "trace")
});
var esm_default;
var init_esm = __esm3({
  "../node_modules/@opentelemetry/api/build/esm/index.js"() {
    "use strict";
    init_utils3();
    init_context();
    init_consoleLogger();
    init_types();
    init_NoopMeter();
    init_Metric();
    init_TextMapPropagator();
    init_ProxyTracer();
    init_ProxyTracerProvider();
    init_SamplingResult();
    init_span_kind();
    init_status2();
    init_trace_flags();
    init_utils22();
    init_spancontext_utils();
    init_invalid_span_constants();
    init_context_api();
    init_diag_api();
    init_metrics_api();
    init_propagation_api();
    init_trace_api();
    esm_default = {
      context: context2,
      diag: diag2,
      metrics,
      propagation,
      trace: trace3
    };
  }
});
var context_exports = {};
__export3(context_exports, {
  OtelContextManager: /* @__PURE__ */ __name(() => OtelContextManager, "OtelContextManager")
});
function isOtelSpan(span) {
  return typeof span === "object" && span !== null && "spanContext" in span && // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Type guard ensures object has property
  typeof span.spanContext === "function";
}
__name(isOtelSpan, "isOtelSpan");
function isValidSpanContext(spanContext) {
  if (!spanContext || typeof spanContext !== "object" || !("spanId" in spanContext) || !("traceId" in spanContext)) {
    return false;
  }
  const ctx = spanContext;
  return ctx.spanId !== "0000000000000000" && ctx.traceId !== "00000000000000000000000000000000";
}
__name(isValidSpanContext, "isValidSpanContext");
var OTEL_NOT_INSTALLED_MESSAGE;
var otelTrace;
var otelContext;
var OTEL_AVAILABLE;
var OtelContextManager;
var init_context3 = __esm3({
  "src/otel/context.ts"() {
    "use strict";
    init_logger();
    OTEL_NOT_INSTALLED_MESSAGE = "OpenTelemetry packages are not installed. Install them with: npm install @opentelemetry/api @opentelemetry/sdk-trace-base";
    otelTrace = null;
    otelContext = null;
    OTEL_AVAILABLE = false;
    try {
      const otelApi2 = (init_esm(), __toCommonJS2(esm_exports));
      otelTrace = otelApi2.trace;
      otelContext = otelApi2.context;
      OTEL_AVAILABLE = true;
    } catch {
      console.warn(OTEL_NOT_INSTALLED_MESSAGE);
      OTEL_AVAILABLE = false;
    }
    OtelContextManager = class extends ContextManager {
      static {
        __name(this, "OtelContextManager");
      }
      constructor() {
        super();
        if (!OTEL_AVAILABLE) {
          throw new Error(OTEL_NOT_INSTALLED_MESSAGE);
        }
      }
      getParentSpanIds() {
        if (!OTEL_AVAILABLE || !otelTrace || !otelContext) return void 0;
        const currentSpan2 = otelTrace.getActiveSpan();
        if (!currentSpan2 || !isOtelSpan(currentSpan2)) {
          return void 0;
        }
        const spanContext = currentSpan2.spanContext();
        if (!isValidSpanContext(spanContext)) {
          return void 0;
        }
        const btSpan = otelContext?.active().getValue?.("braintrust_span");
        if (btSpan && currentSpan2.constructor.name === "NonRecordingSpan" && typeof btSpan === "object" && btSpan !== null && "rootSpanId" in btSpan && "spanId" in btSpan) {
          const typedBtSpan = btSpan;
          return {
            rootSpanId: typedBtSpan.rootSpanId,
            spanParents: [typedBtSpan.spanId]
          };
        }
        const otelTraceId = spanContext.traceId.toString().padStart(32, "0");
        const otelSpanId = spanContext.spanId.toString().padStart(16, "0");
        return {
          rootSpanId: otelTraceId,
          spanParents: [otelSpanId]
        };
      }
      runInContext(span, callback) {
        if (!OTEL_AVAILABLE || !otelTrace || !otelContext) {
          return callback();
        }
        try {
          if (typeof span === "object" && span !== null && "spanId" in span && "rootSpanId" in span) {
            const btSpan = span;
            const spanContext = {
              traceId: btSpan.rootSpanId,
              spanId: btSpan.spanId,
              traceFlags: 1
              // sampled
            };
            const wrappedContext = otelTrace.wrapSpanContext(spanContext);
            const currentContext = otelContext.active();
            let newContext = otelTrace.setSpan(currentContext, wrappedContext);
            newContext = newContext.setValue("braintrust_span", span);
            const parentValue = span._getOtelParent();
            if (parentValue) {
              newContext = newContext.setValue("braintrust.parent", parentValue);
            }
            return otelContext.with(newContext, callback);
          }
        } catch (error22) {
          console.warn("Failed to run in OTEL context:", error22);
        }
        return callback();
      }
      getCurrentSpan() {
        if (!OTEL_AVAILABLE || !otelContext) return void 0;
        const btSpan = otelContext.active().getValue?.("braintrust_span");
        if (btSpan && typeof btSpan === "object" && btSpan !== null && "spanId" in btSpan && "rootSpanId" in btSpan) {
          return btSpan;
        }
        return void 0;
      }
    };
  }
});
function applyMaskingToField(maskingFunction, data, fieldName) {
  try {
    return maskingFunction(data);
  } catch (error22) {
    const errorType = error22 instanceof Error ? error22.constructor.name : "Error";
    if (fieldName === "scores" || fieldName === "metrics") {
      return new MaskingError(fieldName, errorType);
    }
    if (fieldName === "metadata") {
      return {
        error: `ERROR: Failed to mask field '${fieldName}' - ${errorType}`
      };
    }
    return `ERROR: Failed to mask field '${fieldName}' - ${errorType}`;
  }
}
__name(applyMaskingToField, "applyMaskingToField");
function getSpanComponentsClass() {
  const useV4 = typeof process !== "undefined" && process.env?.BRAINTRUST_OTEL_COMPAT?.toLowerCase() === "true";
  return useV4 ? SpanComponentsV4 : SpanComponentsV3;
}
__name(getSpanComponentsClass, "getSpanComponentsClass");
function getContextManager() {
  const useOtel = typeof process !== "undefined" && process.env?.BRAINTRUST_OTEL_COMPAT?.toLowerCase() === "true";
  if (useOtel) {
    try {
      const { OtelContextManager: OtelContextManager2 } = (init_context3(), __toCommonJS2(context_exports));
      return new OtelContextManager2();
    } catch {
      console.warn(
        "OTEL not available, falling back to Braintrust-only context manager"
      );
    }
  }
  return new BraintrustContextManager();
}
__name(getContextManager, "getContextManager");
function useTestBackgroundLogger() {
  const state = _internalGetGlobalState();
  if (!state) {
    throw new Error("global state not set yet");
  }
  const logger = new TestBackgroundLogger();
  state.setOverrideBgLogger(logger);
  return logger;
}
__name(useTestBackgroundLogger, "useTestBackgroundLogger");
function clearTestBackgroundLogger() {
  _internalGetGlobalState()?.setOverrideBgLogger(null);
}
__name(clearTestBackgroundLogger, "clearTestBackgroundLogger");
function initTestExperiment(experimentName, projectName) {
  setInitialTestState();
  const state = _internalGetGlobalState();
  const project = projectName ?? experimentName;
  const lazyMetadata = new LazyValue(
    async () => ({
      project: { id: project, name: project, fullInfo: {} },
      experiment: { id: experimentName, name: experimentName, fullInfo: {} }
    })
  );
  return new Experiment2(state, lazyMetadata);
}
__name(initTestExperiment, "initTestExperiment");
function _internalSetInitialState() {
  if (_globalState) {
    console.warn(
      "global state already set, should only call _internalSetInitialState once"
    );
    return;
  }
  _globalState = globalThis.__inherited_braintrust_state || new BraintrustState({
    /*empty login options*/
  });
}
__name(_internalSetInitialState, "_internalSetInitialState");
async function checkResponse(resp) {
  if (resp.ok) {
    return resp;
  } else {
    throw new FailedHTTPResponse(
      resp.status,
      resp.statusText,
      await resp.text()
    );
  }
}
__name(checkResponse, "checkResponse");
function logFeedbackImpl(state, parentObjectType, parentObjectId, {
  id,
  expected,
  scores,
  metadata: inputMetadata,
  tags,
  comment,
  source: inputSource
}) {
  const source = inputSource ?? "external";
  if (!VALID_SOURCES.includes(source)) {
    throw new Error(`source must be one of ${VALID_SOURCES}`);
  }
  if (isEmpty(scores) && isEmpty(expected) && isEmpty(tags) && isEmpty(comment)) {
    throw new Error(
      "At least one of scores, expected, tags, or comment must be specified"
    );
  }
  const validatedEvent = validateAndSanitizeExperimentLogPartialArgs({
    scores,
    metadata: inputMetadata,
    expected,
    tags
  });
  let { metadata, ...updateEvent } = deepCopyEvent(validatedEvent);
  updateEvent = Object.fromEntries(
    Object.entries(updateEvent).filter(([_, v]) => !isEmpty(v))
  );
  const parentIds = /* @__PURE__ */ __name(async () => new SpanComponentsV3({
    object_type: parentObjectType,
    object_id: await parentObjectId.get()
  }).objectIdFields(), "parentIds");
  if (Object.keys(updateEvent).length > 0) {
    const record = new LazyValue(async () => {
      return {
        id,
        ...updateEvent,
        ...await parentIds(),
        [AUDIT_SOURCE_FIELD]: source,
        [AUDIT_METADATA_FIELD]: metadata,
        [IS_MERGE_FIELD]: true
      };
    });
    state.bgLogger().log([record]);
  }
  if (!isEmpty(comment)) {
    const record = new LazyValue(async () => {
      return {
        id: v4_default(),
        created: (/* @__PURE__ */ new Date()).toISOString(),
        origin: {
          // NOTE: We do not know (or care?) what the transaction id of the row that
          // we're commenting on is here, so we omit it.
          id
        },
        comment: {
          text: comment
        },
        ...await parentIds(),
        [AUDIT_SOURCE_FIELD]: source,
        [AUDIT_METADATA_FIELD]: metadata
      };
    });
    state.bgLogger().log([record]);
  }
}
__name(logFeedbackImpl, "logFeedbackImpl");
function updateSpanImpl({
  state,
  parentObjectType,
  parentObjectId,
  id,
  event
}) {
  const updateEvent = deepCopyEvent(
    validateAndSanitizeExperimentLogPartialArgs({
      id,
      ...event
    })
  );
  const parentIds = /* @__PURE__ */ __name(async () => new SpanComponentsV3({
    object_type: parentObjectType,
    object_id: await parentObjectId.get()
  }).objectIdFields(), "parentIds");
  const record = new LazyValue(async () => ({
    id,
    ...updateEvent,
    ...await parentIds(),
    [IS_MERGE_FIELD]: true
  }));
  state.bgLogger().log([record]);
}
__name(updateSpanImpl, "updateSpanImpl");
function updateSpan({
  exported,
  state,
  ...event
}) {
  const resolvedState = state ?? _globalState;
  const components = getSpanComponentsClass().fromStr(exported);
  if (!components.data.row_id) {
    throw new Error("Exported span must have a row id");
  }
  updateSpanImpl({
    state: resolvedState,
    parentObjectType: components.data.object_type,
    parentObjectId: new LazyValue(
      spanComponentsToObjectIdLambda(resolvedState, components)
    ),
    id: components.data.row_id,
    event
  });
}
__name(updateSpan, "updateSpan");
function spanComponentsToObjectIdLambda(state, components) {
  if (components.data.object_id) {
    const ret = components.data.object_id;
    return async () => ret;
  }
  if (!components.data.compute_object_metadata_args) {
    throw new Error(
      "Impossible: must provide either objectId or computeObjectMetadataArgs"
    );
  }
  switch (components.data.object_type) {
    case 1:
      throw new Error(
        "Impossible: computeObjectMetadataArgs not supported for experiments"
      );
    case 3:
      throw new Error(
        "Impossible: computeObjectMetadataArgs not supported for prompt sessions"
      );
    case 2:
      return async () => (await computeLoggerMetadata(state, {
        ...components.data.compute_object_metadata_args
      })).project.id;
    default:
      const x = components.data.object_type;
      throw new Error(`Unknown object type: ${x}`);
  }
}
__name(spanComponentsToObjectIdLambda, "spanComponentsToObjectIdLambda");
async function spanComponentsToObjectId({
  components,
  state
}) {
  return await spanComponentsToObjectIdLambda(
    state ?? _globalState,
    components
  )();
}
__name(spanComponentsToObjectId, "spanComponentsToObjectId");
function getErrPermlink(msg) {
  if (msg == "") {
    return ERR_PERMALINK;
  }
  return `${ERR_PERMALINK}?msg=${encodeURIComponent(msg)}`;
}
__name(getErrPermlink, "getErrPermlink");
async function permalink(slug, opts) {
  if (slug === "") {
    return NOOP_SPAN_PERMALINK;
  }
  const state = opts?.state ?? _globalState;
  const getOrgName = /* @__PURE__ */ __name(async () => {
    if (opts?.orgName) {
      return opts.orgName;
    }
    await state.login({});
    if (!state.orgName) {
      throw new Error("provide-org-or-login");
    }
    return state.orgName;
  }, "getOrgName");
  const getAppUrl = /* @__PURE__ */ __name(async () => {
    if (opts?.appUrl) {
      return opts.appUrl;
    }
    await state.login({});
    if (!state.appUrl) {
      throw new Error("provide-app-url-or-login");
    }
    return state.appUrl;
  }, "getAppUrl");
  try {
    const components = getSpanComponentsClass().fromStr(slug);
    const object_type = spanObjectTypeV3ToString(components.data.object_type);
    const [orgName, appUrl, object_id] = await Promise.all([
      getOrgName(),
      getAppUrl(),
      spanComponentsToObjectId({ components, state })
    ]);
    const id = components.data.row_id;
    if (!id) {
      throw new Error("Span slug does not refer to an individual row");
    }
    const urlParams = new URLSearchParams({ object_type, object_id, id });
    return `${appUrl}/app/${orgName}/object?${urlParams}`;
  } catch (e) {
    if (e instanceof FailedHTTPResponse) {
      return getErrPermlink(`http-error-${e.status}`);
    }
    return getErrPermlink(e instanceof Error ? e.message : String(e));
  }
}
__name(permalink, "permalink");
function startSpanParentArgs(args) {
  let argParentObjectId = void 0;
  let argParentSpanIds = void 0;
  let argPropagatedEvent = void 0;
  if (args.parent) {
    if (args.parentSpanIds) {
      throw new Error("Cannot specify both parent and parentSpanIds");
    }
    const parentComponents = getSpanComponentsClass().fromStr(args.parent);
    if (args.parentObjectType !== parentComponents.data.object_type) {
      throw new Error(
        `Mismatch between expected span parent object type ${args.parentObjectType} and provided type ${parentComponents.data.object_type}`
      );
    }
    const parentComponentsObjectIdLambda = spanComponentsToObjectIdLambda(
      args.state,
      parentComponents
    );
    const computeParentObjectId = /* @__PURE__ */ __name(async () => {
      const parentComponentsObjectId = await parentComponentsObjectIdLambda();
      if (await args.parentObjectId.get() !== parentComponentsObjectId) {
        throw new Error(
          `Mismatch between expected span parent object id ${await args.parentObjectId.get()} and provided id ${parentComponentsObjectId}`
        );
      }
      return await args.parentObjectId.get();
    }, "computeParentObjectId");
    argParentObjectId = new LazyValue(computeParentObjectId);
    if (parentComponents.data.row_id) {
      argParentSpanIds = {
        spanId: parentComponents.data.span_id,
        rootSpanId: parentComponents.data.root_span_id
      };
    }
    argPropagatedEvent = args.propagatedEvent ?? (parentComponents.data.propagated_event ?? void 0);
  } else {
    argParentObjectId = args.parentObjectId;
    argParentSpanIds = args.parentSpanIds;
    argPropagatedEvent = args.propagatedEvent;
  }
  return {
    parentObjectType: args.parentObjectType,
    parentObjectId: argParentObjectId,
    parentComputeObjectMetadataArgs: args.parentComputeObjectMetadataArgs,
    parentSpanIds: argParentSpanIds,
    propagatedEvent: argPropagatedEvent
  };
}
__name(startSpanParentArgs, "startSpanParentArgs");
function castLogger(logger, asyncFlush) {
  if (logger === void 0) return void 0;
  if (asyncFlush !== void 0 && !!asyncFlush !== !!logger.asyncFlush) {
    throw new Error(
      `Asserted asyncFlush setting ${asyncFlush} does not match stored logger's setting ${logger.asyncFlush}`
    );
  }
  return logger;
}
__name(castLogger, "castLogger");
function constructLogs3Data(items) {
  return `{"rows": ${constructJsonArray(items)}, "api_version": 2}`;
}
__name(constructLogs3Data, "constructLogs3Data");
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}
__name(now, "now");
function init(projectOrOptions, optionalOptions) {
  const options = (() => {
    if (typeof projectOrOptions === "string") {
      return { ...optionalOptions, project: projectOrOptions };
    } else {
      if (optionalOptions !== void 0) {
        throw new Error(
          "Cannot specify options struct as both parameters. Must call either init(project, options) or init(options)."
        );
      }
      return projectOrOptions;
    }
  })();
  const {
    project,
    experiment,
    description,
    dataset,
    baseExperiment,
    isPublic,
    open: open3,
    update,
    appUrl,
    apiKey,
    orgName,
    forceLogin,
    fetch: fetch2,
    metadata,
    gitMetadataSettings,
    projectId,
    baseExperimentId,
    repoInfo: repoInfo2,
    state: stateArg
  } = options;
  if (!project && !projectId) {
    throw new Error("Must specify at least one of project or projectId");
  }
  if (open3 && update) {
    throw new Error("Cannot open and update an experiment at the same time");
  }
  const state = stateArg ?? _globalState;
  state.enforceQueueSizeLimit(false);
  if (open3) {
    if (isEmpty(experiment)) {
      throw new Error(`Cannot open an experiment without specifying its name`);
    }
    const lazyMetadata2 = new LazyValue(
      async () => {
        await state.login({ apiKey, appUrl, orgName, fetch: fetch2, forceLogin });
        const args = {
          project_name: project,
          project_id: projectId,
          org_name: state.orgName,
          experiment_name: experiment
        };
        const response = await state.appConn().post_json("api/experiment/get", args);
        if (response.length === 0) {
          throw new Error(
            `Experiment ${experiment} not found in project ${projectId ?? project}.`
          );
        }
        const info3 = response[0];
        return {
          project: {
            id: info3.project_id,
            name: project ?? "UNKNOWN_PROJECT",
            fullInfo: {}
          },
          experiment: {
            id: info3.id,
            name: info3.name,
            fullInfo: info3
          }
        };
      }
    );
    return new ReadonlyExperiment(
      stateArg ?? _globalState,
      lazyMetadata2
    );
  }
  const lazyMetadata = new LazyValue(
    async () => {
      await state.login({ apiKey, appUrl, orgName });
      const args = {
        project_name: project,
        project_id: projectId,
        org_id: state.orgId,
        update
      };
      if (experiment) {
        args["experiment_name"] = experiment;
      }
      if (description) {
        args["description"] = description;
      }
      const repoInfoArg = await (async () => {
        if (repoInfo2) {
          return repoInfo2;
        }
        let mergedGitMetadataSettings = {
          ...state.gitMetadataSettings || {
            collect: "all"
          }
        };
        if (gitMetadataSettings) {
          mergedGitMetadataSettings = mergeGitMetadataSettings(
            mergedGitMetadataSettings,
            gitMetadataSettings
          );
        }
        return await isomorph_default.getRepoInfo(mergedGitMetadataSettings);
      })();
      if (repoInfoArg) {
        args["repo_info"] = repoInfoArg;
      }
      if (baseExperimentId) {
        args["base_exp_id"] = baseExperimentId;
      } else if (baseExperiment) {
        args["base_experiment"] = baseExperiment;
      } else {
        args["ancestor_commits"] = await isomorph_default.getPastNAncestors();
      }
      if (dataset !== void 0) {
        args["dataset_id"] = await dataset.id;
        args["dataset_version"] = await dataset.version();
      }
      if (isPublic !== void 0) {
        args["public"] = isPublic;
      }
      if (metadata) {
        args["metadata"] = metadata;
      }
      let response = null;
      while (true) {
        try {
          response = await state.appConn().post_json("api/experiment/register", args);
          break;
        } catch (e) {
          if (args["base_experiment"] && `${"data" in e && e.data}`.includes("base experiment")) {
            console.warn(
              `Base experiment ${args["base_experiment"]} not found.`
            );
            delete args["base_experiment"];
          } else {
            throw e;
          }
        }
      }
      return {
        project: {
          id: response.project.id,
          name: response.project.name,
          fullInfo: response.project
        },
        experiment: {
          id: response.experiment.id,
          name: response.experiment.name,
          created: response.experiment.created,
          fullInfo: response.experiment
        }
      };
    }
  );
  const ret = new Experiment2(state, lazyMetadata, dataset);
  if (options.setCurrent ?? true) {
    state.currentExperiment = ret;
  }
  return ret;
}
__name(init, "init");
function initExperiment(projectOrOptions, optionalOptions) {
  const options = (() => {
    if (typeof projectOrOptions === "string") {
      return { ...optionalOptions, project: projectOrOptions };
    } else {
      if (optionalOptions !== void 0) {
        throw new Error(
          "Cannot specify options struct as both parameters. Must call either init(project, options) or init(options)."
        );
      }
      return projectOrOptions;
    }
  })();
  return init(options);
}
__name(initExperiment, "initExperiment");
function withExperiment(project, callback, options = {}) {
  console.warn(
    "withExperiment is deprecated and will be removed in a future version of braintrust. Simply create the experiment with `init`."
  );
  const experiment = init(project, options);
  return callback(experiment);
}
__name(withExperiment, "withExperiment");
function withLogger(callback, options = {}) {
  console.warn(
    "withLogger is deprecated and will be removed in a future version of braintrust. Simply create the logger with `initLogger`."
  );
  const logger = initLogger(options);
  return callback(logger);
}
__name(withLogger, "withLogger");
function initDataset(projectOrOptions, optionalOptions) {
  const options = (() => {
    if (typeof projectOrOptions === "string") {
      return { ...optionalOptions, project: projectOrOptions };
    } else {
      if (optionalOptions !== void 0) {
        throw new Error(
          "Cannot specify options struct as both parameters. Must call either initDataset(project, options) or initDataset(options)."
        );
      }
      return projectOrOptions;
    }
  })();
  const {
    project,
    dataset,
    description,
    version: version2,
    appUrl,
    apiKey,
    orgName,
    fetch: fetch2,
    forceLogin,
    projectId,
    metadata,
    useOutput: legacy,
    state: stateArg,
    _internal_btql
  } = options;
  const state = stateArg ?? _globalState;
  const lazyMetadata = new LazyValue(
    async () => {
      await state.login({
        orgName,
        apiKey,
        appUrl,
        fetch: fetch2,
        forceLogin
      });
      const args = {
        org_id: state.orgId,
        project_name: project,
        project_id: projectId,
        dataset_name: dataset,
        description,
        metadata
      };
      const response = await state.appConn().post_json("api/dataset/register", args);
      return {
        project: {
          id: response.project.id,
          name: response.project.name,
          fullInfo: response.project
        },
        dataset: {
          id: response.dataset.id,
          name: response.dataset.name,
          fullInfo: response.dataset
        }
      };
    }
  );
  return new Dataset2(
    stateArg ?? _globalState,
    lazyMetadata,
    version2,
    legacy,
    _internal_btql
  );
}
__name(initDataset, "initDataset");
function withDataset(project, callback, options = {}) {
  console.warn(
    "withDataset is deprecated and will be removed in a future version of braintrust. Simply create the dataset with `initDataset`."
  );
  const dataset = initDataset(project, options);
  return callback(dataset);
}
__name(withDataset, "withDataset");
async function computeLoggerMetadata(state, {
  project_name,
  project_id
}) {
  await state.login({});
  const org_id = state.orgId;
  if (isEmpty(project_id)) {
    const response = await state.appConn().post_json("api/project/register", {
      project_name: project_name || GLOBAL_PROJECT,
      org_id
    });
    return {
      org_id,
      project: {
        id: response.project.id,
        name: response.project.name,
        fullInfo: response.project
      }
    };
  } else if (isEmpty(project_name)) {
    const response = await state.appConn().get_json("api/project", {
      id: project_id
    });
    return {
      org_id,
      project: {
        id: project_id,
        name: response.name,
        fullInfo: response.project
      }
    };
  } else {
    return {
      org_id,
      project: { id: project_id, name: project_name, fullInfo: {} }
    };
  }
}
__name(computeLoggerMetadata, "computeLoggerMetadata");
function initLogger(options = {}) {
  const {
    projectName,
    projectId,
    asyncFlush: asyncFlushArg,
    appUrl,
    apiKey,
    orgName,
    forceLogin,
    fetch: fetch2,
    state: stateArg
  } = options || {};
  const asyncFlush = asyncFlushArg === void 0 ? true : asyncFlushArg;
  const computeMetadataArgs = {
    project_name: projectName,
    project_id: projectId
  };
  const state = stateArg ?? _globalState;
  state.enforceQueueSizeLimit(true);
  const lazyMetadata = new LazyValue(
    async () => {
      await state.login({
        orgName,
        apiKey,
        appUrl,
        forceLogin,
        fetch: fetch2
      });
      return computeLoggerMetadata(state, computeMetadataArgs);
    }
  );
  const ret = new Logger(state, lazyMetadata, {
    asyncFlush,
    computeMetadataArgs
  });
  if (options.setCurrent ?? true) {
    state.currentLogger = ret;
  }
  return ret;
}
__name(initLogger, "initLogger");
async function loadPrompt({
  projectName,
  projectId,
  slug,
  version: version2,
  environment,
  id,
  defaults: defaults2,
  noTrace = false,
  appUrl,
  apiKey,
  orgName,
  fetch: fetch2,
  forceLogin,
  state: stateArg
}) {
  if (version2 && environment) {
    throw new Error(
      "Cannot specify both 'version' and 'environment' parameters. Please use only one (remove the other)."
    );
  }
  if (id) {
  } else if (isEmpty(projectName) && isEmpty(projectId)) {
    throw new Error("Must specify either projectName or projectId");
  } else if (isEmpty(slug)) {
    throw new Error("Must specify slug");
  }
  const state = stateArg ?? _globalState;
  let response;
  try {
    await state.login({
      orgName,
      apiKey,
      appUrl,
      fetch: fetch2,
      forceLogin
    });
    if (id) {
      response = await state.apiConn().get_json(`v1/prompt/${id}`, {
        ...version2 && { version: version2 },
        ...environment && { environment }
      });
      if (response) {
        response = { objects: [response] };
      }
    } else {
      response = await state.apiConn().get_json("v1/prompt", {
        project_name: projectName,
        project_id: projectId,
        slug,
        version: version2,
        ...environment && { environment }
      });
    }
  } catch (e) {
    if (environment || version2) {
      throw new Error(`Prompt not found with specified parameters: ${e}`);
    }
    console.warn("Failed to load prompt, attempting to fall back to cache:", e);
    let prompt2;
    if (id) {
      prompt2 = await state.promptCache.get({ id });
      if (!prompt2) {
        throw new Error(
          `Prompt with id ${id} not found (not found on server or in local cache): ${e}`
        );
      }
    } else {
      prompt2 = await state.promptCache.get({
        slug,
        projectId,
        projectName,
        version: version2 ?? "latest"
      });
      if (!prompt2) {
        throw new Error(
          `Prompt ${slug} (version ${version2 ?? "latest"}) not found in ${[
            projectName ?? projectId
          ]} (not found on server or in local cache): ${e}`
        );
      }
    }
    return prompt2;
  }
  if (!("objects" in response) || response.objects.length === 0) {
    if (id) {
      throw new Error(`Prompt with id ${id} not found.`);
    } else {
      throw new Error(
        `Prompt ${slug} not found in ${[projectName ?? projectId]}`
      );
    }
  } else if (response.objects.length > 1) {
    if (id) {
      throw new Error(
        `Multiple prompts found with id ${id}. This should never happen.`
      );
    } else {
      throw new Error(
        `Multiple prompts found with slug ${slug} in project ${projectName ?? projectId}. This should never happen.`
      );
    }
  }
  const metadata = Prompt.parse(response["objects"][0]);
  const prompt = new Prompt2(metadata, defaults2 || {}, noTrace);
  try {
    if (id) {
      await state.promptCache.set({ id }, prompt);
    } else if (slug) {
      await state.promptCache.set(
        { slug, projectId, projectName, version: version2 ?? "latest" },
        prompt
      );
    }
  } catch (e) {
    console.warn("Failed to set prompt in cache:", e);
  }
  return prompt;
}
__name(loadPrompt, "loadPrompt");
function setMaskingFunction(maskingFunction) {
  _globalState.setMaskingFunction(maskingFunction);
}
__name(setMaskingFunction, "setMaskingFunction");
async function login(options = {}) {
  const { forceLogin = false } = options || {};
  if (_globalState.loggedIn && !forceLogin) {
    let checkUpdatedParam2 = /* @__PURE__ */ __name(function(varname, arg, orig) {
      if (!isEmpty(arg) && !isEmpty(orig) && arg !== orig) {
        throw new Error(
          `Re-logging in with different ${varname} (${arg}) than original (${orig}). To force re-login, pass \`forceLogin: true\``
        );
      }
    }, "checkUpdatedParam2");
    var checkUpdatedParam = checkUpdatedParam2;
    checkUpdatedParam2("appUrl", options.appUrl, _globalState.appUrl);
    checkUpdatedParam2(
      "apiKey",
      options.apiKey ? HTTPConnection.sanitize_token(options.apiKey) : void 0,
      _globalState.loginToken
    );
    checkUpdatedParam2("orgName", options.orgName, _globalState.orgName);
    return _globalState;
  }
  await _globalState.login(options);
  globalThis.__inherited_braintrust_state = _globalState;
  return _globalState;
}
__name(login, "login");
async function loginToState(options = {}) {
  const {
    appUrl = isomorph_default.getEnv("BRAINTRUST_APP_URL") || "https://www.braintrust.dev",
    apiKey = isomorph_default.getEnv("BRAINTRUST_API_KEY"),
    orgName = isomorph_default.getEnv("BRAINTRUST_ORG_NAME"),
    fetch: fetch2 = globalThis.fetch
  } = options || {};
  const appPublicUrl = isomorph_default.getEnv("BRAINTRUST_APP_PUBLIC_URL") || appUrl;
  const state = new BraintrustState(options);
  state.resetLoginInfo();
  state.appUrl = appUrl;
  state.appPublicUrl = appPublicUrl;
  let conn = null;
  if (!apiKey) {
    throw new Error(
      "Please specify an api key (e.g. by setting BRAINTRUST_API_KEY)."
    );
  } else if (apiKey === TEST_API_KEY) {
    const testOrgInfo = [
      {
        id: "test-org-id",
        name: "test-org-name",
        api_url: "https://braintrust.dev/fake-api-url"
      }
    ];
    state.loggedIn = true;
    state.loginToken = TEST_API_KEY;
    _saveOrgInfo(state, testOrgInfo, testOrgInfo[0].name);
    return state;
  } else {
    const resp = await checkResponse(
      await fetch2(_urljoin(state.appUrl, `/api/apikey/login`), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${apiKey}`
        }
      })
    );
    const info3 = await resp.json();
    _saveOrgInfo(state, info3.org_info, orgName);
    if (!state.apiUrl) {
      if (orgName) {
        throw new Error(
          `Unable to log into organization '${orgName}'. Are you sure this credential is scoped to the organization?`
        );
      } else {
        throw new Error(
          "Unable to log into any organization with the provided credential."
        );
      }
    }
    conn = state.apiConn();
    conn.set_token(apiKey);
    if (!conn) {
      throw new Error("Conn should be set at this point (a bug)");
    }
    conn.make_long_lived();
    state.appConn().set_token(apiKey);
    if (state.proxyUrl) {
      state.proxyConn().set_token(apiKey);
    }
    state.loginToken = conn.token;
    state.loggedIn = true;
    state.loginReplaceApiConn(conn);
  }
  return state;
}
__name(loginToState, "loginToState");
function log3(event) {
  console.warn(
    "braintrust.log is deprecated and will be removed in a future version of braintrust. Use `experiment.log` instead."
  );
  const e = currentExperiment();
  if (!e) {
    throw new Error("Not initialized. Please call init() first");
  }
  return e.log(event);
}
__name(log3, "log");
async function summarize(options = {}) {
  console.warn(
    "braintrust.summarize is deprecated and will be removed in a future version of braintrust. Use `experiment.summarize` instead."
  );
  const e = currentExperiment();
  if (!e) {
    throw new Error("Not initialized. Please call init() first");
  }
  return await e.summarize(options);
}
__name(summarize, "summarize");
function currentExperiment(options) {
  const state = options?.state ?? _globalState;
  return state.currentExperiment;
}
__name(currentExperiment, "currentExperiment");
function currentLogger(options) {
  const state = options?.state ?? _globalState;
  return castLogger(state.currentLogger, options?.asyncFlush);
}
__name(currentLogger, "currentLogger");
function currentSpan(options) {
  const state = options?.state ?? _globalState;
  return state.contextManager.getCurrentSpan() ?? NOOP_SPAN;
}
__name(currentSpan, "currentSpan");
function getSpanParentObject(options) {
  const state = options?.state ?? _globalState;
  const parentSpan = currentSpan({ state });
  if (!Object.is(parentSpan, NOOP_SPAN)) {
    return parentSpan;
  }
  const parentStr = options?.parent ?? state.currentParent.getStore();
  if (parentStr) return getSpanComponentsClass().fromStr(parentStr);
  const experiment = currentExperiment();
  if (experiment) {
    return experiment;
  }
  const logger = currentLogger(options);
  if (logger) {
    return logger;
  }
  return NOOP_SPAN;
}
__name(getSpanParentObject, "getSpanParentObject");
function logError(span, error22) {
  let errorMessage = "<error>";
  let stackTrace = "";
  if (error22 instanceof Error) {
    errorMessage = error22.message;
    stackTrace = error22.stack || "";
  } else {
    errorMessage = String(error22);
  }
  span.log({ error: `${errorMessage}

${stackTrace}` });
}
__name(logError, "logError");
function traced(callback, args) {
  const { span, isSyncFlushLogger } = startSpanAndIsLogger(args);
  const ret = runCatchFinally(
    () => {
      if (args?.setCurrent ?? true) {
        return withCurrent(span, callback);
      } else {
        return callback(span);
      }
    },
    (e) => {
      logError(span, e);
      throw e;
    },
    () => span.end()
  );
  if (args?.asyncFlush === void 0 || args?.asyncFlush) {
    return ret;
  } else {
    return (async () => {
      const awaitedRet = await ret;
      if (isSyncFlushLogger) {
        await span.flush();
      }
      return awaitedRet;
    })();
  }
}
__name(traced, "traced");
function isGeneratorFunction(fn) {
  return Object.prototype.toString.call(fn) === "[object GeneratorFunction]";
}
__name(isGeneratorFunction, "isGeneratorFunction");
function isAsyncGeneratorFunction(fn) {
  return Object.prototype.toString.call(fn) === "[object AsyncGeneratorFunction]";
}
__name(isAsyncGeneratorFunction, "isAsyncGeneratorFunction");
function wrapTracedSyncGenerator(fn, spanArgs, noTraceIO) {
  const wrapper = /* @__PURE__ */ __name(function* (...fnArgs) {
    const span = startSpan(spanArgs);
    try {
      if (!noTraceIO) {
        span.log({ input: fnArgs });
      }
      const envValue = isomorph_default.getEnv("BRAINTRUST_MAX_GENERATOR_ITEMS");
      const maxItems = envValue !== void 0 ? Number(envValue) : 1e3;
      if (!noTraceIO && maxItems !== 0) {
        let collected = [];
        let truncated = false;
        const gen = generatorWithCurrent(span, fn.apply(this, fnArgs));
        try {
          for (const value of gen) {
            if (maxItems === -1 || !truncated && collected.length < maxItems) {
              collected.push(value);
            } else {
              truncated = true;
              collected = [];
              console.warn(
                `Generator output exceeded limit of ${maxItems} items, output not logged. Increase BRAINTRUST_MAX_GENERATOR_ITEMS or set to -1 to disable limit.`
              );
            }
            yield value;
          }
          if (!truncated) {
            span.log({ output: collected });
          }
        } catch (error22) {
          logError(span, error22);
          if (!truncated && collected.length > 0) {
            span.log({ output: collected });
          }
          throw error22;
        }
      } else {
        const gen = generatorWithCurrent(span, fn.apply(this, fnArgs));
        for (const value of gen) {
          yield value;
        }
      }
    } finally {
      span.end();
    }
  }, "wrapper");
  Object.defineProperty(wrapper, "name", { value: fn.name });
  return wrapper;
}
__name(wrapTracedSyncGenerator, "wrapTracedSyncGenerator");
function wrapTracedAsyncGenerator(fn, spanArgs, noTraceIO) {
  const wrapper = /* @__PURE__ */ __name(async function* (...fnArgs) {
    const span = startSpan(spanArgs);
    try {
      if (!noTraceIO) {
        span.log({ input: fnArgs });
      }
      const envValue = isomorph_default.getEnv("BRAINTRUST_MAX_GENERATOR_ITEMS");
      const maxItems = envValue !== void 0 ? Number(envValue) : 1e3;
      if (!noTraceIO && maxItems !== 0) {
        let collected = [];
        let truncated = false;
        const gen = asyncGeneratorWithCurrent(span, fn.apply(this, fnArgs));
        try {
          for await (const value of gen) {
            if (maxItems === -1 || !truncated && collected.length < maxItems) {
              collected.push(value);
            } else {
              truncated = true;
              collected = [];
              console.warn(
                `Generator output exceeded limit of ${maxItems} items, output not logged. Increase BRAINTRUST_MAX_GENERATOR_ITEMS or set to -1 to disable limit.`
              );
            }
            yield value;
          }
          if (!truncated) {
            span.log({ output: collected });
          }
        } catch (error22) {
          logError(span, error22);
          if (!truncated && collected.length > 0) {
            span.log({ output: collected });
          }
          throw error22;
        }
      } else {
        const gen = asyncGeneratorWithCurrent(span, fn.apply(this, fnArgs));
        for await (const value of gen) {
          yield value;
        }
      }
    } finally {
      span.end();
    }
  }, "wrapper");
  Object.defineProperty(wrapper, "name", { value: fn.name });
  return wrapper;
}
__name(wrapTracedAsyncGenerator, "wrapTracedAsyncGenerator");
function wrapTraced(fn, args) {
  const spanArgs = {
    name: fn.name,
    type: "function",
    ...args
  };
  const hasExplicitInput = args && args.event && "input" in args.event && args.event.input !== void 0;
  const hasExplicitOutput = args && args.event && args.event.output !== void 0;
  const noTraceIO = args?.noTraceIO || hasExplicitInput || hasExplicitOutput;
  if (isGeneratorFunction(fn)) {
    return wrapTracedSyncGenerator(fn, spanArgs, !!noTraceIO);
  }
  if (isAsyncGeneratorFunction(fn)) {
    return wrapTracedAsyncGenerator(fn, spanArgs, !!noTraceIO);
  }
  if (args?.asyncFlush) {
    return (...fnArgs) => traced((span) => {
      if (!hasExplicitInput) {
        span.log({ input: fnArgs });
      }
      const output = fn(...fnArgs);
      if (!hasExplicitOutput) {
        if (output instanceof Promise) {
          return (async () => {
            const result = await output;
            span.log({ output: result });
            return result;
          })();
        } else {
          span.log({ output });
        }
      }
      return output;
    }, spanArgs);
  } else {
    return (...fnArgs) => traced(async (span) => {
      if (!hasExplicitInput) {
        span.log({ input: fnArgs });
      }
      const outputResult = fn(...fnArgs);
      const output = await outputResult;
      if (!hasExplicitOutput) {
        span.log({ output });
      }
      return output;
    }, spanArgs);
  }
}
__name(wrapTraced, "wrapTraced");
function startSpan(args) {
  return startSpanAndIsLogger(args).span;
}
__name(startSpan, "startSpan");
async function flush(options) {
  const state = options?.state ?? _globalState;
  return await state.bgLogger().flush();
}
__name(flush, "flush");
function setFetch(fetch2) {
  _globalState.setFetch(fetch2);
}
__name(setFetch, "setFetch");
function startSpanAndIsLogger(args) {
  const state = args?.state ?? _globalState;
  const parentObject = getSpanParentObject({
    asyncFlush: args?.asyncFlush,
    parent: args?.parent,
    state
  });
  if (parentObject instanceof SpanComponentsV3 || parentObject instanceof SpanComponentsV4) {
    const parentSpanIds = parentObject.data.row_id ? {
      spanId: parentObject.data.span_id,
      rootSpanId: parentObject.data.root_span_id
    } : void 0;
    const span = new SpanImpl({
      state,
      ...args,
      parentObjectType: parentObject.data.object_type,
      parentObjectId: new LazyValue(
        spanComponentsToObjectIdLambda(state, parentObject)
      ),
      parentComputeObjectMetadataArgs: parentObject.data.compute_object_metadata_args ?? void 0,
      parentSpanIds,
      propagatedEvent: args?.propagatedEvent ?? // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
      (parentObject.data.propagated_event ?? void 0)
    });
    return {
      span,
      isSyncFlushLogger: parentObject.data.object_type === 2 && // Since there's no parent logger here, we're free to choose the async flush
      // behavior, and therefore propagate along whatever we get from the arguments
      args?.asyncFlush === false
    };
  } else {
    const span = parentObject.startSpan(args);
    return {
      span,
      isSyncFlushLogger: parentObject.kind === "logger" && parentObject.asyncFlush === false
    };
  }
}
__name(startSpanAndIsLogger, "startSpanAndIsLogger");
function withCurrent(span, callback, state = void 0) {
  const currentState = state ?? _globalState;
  return currentState.contextManager.runInContext(span, () => callback(span));
}
__name(withCurrent, "withCurrent");
function* generatorWithCurrent(span, gen, state = void 0) {
  let nextValue;
  while (true) {
    const result = withCurrent(
      span,
      () => {
        try {
          return gen.next(nextValue);
        } catch (e) {
          return { value: void 0, done: true, error: e };
        }
      },
      state
    );
    if ("error" in result) {
      throw result.error;
    }
    if (result.done) {
      return result.value;
    }
    nextValue = yield result.value;
  }
}
__name(generatorWithCurrent, "generatorWithCurrent");
async function* asyncGeneratorWithCurrent(span, gen, state = void 0) {
  let nextValue;
  while (true) {
    const result = await withCurrent(
      span,
      async () => {
        try {
          return await gen.next(nextValue);
        } catch (e) {
          return { value: void 0, done: true, error: e };
        }
      },
      state
    );
    if ("error" in result) {
      throw result.error;
    }
    if (result.done) {
      return result.value;
    }
    nextValue = yield result.value;
  }
}
__name(asyncGeneratorWithCurrent, "asyncGeneratorWithCurrent");
function withParent(parent, callback, state = void 0) {
  return (state ?? _globalState).currentParent.run(parent, () => callback());
}
__name(withParent, "withParent");
function _saveOrgInfo(state, org_info, org_name) {
  if (org_info.length === 0) {
    throw new Error("This user is not part of any organizations.");
  }
  for (const org of org_info) {
    if (org_name === void 0 || org.name === org_name) {
      state.orgId = org.id;
      state.orgName = org.name;
      state.apiUrl = isomorph_default.getEnv("BRAINTRUST_API_URL") ?? org.api_url;
      state.proxyUrl = isomorph_default.getEnv("BRAINTRUST_PROXY_URL") ?? org.proxy_url;
      state.gitMetadataSettings = org.git_metadata || void 0;
      break;
    }
  }
  if (state.orgId === void 0) {
    throw new Error(
      `Organization ${org_name} not found. Must be one of ${org_info.map((x) => x.name).join(", ")}`
    );
  }
}
__name(_saveOrgInfo, "_saveOrgInfo");
function validateTags(tags) {
  const seen = /* @__PURE__ */ new Set();
  for (const tag of tags) {
    if (typeof tag !== "string") {
      throw new Error("tags must be strings");
    }
    if (seen.has(tag)) {
      throw new Error(`duplicate tag: ${tag}`);
    }
  }
}
__name(validateTags, "validateTags");
function validateAndSanitizeExperimentLogPartialArgs(event) {
  if (event.scores) {
    if (Array.isArray(event.scores)) {
      throw new Error("scores must be an object, not an array");
    }
    for (let [name, score] of Object.entries(event.scores)) {
      if (typeof name !== "string") {
        throw new Error("score names must be strings");
      }
      if (score === null || score === void 0) {
        continue;
      }
      if (typeof score === "boolean") {
        score = score ? 1 : 0;
        event.scores[name] = score;
      }
      if (typeof score !== "number") {
        throw new Error("score values must be numbers");
      }
      if (score < 0 || score > 1) {
        throw new Error("score values must be between 0 and 1");
      }
    }
  }
  if (event.metadata) {
    for (const key of Object.keys(event.metadata)) {
      if (typeof key !== "string") {
        throw new Error("metadata keys must be strings");
      }
    }
  }
  if (event.metrics) {
    for (const [key, value] of Object.entries(event.metrics)) {
      if (typeof key !== "string") {
        throw new Error("metric keys must be strings");
      }
      if (value !== void 0 && typeof value !== "number") {
        throw new Error("metric values must be numbers");
      }
    }
  }
  if ("input" in event && event.input && "inputs" in event && event.inputs) {
    throw new Error(
      "Only one of input or inputs (deprecated) can be specified. Prefer input."
    );
  }
  if ("tags" in event && event.tags) {
    validateTags(event.tags);
  }
  if ("inputs" in event) {
    const { inputs, ...rest } = event;
    return { input: inputs, ...rest };
  } else {
    return { ...event };
  }
}
__name(validateAndSanitizeExperimentLogPartialArgs, "validateAndSanitizeExperimentLogPartialArgs");
function deepCopyEvent(event) {
  const attachments = [];
  const IDENTIFIER = "_bt_internal_saved_attachment";
  const savedAttachmentSchema = external_exports.strictObject({ [IDENTIFIER]: external_exports.number() });
  const serialized = JSON.stringify(event, (_k, v) => {
    if (v instanceof SpanImpl || v instanceof NoopSpan) {
      return `<span>`;
    } else if (v instanceof Experiment2) {
      return `<experiment>`;
    } else if (v instanceof Dataset2) {
      return `<dataset>`;
    } else if (v instanceof Logger) {
      return `<logger>`;
    } else if (v instanceof BaseAttachment) {
      const idx = attachments.push(v);
      return { [IDENTIFIER]: idx - 1 };
    } else if (v instanceof ReadonlyAttachment) {
      return v.reference;
    }
    return v;
  });
  const x = JSON.parse(serialized, (_k, v) => {
    const parsedAttachment = savedAttachmentSchema.safeParse(v);
    if (parsedAttachment.success) {
      return attachments[parsedAttachment.data[IDENTIFIER]];
    }
    return v;
  });
  return x;
}
__name(deepCopyEvent, "deepCopyEvent");
function extractAttachments(event, attachments) {
  for (const [key, value] of Object.entries(event)) {
    if (!value) {
      continue;
    }
    if (value instanceof BaseAttachment) {
      attachments.push(value);
      event[key] = value.reference;
      continue;
    }
    if (value?.type === BRAINTRUST_ATTACHMENT && value.key && !value.uploader) {
      continue;
    }
    if (value?.reference?.type === BRAINTRUST_ATTACHMENT && value?.uploader) {
      const attachment = new Attachment({
        data: value.dataDebugString,
        filename: value.reference.filename,
        contentType: value.reference.content_type
      });
      attachments.push(attachment);
      event[key] = attachment.reference;
      continue;
    }
    if (!(value instanceof Object)) {
      continue;
    }
    extractAttachments(value, attachments);
  }
}
__name(extractAttachments, "extractAttachments");
function enrichAttachments(event, state) {
  for (const [key, value] of Object.entries(event)) {
    const parsedValue = AttachmentReference.safeParse(value);
    if (parsedValue.success) {
      event[key] = new ReadonlyAttachment(parsedValue.data, state);
      continue;
    }
    if (!(value instanceof Object)) {
      continue;
    }
    enrichAttachments(value, state);
  }
  return event;
}
__name(enrichAttachments, "enrichAttachments");
async function resolveAttachmentsToBase64(event, state) {
  for (const [key, value] of Object.entries(event)) {
    if (value instanceof ReadonlyAttachment) {
      event[key] = await value.asBase64Url();
      continue;
    }
    if (!(value instanceof Object)) {
      continue;
    }
    await resolveAttachmentsToBase64(value, state);
  }
  return event;
}
__name(resolveAttachmentsToBase64, "resolveAttachmentsToBase64");
function validateAndSanitizeExperimentLogFullArgs(event, hasDataset) {
  if ("input" in event && !isEmpty(event.input) && "inputs" in event && !isEmpty(event.inputs) || !("input" in event) && !("inputs" in event)) {
    throw new Error(
      "Exactly one of input or inputs (deprecated) must be specified. Prefer input."
    );
  }
  if (isEmpty(event.output)) {
    throw new Error("output must be specified");
  }
  if (isEmpty(event.scores)) {
    throw new Error("scores must be specified");
  }
  if (hasDataset && event.datasetRecordId === void 0) {
    throw new Error("datasetRecordId must be specified when using a dataset");
  } else if (!hasDataset && event.datasetRecordId !== void 0) {
    throw new Error(
      "datasetRecordId cannot be specified when not using a dataset"
    );
  }
  return event;
}
__name(validateAndSanitizeExperimentLogFullArgs, "validateAndSanitizeExperimentLogFullArgs");
function newId() {
  return v4_default();
}
__name(newId, "newId");
function _resolveSpanIds(spanId, parentSpanIds, lookupSpanParent, idGenerator, contextManager) {
  const resolvedSpanId = spanId ?? idGenerator.getSpanId();
  if (parentSpanIds) {
    return {
      spanId: resolvedSpanId,
      rootSpanId: parentSpanIds.rootSpanId,
      spanParents: "parentSpanIds" in parentSpanIds ? parentSpanIds.parentSpanIds : [parentSpanIds.spanId]
    };
  }
  if (lookupSpanParent) {
    const parentInfo = contextManager.getParentSpanIds();
    if (parentInfo) {
      return {
        spanId: resolvedSpanId,
        rootSpanId: parentInfo.rootSpanId,
        spanParents: parentInfo.spanParents
      };
    }
  }
  let resolvedRootSpanId;
  if (idGenerator.shareRootSpanId()) {
    resolvedRootSpanId = resolvedSpanId;
  } else {
    resolvedRootSpanId = idGenerator.getTraceId();
  }
  return {
    spanId: resolvedSpanId,
    rootSpanId: resolvedRootSpanId,
    spanParents: void 0
  };
}
__name(_resolveSpanIds, "_resolveSpanIds");
function splitLoggingData({
  event,
  internalData
}) {
  const sanitized = validateAndSanitizeExperimentLogPartialArgs(event ?? {});
  const sanitizedAndInternalData = {};
  mergeDicts(sanitizedAndInternalData, internalData || {});
  mergeDicts(sanitizedAndInternalData, sanitized);
  const serializableInternalData = {};
  const lazyInternalData = {};
  for (const [key, value] of Object.entries(sanitizedAndInternalData)) {
    if (value instanceof BraintrustStream) {
      const streamCopy = value.copy();
      lazyInternalData[key] = new LazyValue(async () => {
        return await new Promise((resolve, reject2) => {
          streamCopy.toReadableStream().pipeThrough(createFinalValuePassThroughStream(resolve, reject2)).pipeTo(devNullWritableStream());
        });
      });
    } else if (value instanceof ReadableStream) {
      lazyInternalData[key] = new LazyValue(async () => {
        return await new Promise((resolve, reject2) => {
          value.pipeThrough(createFinalValuePassThroughStream(resolve, reject2)).pipeTo(devNullWritableStream());
        });
      });
    } else {
      serializableInternalData[key] = value;
    }
  }
  return [serializableInternalData, lazyInternalData];
}
__name(splitLoggingData, "splitLoggingData");
function renderMessage(render3, message) {
  return {
    ...message,
    ..."content" in message ? {
      content: isEmpty(message.content) ? void 0 : typeof message.content === "string" ? render3(message.content) : message.content.map((c) => {
        switch (c.type) {
          case "text":
            return { ...c, text: render3(c.text) };
          case "image_url":
            if (isObject(c.image_url.url)) {
              throw new Error(
                "Attachments must be replaced with URLs before calling `build()`"
              );
            }
            return {
              ...c,
              image_url: {
                ...c.image_url,
                url: render3(c.image_url.url)
              }
            };
          default:
            const _exhaustiveCheck = c;
            return _exhaustiveCheck;
        }
      })
    } : {},
    ..."tool_calls" in message ? {
      tool_calls: isEmpty(message.tool_calls) ? void 0 : message.tool_calls.map((t) => {
        return {
          type: t.type,
          id: render3(t.id),
          function: {
            name: render3(t.function.name),
            arguments: render3(t.function.arguments)
          }
        };
      })
    } : {},
    ..."tool_call_id" in message ? {
      tool_call_id: render3(message.tool_call_id)
    } : {}
  };
}
__name(renderMessage, "renderMessage");
function deserializePlainStringAsJSON(s) {
  if (s.trim() === "") {
    return { value: null, error: void 0 };
  }
  try {
    return { value: JSON.parse(s), error: void 0 };
  } catch (e) {
    return { value: s, error: e };
  }
}
__name(deserializePlainStringAsJSON, "deserializePlainStringAsJSON");
function renderTemplatedObject(obj, args, options) {
  if (typeof obj === "string") {
    if (options.strict) {
      lintTemplate(obj, args);
    }
    return mustache_default.render(obj, args, void 0, {
      escape: /* @__PURE__ */ __name((value) => {
        if (typeof value === "string") {
          return value;
        } else {
          return JSON.stringify(value);
        }
      }, "escape")
    });
  } else if (isArray2(obj)) {
    return obj.map((item) => renderTemplatedObject(item, args, options));
  } else if (isObject(obj)) {
    return Object.fromEntries(
      Object.entries(obj).map(([key, value]) => [
        key,
        renderTemplatedObject(value, args, options)
      ])
    );
  }
  return obj;
}
__name(renderTemplatedObject, "renderTemplatedObject");
function renderPromptParams(params, args, options) {
  const schemaParsed = external_exports.object({
    response_format: external_exports.object({
      type: external_exports.literal("json_schema"),
      json_schema: ResponseFormatJsonSchema.omit({ schema: true }).extend({
        schema: external_exports.unknown()
      })
    })
  }).safeParse(params);
  if (schemaParsed.success) {
    const rawSchema = schemaParsed.data.response_format.json_schema.schema;
    const templatedSchema = renderTemplatedObject(rawSchema, args, options);
    const parsedSchema = typeof templatedSchema === "string" ? deserializePlainStringAsJSON(templatedSchema).value : templatedSchema;
    return {
      ...params,
      response_format: {
        ...schemaParsed.data.response_format,
        json_schema: {
          ...schemaParsed.data.response_format.json_schema,
          schema: parsedSchema
        }
      }
    };
  }
  return params;
}
__name(renderPromptParams, "renderPromptParams");
function setInitialTestState() {
  if (!_internalGetGlobalState()) {
    _internalSetInitialState();
  }
}
__name(setInitialTestState, "setInitialTestState");
async function simulateLoginForTests() {
  return await login({
    apiKey: TEST_API_KEY,
    appUrl: "https://braintrust.dev"
  });
}
__name(simulateLoginForTests, "simulateLoginForTests");
function simulateLogoutForTests() {
  _globalState.resetLoginInfo();
  _globalState.appUrl = "https://www.braintrust.dev";
  return _globalState;
}
__name(simulateLogoutForTests, "simulateLogoutForTests");
async function getPromptVersions(projectId, promptId) {
  const state = _internalGetGlobalState();
  if (!state) {
    throw new Error("Must log in first");
  }
  await state.login({});
  const query = {
    from: {
      op: "function",
      name: {
        op: "ident",
        name: ["project_prompts"]
      },
      args: [
        {
          op: "literal",
          value: projectId
        }
      ]
    },
    select: [
      {
        op: "star"
      }
    ],
    filter: {
      op: "eq",
      left: { op: "ident", name: ["id"] },
      right: { op: "literal", value: promptId }
    }
  };
  const response = await state.apiConn().post(
    "btql",
    {
      query,
      audit_log: true,
      use_columnstore: false,
      brainstore_realtime: true
    },
    { headers: { "Accept-Encoding": "gzip" } }
  );
  if (!response.ok) {
    throw new Error(
      `API request failed: ${response.status} ${response.statusText}`
    );
  }
  const result = await response.json();
  return result.data?.filter(
    (entry) => ["upsert", "merge"].includes(entry.audit_data?.action)
  ).map((entry) => prettifyXact(entry._xact_id)) || [];
}
__name(getPromptVersions, "getPromptVersions");
function resetIdGenStateForTests() {
  const state = _internalGetGlobalState();
  if (state) {
    state.resetIdGenState();
  }
}
__name(resetIdGenStateForTests, "resetIdGenStateForTests");
var BRAINTRUST_ATTACHMENT;
var EXTERNAL_ATTACHMENT;
var BRAINTRUST_PARAMS;
var REDACTION_FIELDS;
var MaskingError;
var ContextManager;
var BraintrustContextManager;
var NoopSpan;
var NOOP_SPAN;
var NOOP_SPAN_PERMALINK;
var loginSchema;
var stateNonce;
var BraintrustState;
var _globalState;
var _internalGetGlobalState;
var FailedHTTPResponse;
var HTTPConnection;
var BaseAttachment;
var Attachment;
var ExternalAttachment;
var attachmentMetadataSchema;
var ReadonlyAttachment;
var JSONAttachment;
var ERR_PERMALINK;
var Logger;
var TestBackgroundLogger;
var BACKGROUND_LOGGER_BASE_SLEEP_TIME_S;
var HTTPBackgroundLogger;
var traceable;
var INTERNAL_BTQL_LIMIT;
var MAX_BTQL_ITERATIONS;
var ObjectFetcher;
var Experiment2;
var ReadonlyExperiment;
var executionCounter;
var SpanImpl;
var Dataset2;
var Prompt2;
var TEST_API_KEY;
var _exportsForTestingOnly;
var init_logger = __esm3({
  "src/logger.ts"() {
    "use strict";
    init_queue();
    init_id_gen();
    init_util2();
    init_generated_types();
    init_stream();
    init_isomorph();
    init_disk_cache();
    init_lru_cache();
    init_prompt_cache();
    init_util22();
    init_mustache_utils();
    init_util2();
    BRAINTRUST_ATTACHMENT = BraintrustAttachmentReference.shape.type.value;
    EXTERNAL_ATTACHMENT = ExternalAttachmentReference.shape.type.value;
    BRAINTRUST_PARAMS = Object.keys(BraintrustModelParams.shape);
    REDACTION_FIELDS = [
      "input",
      "output",
      "expected",
      "metadata",
      "context",
      "scores",
      "metrics"
    ];
    MaskingError = class {
      static {
        __name(this, "MaskingError");
      }
      constructor(fieldName, errorType) {
        this.fieldName = fieldName;
        this.errorType = errorType;
      }
      get errorMsg() {
        return `ERROR: Failed to mask field '${this.fieldName}' - ${this.errorType}`;
      }
    };
    ContextManager = class {
      static {
        __name(this, "ContextManager");
      }
    };
    BraintrustContextManager = class extends ContextManager {
      static {
        __name(this, "BraintrustContextManager");
      }
      _currentSpan;
      constructor() {
        super();
        this._currentSpan = isomorph_default.newAsyncLocalStorage();
      }
      getParentSpanIds() {
        const currentSpan2 = this._currentSpan.getStore();
        if (!currentSpan2) {
          return void 0;
        }
        return {
          rootSpanId: currentSpan2.rootSpanId,
          spanParents: [currentSpan2.spanId]
        };
      }
      runInContext(span, callback) {
        return this._currentSpan.run(span, callback);
      }
      getCurrentSpan() {
        return this._currentSpan.getStore();
      }
    };
    NoopSpan = class {
      static {
        __name(this, "NoopSpan");
      }
      id;
      spanId;
      rootSpanId;
      spanParents;
      kind = "span";
      constructor() {
        this.id = "";
        this.spanId = "";
        this.rootSpanId = "";
        this.spanParents = [];
      }
      log(_) {
      }
      logFeedback(_event) {
      }
      traced(callback, _1) {
        return callback(this);
      }
      startSpan(_1) {
        return this;
      }
      end(args) {
        return args?.endTime ?? getCurrentUnixTimestamp();
      }
      async export() {
        return "";
      }
      async permalink() {
        return NOOP_SPAN_PERMALINK;
      }
      link() {
        return NOOP_SPAN_PERMALINK;
      }
      async flush() {
      }
      close(args) {
        return this.end(args);
      }
      setAttributes(_args) {
      }
      startSpanWithParents(_spanId, _spanParents, _args) {
        return this;
      }
      state() {
        return _internalGetGlobalState();
      }
      _getOtelParent() {
        return void 0;
      }
      // Custom inspect for Node.js console.log
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `NoopSpan {
  kind: '${this.kind}',
  id: '${this.id}',
  spanId: '${this.spanId}',
  rootSpanId: '${this.rootSpanId}',
  spanParents: ${JSON.stringify(this.spanParents)}
}`;
      }
      // Custom toString
      toString() {
        return `NoopSpan(id=${this.id}, spanId=${this.spanId})`;
      }
    };
    NOOP_SPAN = new NoopSpan();
    NOOP_SPAN_PERMALINK = "https://braintrust.dev/noop-span";
    loginSchema = external_exports.strictObject({
      appUrl: external_exports.string(),
      appPublicUrl: external_exports.string(),
      orgName: external_exports.string(),
      apiUrl: external_exports.string(),
      proxyUrl: external_exports.string(),
      loginToken: external_exports.string(),
      orgId: external_exports.string().nullish(),
      gitMetadataSettings: GitMetadataSettings.nullish()
    });
    stateNonce = 0;
    BraintrustState = class _BraintrustState {
      static {
        __name(this, "_BraintrustState");
      }
      constructor(loginParams) {
        this.loginParams = loginParams;
        this.id = `${(/* @__PURE__ */ new Date()).toLocaleString()}-${stateNonce++}`;
        this.currentExperiment = void 0;
        this.currentLogger = void 0;
        this.currentParent = isomorph_default.newAsyncLocalStorage();
        this.currentSpan = isomorph_default.newAsyncLocalStorage();
        if (loginParams.fetch) {
          this.fetch = loginParams.fetch;
        }
        const defaultGetLogConn = /* @__PURE__ */ __name(async () => {
          await this.login({});
          return this.apiConn();
        }, "defaultGetLogConn");
        this._bgLogger = new SyncLazyValue(
          () => new HTTPBackgroundLogger(new LazyValue(defaultGetLogConn), loginParams)
        );
        this.resetLoginInfo();
        const memoryCache = new LRUCache({
          max: Number(isomorph_default.getEnv("BRAINTRUST_PROMPT_CACHE_MEMORY_MAX")) ?? 1 << 10
        });
        const diskCache = canUseDiskCache() ? new DiskCache({
          cacheDir: isomorph_default.getEnv("BRAINTRUST_PROMPT_CACHE_DIR") ?? `${isomorph_default.getEnv("HOME") ?? isomorph_default.homedir()}/.braintrust/prompt_cache`,
          max: Number(isomorph_default.getEnv("BRAINTRUST_PROMPT_CACHE_DISK_MAX")) ?? 1 << 20
        }) : void 0;
        this.promptCache = new PromptCache({ memoryCache, diskCache });
      }
      id;
      currentExperiment;
      // Note: the value of IsAsyncFlush doesn't really matter here, since we
      // (safely) dynamically cast it whenever retrieving the logger.
      currentLogger;
      currentParent;
      currentSpan;
      // Any time we re-log in, we directly update the apiConn inside the logger.
      // This is preferable to replacing the whole logger, which would create the
      // possibility of multiple loggers floating around, which may not log in a
      // deterministic order.
      _bgLogger;
      _overrideBgLogger = null;
      appUrl = null;
      appPublicUrl = null;
      loginToken = null;
      orgId = null;
      orgName = null;
      apiUrl = null;
      proxyUrl = null;
      loggedIn = false;
      gitMetadataSettings;
      fetch = globalThis.fetch;
      _appConn = null;
      _apiConn = null;
      _proxyConn = null;
      promptCache;
      _idGenerator = null;
      _contextManager = null;
      resetLoginInfo() {
        this.appUrl = null;
        this.appPublicUrl = null;
        this.loginToken = null;
        this.orgId = null;
        this.orgName = null;
        this.apiUrl = null;
        this.proxyUrl = null;
        this.loggedIn = false;
        this.gitMetadataSettings = void 0;
        this._appConn = null;
        this._apiConn = null;
        this._proxyConn = null;
      }
      resetIdGenState() {
        this._idGenerator = null;
      }
      get idGenerator() {
        if (this._idGenerator === null) {
          this._idGenerator = getIdGenerator();
        }
        return this._idGenerator;
      }
      get contextManager() {
        if (this._contextManager === null) {
          this._contextManager = getContextManager();
        }
        return this._contextManager;
      }
      copyLoginInfo(other) {
        this.appUrl = other.appUrl;
        this.appPublicUrl = other.appPublicUrl;
        this.loginToken = other.loginToken;
        this.orgId = other.orgId;
        this.orgName = other.orgName;
        this.apiUrl = other.apiUrl;
        this.proxyUrl = other.proxyUrl;
        this.loggedIn = other.loggedIn;
        this.gitMetadataSettings = other.gitMetadataSettings;
        this._appConn = other._appConn;
        this._apiConn = other._apiConn;
        this.loginReplaceApiConn(this.apiConn());
        this._proxyConn = other._proxyConn;
      }
      serialize() {
        if (!this.loggedIn) {
          throw new Error(
            "Cannot serialize BraintrustState without being logged in"
          );
        }
        if (!this.appUrl || !this.appPublicUrl || !this.apiUrl || !this.proxyUrl || !this.orgName || !this.loginToken || !this.loggedIn) {
          throw new Error(
            "Cannot serialize BraintrustState without all login attributes"
          );
        }
        return {
          appUrl: this.appUrl,
          appPublicUrl: this.appPublicUrl,
          loginToken: this.loginToken,
          orgId: this.orgId,
          orgName: this.orgName,
          apiUrl: this.apiUrl,
          proxyUrl: this.proxyUrl,
          gitMetadataSettings: this.gitMetadataSettings
        };
      }
      static deserialize(serialized, opts) {
        const serializedParsed = loginSchema.safeParse(serialized);
        if (!serializedParsed.success) {
          throw new Error(
            `Cannot deserialize BraintrustState: ${serializedParsed.error.message}`
          );
        }
        const state = new _BraintrustState({ ...opts });
        for (const key of Object.keys(loginSchema.shape)) {
          state[key] = serializedParsed.data[key];
        }
        if (!state.loginToken) {
          throw new Error(
            "Cannot deserialize BraintrustState without a login token"
          );
        }
        state.apiConn().set_token(state.loginToken);
        state.apiConn().make_long_lived();
        state.appConn().set_token(state.loginToken);
        if (state.proxyUrl) {
          state.proxyConn().make_long_lived();
          state.proxyConn().set_token(state.loginToken);
        }
        state.loggedIn = true;
        state.loginReplaceApiConn(state.apiConn());
        return state;
      }
      setFetch(fetch2) {
        this.loginParams.fetch = fetch2;
        this.fetch = fetch2;
        this._apiConn?.setFetch(fetch2);
        this._appConn?.setFetch(fetch2);
      }
      setMaskingFunction(maskingFunction) {
        this.bgLogger().setMaskingFunction(maskingFunction);
      }
      async login(loginParams) {
        if (this.apiUrl && !loginParams.forceLogin) {
          return;
        }
        const newState = await loginToState({
          ...this.loginParams,
          ...Object.fromEntries(
            Object.entries(loginParams).filter(([k, v]) => !isEmpty(v))
          )
        });
        this.copyLoginInfo(newState);
      }
      appConn() {
        if (!this._appConn) {
          if (!this.appUrl) {
            throw new Error("Must initialize appUrl before requesting appConn");
          }
          this._appConn = new HTTPConnection(this.appUrl, this.fetch);
        }
        return this._appConn;
      }
      apiConn() {
        if (!this._apiConn) {
          if (!this.apiUrl) {
            throw new Error("Must initialize apiUrl before requesting apiConn");
          }
          this._apiConn = new HTTPConnection(this.apiUrl, this.fetch);
        }
        return this._apiConn;
      }
      proxyConn() {
        if (!this.proxyUrl) {
          return this.apiConn();
        }
        if (!this._proxyConn) {
          if (!this.proxyUrl) {
            throw new Error("Must initialize proxyUrl before requesting proxyConn");
          }
          this._proxyConn = new HTTPConnection(this.proxyUrl, this.fetch);
        }
        return this._proxyConn;
      }
      bgLogger() {
        if (this._overrideBgLogger) {
          return this._overrideBgLogger;
        }
        return this._bgLogger.get();
      }
      httpLogger() {
        return this._bgLogger.get();
      }
      setOverrideBgLogger(logger) {
        this._overrideBgLogger = logger;
      }
      // Should only be called by the login function.
      loginReplaceApiConn(apiConn) {
        this._bgLogger.get().internalReplaceApiConn(apiConn);
      }
      disable() {
        this._bgLogger.get().disable();
      }
      enforceQueueSizeLimit(enforce) {
        this._bgLogger.get().enforceQueueSizeLimit(enforce);
      }
      // Custom serialization to avoid logging sensitive data
      toJSON() {
        return {
          id: this.id,
          orgId: this.orgId,
          orgName: this.orgName,
          appUrl: this.appUrl,
          appPublicUrl: this.appPublicUrl,
          apiUrl: this.apiUrl,
          proxyUrl: this.proxyUrl,
          loggedIn: this.loggedIn
          // Explicitly exclude loginToken, _apiConn, _appConn, _proxyConn and other sensitive fields
        };
      }
      // Custom inspect for Node.js console.log
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `BraintrustState {
  id: '${this.id}',
  orgId: ${this.orgId ? `'${this.orgId}'` : "null"},
  orgName: ${this.orgName ? `'${this.orgName}'` : "null"},
  appUrl: ${this.appUrl ? `'${this.appUrl}'` : "null"},
  apiUrl: ${this.apiUrl ? `'${this.apiUrl}'` : "null"},
  proxyUrl: ${this.proxyUrl ? `'${this.proxyUrl}'` : "null"},
  loggedIn: ${this.loggedIn},
  loginToken: '[REDACTED]'
}`;
      }
      // Custom toString
      toString() {
        return `BraintrustState(id=${this.id}, org=${this.orgName || "none"}, loggedIn=${this.loggedIn})`;
      }
    };
    _internalGetGlobalState = /* @__PURE__ */ __name(() => _globalState, "_internalGetGlobalState");
    FailedHTTPResponse = class extends Error {
      static {
        __name(this, "FailedHTTPResponse");
      }
      status;
      text;
      data;
      constructor(status, text, data) {
        super(`${status}: ${text} (${data})`);
        this.status = status;
        this.text = text;
        this.data = data;
      }
    };
    HTTPConnection = class _HTTPConnection {
      static {
        __name(this, "_HTTPConnection");
      }
      base_url;
      token;
      headers;
      fetch;
      constructor(base_url, fetch2) {
        this.base_url = base_url;
        this.token = null;
        this.headers = {};
        this._reset();
        this.fetch = fetch2;
      }
      setFetch(fetch2) {
        this.fetch = fetch2;
      }
      async ping() {
        try {
          const resp = await this.get("ping");
          return resp.status === 200;
        } catch (e) {
          return false;
        }
      }
      make_long_lived() {
        this._reset();
      }
      static sanitize_token(token) {
        return token.trim();
      }
      set_token(token) {
        token = _HTTPConnection.sanitize_token(token);
        this.token = token;
        this._reset();
      }
      // As far as I can tell, you cannot set the retry/backoff factor here
      _reset() {
        this.headers = {};
        if (this.token) {
          this.headers["Authorization"] = `Bearer ${this.token}`;
        }
      }
      async get(path32, params = void 0, config2) {
        const { headers, ...rest } = config2 || {};
        const url = new URL(_urljoin(this.base_url, path32));
        url.search = new URLSearchParams(
          params ? Object.entries(params).filter(([_, v]) => v !== void 0).flatMap(
            ([k, v]) => v !== void 0 ? typeof v === "string" ? [[k, v]] : v.map((x) => [k, x]) : []
          ) : []
        ).toString();
        const this_fetch = this.fetch;
        const this_headers = this.headers;
        return await checkResponse(
          // Using toString() here makes it work with isomorphic fetch
          await this_fetch(url.toString(), {
            headers: {
              Accept: "application/json",
              ...this_headers,
              ...headers
            },
            keepalive: true,
            ...rest
          })
        );
      }
      async post(path32, params, config2) {
        const { headers, ...rest } = config2 || {};
        const this_fetch = this.fetch;
        const this_base_url = this.base_url;
        const this_headers = this.headers;
        return await checkResponse(
          await this_fetch(_urljoin(this_base_url, path32), {
            method: "POST",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
              ...this_headers,
              ...headers
            },
            body: typeof params === "string" ? params : params ? JSON.stringify(params) : void 0,
            keepalive: true,
            ...rest
          })
        );
      }
      async get_json(object_type, args = void 0, retries = 0) {
        const tries = retries + 1;
        for (let i = 0; i < tries; i++) {
          try {
            const resp = await this.get(`${object_type}`, args);
            return await resp.json();
          } catch (e) {
            if (i < tries - 1) {
              console.log(
                `Retrying API request ${object_type} ${JSON.stringify(args)} ${e.status} ${e.text}`
              );
              continue;
            }
            throw e;
          }
        }
      }
      async post_json(object_type, args = void 0) {
        const resp = await this.post(`${object_type}`, args, {
          headers: { "Content-Type": "application/json" }
        });
        return await resp.json();
      }
      // Custom inspect for Node.js console.log
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `HTTPConnection {
  base_url: '${this.base_url}',
  token: '[REDACTED]'
}`;
      }
      // Custom toString
      toString() {
        return `HTTPConnection(${this.base_url})`;
      }
    };
    BaseAttachment = class {
      static {
        __name(this, "BaseAttachment");
      }
      reference;
    };
    Attachment = class extends BaseAttachment {
      static {
        __name(this, "Attachment");
      }
      /**
       * The object that replaces this `Attachment` at upload time.
       */
      reference;
      uploader;
      _data;
      state;
      // For debug logging only.
      dataDebugString;
      /**
       * Construct an attachment.
       *
       * @param param A parameter object with:
       *
       * `data`: A string representing the path of the file on disk, or a
       * `Blob`/`ArrayBuffer` with the file's contents. The caller is responsible
       * for ensuring the file/blob/buffer is not modified until upload is complete.
       *
       * `filename`: The desired name of the file in Braintrust after uploading.
       * This parameter is for visualization purposes only and has no effect on
       * attachment storage.
       *
       * `contentType`: The MIME type of the file.
       *
       * `state`: (Optional) For internal use.
       */
      constructor({ data, filename, contentType, state }) {
        super();
        this.reference = {
          type: BRAINTRUST_ATTACHMENT,
          filename,
          content_type: contentType,
          key: newId()
        };
        this.state = state;
        this.dataDebugString = typeof data === "string" ? data : "<in-memory data>";
        this._data = this.initData(data);
        this.uploader = this.initUploader();
      }
      /**
       * On first access, (1) reads the attachment from disk if needed, (2)
       * authenticates with the data plane to request a signed URL, (3) uploads to
       * object store, and (4) updates the attachment.
       *
       * @returns The attachment status.
       */
      async upload() {
        return await this.uploader.get();
      }
      /**
       * The attachment contents. This is a lazy value that will read the attachment contents from disk or memory on first access.
       */
      async data() {
        return this._data.get();
      }
      /**
       * A human-readable description for logging and debugging.
       *
       * @returns The debug object. The return type is not stable and may change in
       * a future release.
       */
      debugInfo() {
        return {
          inputData: this.dataDebugString,
          reference: this.reference,
          state: this.state
        };
      }
      initUploader() {
        const doUpload = /* @__PURE__ */ __name(async (conn, orgId) => {
          const requestParams = {
            key: this.reference.key,
            filename: this.reference.filename,
            content_type: this.reference.content_type,
            org_id: orgId
          };
          const [metadataPromiseResult, dataPromiseResult] = await Promise.allSettled([
            conn.post("/attachment", requestParams),
            this._data.get()
          ]);
          if (metadataPromiseResult.status === "rejected") {
            const errorStr = JSON.stringify(metadataPromiseResult.reason);
            throw new Error(
              `Failed to request signed URL from API server: ${errorStr}`
            );
          }
          if (dataPromiseResult.status === "rejected") {
            const errorStr = JSON.stringify(dataPromiseResult.reason);
            throw new Error(`Failed to read file: ${errorStr}`);
          }
          const metadataResponse = metadataPromiseResult.value;
          const data = dataPromiseResult.value;
          let signedUrl;
          let headers;
          try {
            ({ signedUrl, headers } = external_exports.object({
              signedUrl: external_exports.string().url(),
              headers: external_exports.record(external_exports.string())
            }).parse(await metadataResponse.json()));
          } catch (error22) {
            if (error22 instanceof ZodError) {
              const errorStr = JSON.stringify(error22.flatten());
              throw new Error(`Invalid response from API server: ${errorStr}`);
            }
            throw error22;
          }
          addAzureBlobHeaders(headers, signedUrl);
          let objectStoreResponse;
          try {
            objectStoreResponse = await checkResponse(
              await fetch(signedUrl, {
                method: "PUT",
                headers,
                body: data
              })
            );
          } catch (error22) {
            if (error22 instanceof FailedHTTPResponse) {
              throw new Error(
                `Failed to upload attachment to object store: ${error22.status} ${error22.text} ${error22.data}`
              );
            }
            throw error22;
          }
          return { signedUrl, metadataResponse, objectStoreResponse };
        }, "doUpload");
        const errorWrapper = /* @__PURE__ */ __name(async () => {
          const status = { upload_status: "done" };
          const state = this.state ?? _globalState;
          await state.login({});
          const conn = state.apiConn();
          const orgId = state.orgId ?? "";
          try {
            await doUpload(conn, orgId);
          } catch (error22) {
            status.upload_status = "error";
            status.error_message = error22 instanceof Error ? error22.message : JSON.stringify(error22);
          }
          const requestParams = {
            key: this.reference.key,
            org_id: orgId,
            status
          };
          const statusResponse = await conn.post(
            "/attachment/status",
            requestParams
          );
          if (!statusResponse.ok) {
            const errorStr = JSON.stringify(statusResponse);
            throw new Error(`Couldn't log attachment status: ${errorStr}`);
          }
          return status;
        }, "errorWrapper");
        return new LazyValue(errorWrapper);
      }
      initData(data) {
        if (typeof data === "string") {
          this.ensureFileReadable(data);
          const readFile22 = isomorph_default.readFile;
          if (!readFile22) {
            throw new Error(
              `This platform does not support reading the filesystem. Construct the Attachment
with a Blob/ArrayBuffer, or run the program on Node.js.`
            );
          }
          return new LazyValue(async () => new Blob([await readFile22(data)]));
        } else {
          return new LazyValue(async () => new Blob([data]));
        }
      }
      ensureFileReadable(data) {
        const statSync2 = isomorph_default.statSync;
        if (!statSync2) {
          throw new Error(
            `This platform does not support reading the filesystem. Construct the Attachment
with a Blob/ArrayBuffer, or run the program on Node.js.`
          );
        }
        try {
          statSync2(data);
        } catch (e) {
          console.warn(`Failed to read file: ${e}`);
        }
      }
    };
    ExternalAttachment = class extends BaseAttachment {
      static {
        __name(this, "ExternalAttachment");
      }
      /**
       * The object that replaces this `ExternalAttachment` at upload time.
       */
      reference;
      _data;
      state;
      /**
       * Construct an external attachment.
       *
       * @param param A parameter object with:
       *
       * `url`: The fully qualified URL of the file in the external object store.
       *
       * `filename`: The desired name of the file in Braintrust after uploading.
       * This parameter is for visualization purposes only and has no effect on
       * attachment storage.
       *
       * `contentType`: The MIME type of the file.
       *
       * `state`: (Optional) For internal use.
       */
      constructor({ url, filename, contentType, state }) {
        super();
        this.reference = {
          type: EXTERNAL_ATTACHMENT,
          filename,
          content_type: contentType,
          url
        };
        this._data = this.initData();
      }
      /**
       * For ExternalAttachment, this is a no-op since the data already resides
       * in the external object store. It marks the attachment as already uploaded.
       *
       * @returns The attachment status, which will always indicate success.
       */
      async upload() {
        return { upload_status: "done" };
      }
      /**
       * The attachment contents. This is a lazy value that will read the attachment contents from the external object store on first access.
       */
      async data() {
        return this._data.get();
      }
      /**
       * A human-readable description for logging and debugging.
       *
       * @returns The debug object. The return type is not stable and may change in
       * a future release.
       */
      debugInfo() {
        return {
          url: this.reference.url,
          reference: this.reference,
          state: this.state
        };
      }
      initData() {
        return new LazyValue(async () => {
          const readonly = new ReadonlyAttachment(this.reference, this.state);
          return await readonly.data();
        });
      }
    };
    attachmentMetadataSchema = external_exports.object({
      downloadUrl: external_exports.string(),
      status: AttachmentStatus
    });
    ReadonlyAttachment = class {
      static {
        __name(this, "ReadonlyAttachment");
      }
      /**
       * Attachment metadata.
       */
      reference;
      _data;
      state;
      /**
       * Construct a ReadonlyAttachment.
       *
       * @param reference The `AttachmentReference` that should be read by the
       * `ReadonlyAttachment` object.
       * @param state (Optional) For internal use.
       * @returns The new `ReadonlyAttachment` object.
       */
      constructor(reference, state) {
        this.reference = reference;
        this.state = state;
        this._data = this.initDownloader();
      }
      /**
       * The attachment contents. This is a lazy value that will read the attachment
       * contents from the object store on first access.
       */
      async data() {
        return this._data.get();
      }
      /**
       * Returns the attachment contents as a base64-encoded URL that is suitable
       * for use in a prompt.
       *
       * @returns The attachment contents as a base64-encoded URL.
       */
      async asBase64Url() {
        const buf = await (await this.data()).arrayBuffer();
        const base64 = Buffer.from(buf).toString("base64");
        return `data:${this.reference.content_type};base64,${base64}`;
      }
      /**
       * Fetch the attachment metadata, which includes a downloadUrl and a status.
       * This will re-fetch the status each time in case it changes over time.
       */
      async metadata() {
        const state = this.state ?? _globalState;
        await state.login({});
        const params = {
          filename: this.reference.filename,
          content_type: this.reference.content_type,
          org_id: state.orgId || ""
        };
        if (this.reference.type === "braintrust_attachment") {
          params.key = this.reference.key;
        } else if (this.reference.type === "external_attachment") {
          params.url = this.reference.url;
        }
        const resp = await state.apiConn().get("/attachment", params);
        if (!resp.ok) {
          const errorStr = JSON.stringify(resp);
          throw new Error(`Invalid response from API server: ${errorStr}`);
        }
        return attachmentMetadataSchema.parse(await resp.json());
      }
      /**
       * Fetch the attachment upload status. This will re-fetch the status each time
       * in case it changes over time.
       */
      async status() {
        return (await this.metadata()).status;
      }
      initDownloader() {
        const download = /* @__PURE__ */ __name(async () => {
          const { downloadUrl, status } = await this.metadata();
          if (status.upload_status !== "done") {
            throw new Error(
              `Expected attachment status "done", got "${status.upload_status}"`
            );
          }
          const objResponse = await fetch(downloadUrl);
          if (objResponse.status !== 200) {
            const error22 = await objResponse.text();
            throw new Error(`Couldn't download attachment: ${error22}`);
          }
          return await objResponse.blob();
        }, "download");
        return new LazyValue(download);
      }
    };
    JSONAttachment = class extends Attachment {
      static {
        __name(this, "JSONAttachment");
      }
      /**
       * Construct a JSONAttachment from a JSON-serializable object.
       *
       * @param data The JSON object to attach. Must be JSON-serializable.
       * @param options Additional options:
       * - `filename`: The filename for the attachment (defaults to "data.json")
       * - `pretty`: Whether to pretty-print the JSON (defaults to false)
       * - `state`: (Optional) For internal use.
       *
       * @example
       * ```typescript
       * const largeTranscript = [
       *   { role: "user", content: "..." },
       *   { role: "assistant", content: "..." },
       *   // ... many more messages
       * ];
       *
       * logger.log({
       *   input: {
       *     type: "chat",
       *     transcript: new JSONAttachment(largeTranscript, { filename: "transcript.json" })
       *   }
       * });
       * ```
       */
      constructor(data, options) {
        const { filename = "data.json", pretty = false, state } = options ?? {};
        const jsonString = pretty ? JSON.stringify(data, null, 2) : JSON.stringify(data);
        const blob = new Blob([jsonString], { type: "application/json" });
        super({
          data: blob,
          filename,
          contentType: "application/json",
          state
        });
      }
    };
    ERR_PERMALINK = "https://braintrust.dev/error-generating-link";
    Logger = class {
      static {
        __name(this, "Logger");
      }
      state;
      lazyMetadata;
      _asyncFlush;
      computeMetadataArgs;
      lastStartTime;
      lazyId;
      calledStartSpan;
      // For type identification.
      kind = "logger";
      constructor(state, lazyMetadata, logOptions = {}) {
        this.lazyMetadata = lazyMetadata;
        this._asyncFlush = logOptions.asyncFlush;
        this.computeMetadataArgs = logOptions.computeMetadataArgs;
        this.lastStartTime = getCurrentUnixTimestamp();
        this.lazyId = new LazyValue(async () => await this.id);
        this.calledStartSpan = false;
        this.state = state;
      }
      get org_id() {
        return (async () => {
          return (await this.lazyMetadata.get()).org_id;
        })();
      }
      get project() {
        return (async () => {
          return (await this.lazyMetadata.get()).project;
        })();
      }
      get id() {
        return (async () => (await this.project).id)();
      }
      get loggingState() {
        return this.state;
      }
      parentObjectType() {
        return 2;
      }
      /**
       * Log a single event. The event will be batched and uploaded behind the scenes if `logOptions.asyncFlush` is true.
       *
       * @param event The event to log.
       * @param event.input: (Optional) the arguments that uniquely define a user input (an arbitrary, JSON serializable object).
       * @param event.output: (Optional) the output of your application, including post-processing (an arbitrary, JSON serializable object), that allows you to determine whether the result is correct or not. For example, in an app that generates SQL queries, the `output` should be the _result_ of the SQL query generated by the model, not the query itself, because there may be multiple valid queries that answer a single question.
       * @param event.expected: (Optional) the ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not. Braintrust currently does not compare `output` to `expected` for you, since there are so many different ways to do that correctly. Instead, these values are just used to help you navigate while digging into analyses. However, we may later use these values to re-score outputs or fine-tune your models.
       * @param event.error: (Optional) The error that occurred, if any. If you use tracing to run an experiment, errors are automatically logged when your code throws an exception.
       * @param event.scores: (Optional) a dictionary of numeric values (between 0 and 1) to log. The scores should give you a variety of signals that help you determine how accurate the outputs are compared to what you expect and diagnose failures. For example, a summarization app might have one score that tells you how accurate the summary is, and another that measures the word similarity between the generated and grouth truth summary. The word similarity score could help you determine whether the summarization was covering similar concepts or not. You can use these scores to help you sort, filter, and compare logs.
       * @param event.metadata: (Optional) a dictionary with additional data about the test example, model outputs, or just about anything else that's relevant, that you can use to help find and analyze examples later. For example, you could log the `prompt`, example's `id`, or anything else that would be useful to slice/dice later. The values in `metadata` can be any JSON-serializable type, but its keys must be strings.
       * @param event.metrics: (Optional) a dictionary of metrics to log. The following keys are populated automatically: "start", "end".
       * @param event.id: (Optional) a unique identifier for the event. If you don't provide one, BrainTrust will generate one for you.
       * @param options Additional logging options
       * @param options.allowConcurrentWithSpans in rare cases where you need to log at the top level separately from spans on the logger elsewhere, set this to true.
       * @returns The `id` of the logged event.
       */
      log(event, options) {
        if (this.calledStartSpan && !options?.allowConcurrentWithSpans) {
          throw new Error(
            "Cannot run toplevel `log` method while using spans. To log to the span, call `logger.traced` and then log with `span.log`"
          );
        }
        const span = this.startSpanImpl({ startTime: this.lastStartTime, event });
        this.lastStartTime = span.end();
        const ret = span.id;
        if (this.asyncFlush === true) {
          return ret;
        } else {
          return (async () => {
            await this.flush();
            return ret;
          })();
        }
      }
      /**
       * Create a new toplevel span underneath the logger. The name defaults to "root".
       *
       * See {@link Span.traced} for full details.
       */
      traced(callback, args) {
        const { setCurrent, ...argsRest } = args ?? {};
        const span = this.startSpan(argsRest);
        const ret = runCatchFinally(
          () => {
            if (setCurrent ?? true) {
              return withCurrent(span, callback);
            } else {
              return callback(span);
            }
          },
          (e) => {
            logError(span, e);
            throw e;
          },
          () => span.end()
        );
        if (this.asyncFlush) {
          return ret;
        } else {
          return (async () => {
            const awaitedRet = await ret;
            await this.flush();
            return awaitedRet;
          })();
        }
      }
      /**
       * Lower-level alternative to `traced`. This allows you to start a span yourself, and can be useful in situations
       * where you cannot use callbacks. However, spans started with `startSpan` will not be marked as the "current span",
       * so `currentSpan()` and `traced()` will be no-ops. If you want to mark a span as current, use `traced` instead.
       *
       * See {@link traced} for full details.
       */
      startSpan(args) {
        this.calledStartSpan = true;
        return this.startSpanImpl(args);
      }
      startSpanImpl(args) {
        return new SpanImpl({
          ...args,
          // Sometimes `args` gets passed directly into this function, and it contains an undefined value for `state`.
          // To ensure that we always use this logger's state, we override the `state` argument no matter what.
          state: this.state,
          ...startSpanParentArgs({
            state: this.state,
            parent: args?.parent,
            parentObjectType: this.parentObjectType(),
            parentObjectId: this.lazyId,
            parentComputeObjectMetadataArgs: this.computeMetadataArgs,
            parentSpanIds: args?.parentSpanIds,
            propagatedEvent: args?.propagatedEvent
          }),
          defaultRootType: "task"
          /* TASK */
        });
      }
      /**
       * Log feedback to an event. Feedback is used to save feedback scores, set an expected value, or add a comment.
       *
       * @param event
       * @param event.id The id of the event to log feedback for. This is the `id` returned by `log` or accessible as the `id` field of a span.
       * @param event.scores (Optional) a dictionary of numeric values (between 0 and 1) to log. These scores will be merged into the existing scores for the event.
       * @param event.expected (Optional) the ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not.
       * @param event.comment (Optional) an optional comment string to log about the event.
       * @param event.metadata (Optional) a dictionary with additional data about the feedback. If you have a `user_id`, you can log it here and access it in the Braintrust UI. Note, this metadata does not correspond to the main event itself, but rather the audit log attached to the event.
       * @param event.source (Optional) the source of the feedback. Must be one of "external" (default), "app", or "api".
       */
      logFeedback(event) {
        logFeedbackImpl(this.state, this.parentObjectType(), this.lazyId, event);
      }
      /**
       * Update a span in the experiment using its id. It is important that you only update a span once the original span has been fully written and flushed,
       * since otherwise updates to the span may conflict with the original span.
       *
       * @param event The event data to update the span with. Must include `id`. See {@link Experiment.log} for a full list of valid fields.
       */
      updateSpan(event) {
        const { id, ...eventRest } = event;
        if (!id) {
          throw new Error("Span id is required to update a span");
        }
        updateSpanImpl({
          state: this.state,
          parentObjectType: this.parentObjectType(),
          parentObjectId: this.lazyId,
          id,
          event: eventRest
        });
      }
      /**
       * Return a serialized representation of the logger that can be used to start subspans in other places.
       *
       * See {@link Span.startSpan} for more details.
       */
      async export() {
        return new (getSpanComponentsClass())({
          object_type: this.parentObjectType(),
          ...this.computeMetadataArgs && !this.lazyId.hasSucceeded ? { compute_object_metadata_args: this.computeMetadataArgs } : { object_id: await this.lazyId.get() }
        }).toStr();
      }
      /*
       * Flush any pending logs to the server.
       */
      async flush() {
        return await this.state.bgLogger().flush();
      }
      get asyncFlush() {
        return this._asyncFlush;
      }
    };
    TestBackgroundLogger = class {
      static {
        __name(this, "TestBackgroundLogger");
      }
      items = [];
      maskingFunction = null;
      log(items) {
        this.items.push(items);
      }
      setMaskingFunction(maskingFunction) {
        this.maskingFunction = maskingFunction;
      }
      async flush() {
        return Promise.resolve();
      }
      async drain() {
        const items = this.items;
        this.items = [];
        const events = [];
        for (const item of items) {
          for (const event of item) {
            events.push(await event.get());
          }
        }
        const batch = mergeRowBatch(events);
        let flatBatch = batch.flat();
        if (this.maskingFunction) {
          flatBatch = flatBatch.map((item) => {
            const maskedItem = { ...item };
            for (const field of REDACTION_FIELDS) {
              if (item[field] !== void 0) {
                const maskedValue = applyMaskingToField(
                  this.maskingFunction,
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  item[field],
                  field
                );
                if (maskedValue instanceof MaskingError) {
                  delete maskedItem[field];
                  if (maskedItem.error) {
                    maskedItem.error = `${maskedItem.error}; ${maskedValue.errorMsg}`;
                  } else {
                    maskedItem.error = maskedValue.errorMsg;
                  }
                } else {
                  maskedItem[field] = maskedValue;
                }
              }
            }
            return maskedItem;
          });
        }
        return flatBatch;
      }
    };
    BACKGROUND_LOGGER_BASE_SLEEP_TIME_S = 1;
    HTTPBackgroundLogger = class _HTTPBackgroundLogger {
      static {
        __name(this, "_HTTPBackgroundLogger");
      }
      apiConn;
      queue;
      activeFlush = Promise.resolve();
      activeFlushResolved = true;
      activeFlushError = void 0;
      onFlushError;
      maskingFunction = null;
      syncFlush = false;
      // 6 MB for the AWS lambda gateway (from our own testing).
      maxRequestSize = 6 * 1024 * 1024;
      defaultBatchSize = 100;
      numTries = 3;
      queueDropExceedingMaxsize = DEFAULT_QUEUE_SIZE;
      queueDropLoggingPeriod = 60;
      failedPublishPayloadsDir = void 0;
      allPublishPayloadsDir = void 0;
      _disabled = false;
      queueDropLoggingState = {
        numDropped: 0,
        lastLoggedTimestamp: 0
      };
      constructor(apiConn, opts) {
        opts = opts ?? {};
        this.apiConn = apiConn;
        const syncFlushEnv = Number(isomorph_default.getEnv("BRAINTRUST_SYNC_FLUSH"));
        if (!isNaN(syncFlushEnv)) {
          this.syncFlush = Boolean(syncFlushEnv);
        }
        const defaultBatchSizeEnv = Number(
          isomorph_default.getEnv("BRAINTRUST_DEFAULT_BATCH_SIZE")
        );
        if (!isNaN(defaultBatchSizeEnv)) {
          this.defaultBatchSize = defaultBatchSizeEnv;
        }
        const maxRequestSizeEnv = Number(isomorph_default.getEnv("BRAINTRUST_MAX_REQUEST_SIZE"));
        if (!isNaN(maxRequestSizeEnv)) {
          this.maxRequestSize = maxRequestSizeEnv;
        }
        const numTriesEnv = Number(isomorph_default.getEnv("BRAINTRUST_NUM_RETRIES"));
        if (!isNaN(numTriesEnv)) {
          this.numTries = numTriesEnv + 1;
        }
        const queueDropExceedingMaxsizeEnv = Number(
          isomorph_default.getEnv("BRAINTRUST_QUEUE_DROP_EXCEEDING_MAXSIZE")
        );
        if (!isNaN(queueDropExceedingMaxsizeEnv)) {
          this.queueDropExceedingMaxsize = queueDropExceedingMaxsizeEnv;
        }
        this.queue = new Queue(this.queueDropExceedingMaxsize);
        const queueDropLoggingPeriodEnv = Number(
          isomorph_default.getEnv("BRAINTRUST_QUEUE_DROP_LOGGING_PERIOD")
        );
        if (!isNaN(queueDropLoggingPeriodEnv)) {
          this.queueDropLoggingPeriod = queueDropLoggingPeriodEnv;
        }
        const failedPublishPayloadsDirEnv = isomorph_default.getEnv(
          "BRAINTRUST_FAILED_PUBLISH_PAYLOADS_DIR"
        );
        if (failedPublishPayloadsDirEnv) {
          this.failedPublishPayloadsDir = failedPublishPayloadsDirEnv;
        }
        const allPublishPayloadsDirEnv = isomorph_default.getEnv(
          "BRAINTRUST_ALL_PUBLISH_PAYLOADS_DIR"
        );
        if (allPublishPayloadsDirEnv) {
          this.allPublishPayloadsDir = allPublishPayloadsDirEnv;
        }
        if (!opts.noExitFlush) {
          isomorph_default.processOn("beforeExit", async () => {
            await this.flush();
          });
        }
        this.onFlushError = opts.onFlushError;
      }
      setMaskingFunction(maskingFunction) {
        this.maskingFunction = maskingFunction;
      }
      log(items) {
        if (this._disabled) {
          return;
        }
        const droppedItems = this.queue.push(...items);
        if (!this.syncFlush) {
          this.triggerActiveFlush();
        }
        if (droppedItems.length) {
          this.registerDroppedItemCount(droppedItems.length);
          if (this.allPublishPayloadsDir || this.failedPublishPayloadsDir) {
            this.dumpDroppedEvents(droppedItems);
          }
        }
      }
      async flush() {
        if (this.syncFlush) {
          this.triggerActiveFlush();
        }
        await this.activeFlush;
        if (this.activeFlushError) {
          const err = this.activeFlushError;
          this.activeFlushError = void 0;
          if (this.syncFlush) {
            throw err;
          }
        }
      }
      async flushOnce(args) {
        if (this._disabled) {
          this.queue.clear();
          return;
        }
        const batchSize = args?.batchSize ?? this.defaultBatchSize;
        const wrappedItems = this.queue.drain();
        const [allItems, attachments] = await this.unwrapLazyValues(wrappedItems);
        if (allItems.length === 0) {
          return;
        }
        const allItemsStr = allItems.map(
          (bucket) => bucket.map((item) => JSON.stringify(item))
        );
        const batchSets = batchItems({
          items: allItemsStr,
          batchMaxNumItems: batchSize,
          batchMaxNumBytes: this.maxRequestSize / 2
        });
        for (const batchSet of batchSets) {
          const postPromises = batchSet.map(
            (batch) => (async () => {
              try {
                await this.submitLogsRequest(batch);
                return { type: "success" };
              } catch (e) {
                return { type: "error", value: e };
              }
            })()
          );
          const results = await Promise.all(postPromises);
          const failingResultErrors = results.map((r) => r.type === "success" ? void 0 : r.value).filter((r) => r !== void 0);
          if (failingResultErrors.length) {
            throw new AggregateError(
              failingResultErrors,
              `Encountered the following errors while logging:`
            );
          }
        }
        const attachmentErrors = [];
        for (const attachment of attachments) {
          try {
            const result = await attachment.upload();
            if (result.upload_status === "error") {
              throw new Error(result.error_message);
            }
          } catch (error22) {
            attachmentErrors.push(error22);
          }
        }
        if (attachmentErrors.length === 1) {
          throw attachmentErrors[0];
        } else if (attachmentErrors.length > 1) {
          throw new AggregateError(
            attachmentErrors,
            `Encountered the following errors while uploading attachments:`
          );
        }
        if (this.queue.length() > 0) {
          await this.flushOnce(args);
        }
      }
      async unwrapLazyValues(wrappedItems) {
        for (let i = 0; i < this.numTries; ++i) {
          try {
            const items = await Promise.all(wrappedItems.map((x) => x.get()));
            const attachments = [];
            items.forEach((item) => extractAttachments(item, attachments));
            let mergedItems = mergeRowBatch(items);
            if (this.maskingFunction) {
              mergedItems = mergedItems.map(
                (batch) => batch.map((item) => {
                  const maskedItem = { ...item };
                  for (const field of REDACTION_FIELDS) {
                    if (item[field] !== void 0) {
                      const maskedValue = applyMaskingToField(
                        this.maskingFunction,
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        item[field],
                        field
                      );
                      if (maskedValue instanceof MaskingError) {
                        delete maskedItem[field];
                        if (maskedItem.error) {
                          maskedItem.error = `${maskedItem.error}; ${maskedValue.errorMsg}`;
                        } else {
                          maskedItem.error = maskedValue.errorMsg;
                        }
                      } else {
                        maskedItem[field] = maskedValue;
                      }
                    }
                  }
                  return maskedItem;
                })
              );
            }
            return [mergedItems, attachments];
          } catch (e) {
            let errmsg = "Encountered error when constructing records to flush";
            const isRetrying = i + 1 < this.numTries;
            if (isRetrying) {
              errmsg += ". Retrying";
            }
            console.warn(errmsg);
            if (!isRetrying) {
              console.warn(
                `Failed to construct log records to flush after ${this.numTries} attempts. Dropping batch`
              );
              throw e;
            } else {
              console.warn(e);
              const sleepTimeS = BACKGROUND_LOGGER_BASE_SLEEP_TIME_S * 2 ** i;
              console.info(`Sleeping for ${sleepTimeS}s`);
              await new Promise(
                (resolve) => setTimeout(resolve, sleepTimeS * 1e3)
              );
            }
          }
        }
        throw new Error("Impossible");
      }
      async submitLogsRequest(items) {
        const conn = await this.apiConn.get();
        const dataStr = constructLogs3Data(items);
        if (this.allPublishPayloadsDir) {
          await _HTTPBackgroundLogger.writePayloadToDir({
            payloadDir: this.allPublishPayloadsDir,
            payload: dataStr
          });
        }
        for (let i = 0; i < this.numTries; i++) {
          const startTime = now();
          let error22 = void 0;
          try {
            await conn.post_json("logs3", dataStr);
          } catch (e) {
            error22 = e;
          }
          if (error22 === void 0) {
            return;
          }
          const isRetrying = i + 1 < this.numTries;
          const retryingText = isRetrying ? "" : " Retrying";
          const errorText = (() => {
            if (error22 instanceof FailedHTTPResponse) {
              return `${error22.status} (${error22.text}): ${error22.data}`;
            } else {
              return `${error22}`;
            }
          })();
          const errMsg = `log request failed. Elapsed time: ${(now() - startTime) / 1e3} seconds. Payload size: ${dataStr.length}.${retryingText}
Error: ${errorText}`;
          if (!isRetrying && this.failedPublishPayloadsDir) {
            await _HTTPBackgroundLogger.writePayloadToDir({
              payloadDir: this.failedPublishPayloadsDir,
              payload: dataStr
            });
            this.logFailedPayloadsDir();
          }
          if (!isRetrying) {
            console.warn(
              `log request failed after ${this.numTries} retries. Dropping batch`
            );
            throw new Error(errMsg);
          } else {
            console.warn(errMsg);
            if (isRetrying) {
              const sleepTimeS = BACKGROUND_LOGGER_BASE_SLEEP_TIME_S * 2 ** i;
              console.info(`Sleeping for ${sleepTimeS}s`);
              await new Promise(
                (resolve) => setTimeout(resolve, sleepTimeS * 1e3)
              );
            }
          }
        }
      }
      registerDroppedItemCount(numItems) {
        if (numItems <= 0) {
          return;
        }
        this.queueDropLoggingState.numDropped += numItems;
        const timeNow = getCurrentUnixTimestamp();
        if (timeNow - this.queueDropLoggingState.lastLoggedTimestamp > this.queueDropLoggingPeriod) {
          console.warn(
            `Dropped ${this.queueDropLoggingState.numDropped} elements due to full queue`
          );
          if (this.failedPublishPayloadsDir) {
            this.logFailedPayloadsDir();
          }
          this.queueDropLoggingState.numDropped = 0;
          this.queueDropLoggingState.lastLoggedTimestamp = timeNow;
        }
      }
      async dumpDroppedEvents(wrappedItems) {
        const publishPayloadsDir = [
          this.allPublishPayloadsDir,
          this.failedPublishPayloadsDir
        ].reduce((acc, x) => x ? acc.concat([x]) : acc, new Array());
        if (!(wrappedItems.length && publishPayloadsDir.length)) {
          return;
        }
        try {
          const [allItems, allAttachments] = await this.unwrapLazyValues(wrappedItems);
          const dataStr = constructLogs3Data(
            allItems.map((x) => JSON.stringify(x))
          );
          const attachmentStr = JSON.stringify(
            allAttachments.map((a) => a.debugInfo())
          );
          const payload = `{"data": ${dataStr}, "attachments": ${attachmentStr}}
`;
          for (const payloadDir of publishPayloadsDir) {
            await _HTTPBackgroundLogger.writePayloadToDir({ payloadDir, payload });
          }
        } catch (e) {
          console.error(e);
        }
      }
      static async writePayloadToDir({
        payloadDir,
        payload
      }) {
        if (!(isomorph_default.pathJoin && isomorph_default.mkdir && isomorph_default.writeFile)) {
          console.warn(
            "Cannot dump payloads: filesystem-operations not supported on this platform"
          );
          return;
        }
        const payloadFile = isomorph_default.pathJoin(
          payloadDir,
          `payload_${getCurrentUnixTimestamp()}_${v4_default().slice(0, 8)}.json`
        );
        try {
          await isomorph_default.mkdir(payloadDir, { recursive: true });
          await isomorph_default.writeFile(payloadFile, payload);
        } catch (e) {
          console.error(
            `Failed to write failed payload to output file ${payloadFile}:
`,
            e
          );
        }
      }
      triggerActiveFlush() {
        if (this.activeFlushResolved) {
          this.activeFlushResolved = false;
          this.activeFlushError = void 0;
          this.activeFlush = (async () => {
            try {
              await this.flushOnce();
            } catch (err) {
              if (err instanceof AggregateError) {
                for (const e of err.errors) {
                  this.onFlushError?.(e);
                }
              } else {
                this.onFlushError?.(err);
              }
              this.activeFlushError = err;
            } finally {
              this.activeFlushResolved = true;
            }
          })();
          (0, import_functions.waitUntil)(this.activeFlush);
        }
      }
      logFailedPayloadsDir() {
        console.warn(`Logging failed payloads to ${this.failedPublishPayloadsDir}`);
      }
      // Should only be called by BraintrustState.
      internalReplaceApiConn(apiConn) {
        this.apiConn = new LazyValue(async () => apiConn);
      }
      disable() {
        this._disabled = true;
      }
      enforceQueueSizeLimit(enforce) {
        this.queue.enforceQueueSizeLimit(enforce);
      }
    };
    traceable = wrapTraced;
    INTERNAL_BTQL_LIMIT = 1e3;
    MAX_BTQL_ITERATIONS = 1e4;
    ObjectFetcher = class {
      static {
        __name(this, "ObjectFetcher");
      }
      constructor(objectType2, pinnedVersion, mutateRecord, _internal_btql) {
        this.objectType = objectType2;
        this.pinnedVersion = pinnedVersion;
        this.mutateRecord = mutateRecord;
        this._internal_btql = _internal_btql;
      }
      _fetchedData = void 0;
      get id() {
        throw new Error("ObjectFetcher subclasses must have an 'id' attribute");
      }
      async getState() {
        throw new Error("ObjectFetcher subclasses must have a 'getState' method");
      }
      async *fetch() {
        const records = await this.fetchedData();
        for (const record of records) {
          yield record;
        }
      }
      [Symbol.asyncIterator]() {
        return this.fetch();
      }
      async fetchedData() {
        if (this._fetchedData === void 0) {
          const state = await this.getState();
          let data = void 0;
          let cursor = void 0;
          let iterations = 0;
          while (true) {
            const resp = await state.apiConn().post(
              `btql`,
              {
                query: {
                  ...this._internal_btql,
                  select: [
                    {
                      op: "star"
                    }
                  ],
                  from: {
                    op: "function",
                    name: {
                      op: "ident",
                      name: [this.objectType]
                    },
                    args: [
                      {
                        op: "literal",
                        value: await this.id
                      }
                    ]
                  },
                  cursor,
                  limit: INTERNAL_BTQL_LIMIT
                },
                use_columnstore: false,
                brainstore_realtime: true
              },
              { headers: { "Accept-Encoding": "gzip" } }
            );
            const respJson = await resp.json();
            data = (data ?? []).concat(respJson.data);
            if (!respJson.cursor) {
              break;
            }
            cursor = respJson.cursor;
            iterations++;
            if (iterations > MAX_BTQL_ITERATIONS) {
              throw new Error("Too many BTQL iterations");
            }
          }
          this._fetchedData = this.mutateRecord ? data?.map(this.mutateRecord) : data;
        }
        return this._fetchedData || [];
      }
      clearCache() {
        this._fetchedData = void 0;
      }
      async version() {
        if (this.pinnedVersion !== void 0) {
          return this.pinnedVersion;
        } else {
          const fetchedData = await this.fetchedData();
          let maxVersion = void 0;
          for (const record of fetchedData) {
            const xactId = String(record[TRANSACTION_ID_FIELD] ?? "0");
            if (maxVersion === void 0 || xactId > maxVersion) {
              maxVersion = xactId;
            }
          }
          return maxVersion;
        }
      }
    };
    Experiment2 = class extends ObjectFetcher {
      static {
        __name(this, "Experiment2");
      }
      lazyMetadata;
      dataset;
      lastStartTime;
      lazyId;
      calledStartSpan;
      state;
      // For type identification.
      kind = "experiment";
      constructor(state, lazyMetadata, dataset) {
        super("experiment", void 0, (r) => enrichAttachments(r, state));
        this.lazyMetadata = lazyMetadata;
        this.dataset = dataset;
        this.lastStartTime = getCurrentUnixTimestamp();
        this.lazyId = new LazyValue(async () => await this.id);
        this.calledStartSpan = false;
        this.state = state;
      }
      get id() {
        return (async () => {
          return (await this.lazyMetadata.get()).experiment.id;
        })();
      }
      get loggingState() {
        return this.state;
      }
      /**
       * Wait for the experiment ID to be resolved. This is useful for ensuring the ID
       * is available synchronously in child spans (for OTEL parent attributes).
       * @internal
       */
      async _waitForId() {
        await this.lazyId.get().catch(() => {
        });
      }
      get name() {
        return (async () => {
          return (await this.lazyMetadata.get()).experiment.name;
        })();
      }
      get project() {
        return (async () => {
          return (await this.lazyMetadata.get()).project;
        })();
      }
      parentObjectType() {
        return 1;
      }
      async getState() {
        await this.lazyMetadata.get();
        return this.state;
      }
      /**
       * Log a single event to the experiment. The event will be batched and uploaded behind the scenes.
       *
       * @param event The event to log.
       * @param event.input: The arguments that uniquely define a test case (an arbitrary, JSON serializable object). Later on, Braintrust will use the `input` to know whether two test cases are the same between experiments, so they should not contain experiment-specific state. A simple rule of thumb is that if you run the same experiment twice, the `input` should be identical.
       * @param event.output: The output of your application, including post-processing (an arbitrary, JSON serializable object), that allows you to determine whether the result is correct or not. For example, in an app that generates SQL queries, the `output` should be the _result_ of the SQL query generated by the model, not the query itself, because there may be multiple valid queries that answer a single question.
       * @param event.expected: (Optional) The ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not. Braintrust currently does not compare `output` to `expected` for you, since there are so many different ways to do that correctly. Instead, these values are just used to help you navigate your experiments while digging into analyses. However, we may later use these values to re-score outputs or fine-tune your models.
       * @param event.error: (Optional) The error that occurred, if any. If you use tracing to run an experiment, errors are automatically logged when your code throws an exception.
       * @param event.scores: A dictionary of numeric values (between 0 and 1) to log. The scores should give you a variety of signals that help you determine how accurate the outputs are compared to what you expect and diagnose failures. For example, a summarization app might have one score that tells you how accurate the summary is, and another that measures the word similarity between the generated and grouth truth summary. The word similarity score could help you determine whether the summarization was covering similar concepts or not. You can use these scores to help you sort, filter, and compare experiments.
       * @param event.metadata: (Optional) a dictionary with additional data about the test example, model outputs, or just about anything else that's relevant, that you can use to help find and analyze examples later. For example, you could log the `prompt`, example's `id`, or anything else that would be useful to slice/dice later. The values in `metadata` can be any JSON-serializable type, but its keys must be strings.
       * @param event.metrics: (Optional) a dictionary of metrics to log. The following keys are populated automatically: "start", "end".
       * @param event.id: (Optional) a unique identifier for the event. If you don't provide one, BrainTrust will generate one for you.
       * @param event.dataset_record_id: (Optional) the id of the dataset record that this event is associated with. This field is required if and only if the experiment is associated with a dataset. This field is unused and will be removed in a future version.
       * @param options Additional logging options
       * @param options.allowConcurrentWithSpans in rare cases where you need to log at the top level separately from spans on the experiment elsewhere, set this to true.
       * @returns The `id` of the logged event.
       */
      log(event, options) {
        if (this.calledStartSpan && !options?.allowConcurrentWithSpans) {
          throw new Error(
            "Cannot run toplevel `log` method while using spans. To log to the span, call `experiment.traced` and then log with `span.log`"
          );
        }
        event = validateAndSanitizeExperimentLogFullArgs(event, !!this.dataset);
        const span = this.startSpanImpl({ startTime: this.lastStartTime, event });
        this.lastStartTime = span.end();
        return span.id;
      }
      /**
       * Create a new toplevel span underneath the experiment. The name defaults to "root".
       *
       * See {@link Span.traced} for full details.
       */
      traced(callback, args) {
        const { setCurrent, ...argsRest } = args ?? {};
        const span = this.startSpan(argsRest);
        const ret = runCatchFinally(
          () => {
            if (setCurrent ?? true) {
              return withCurrent(span, callback);
            } else {
              return callback(span);
            }
          },
          (e) => {
            logError(span, e);
            throw e;
          },
          () => span.end()
        );
        return ret;
      }
      /**
       * Lower-level alternative to `traced`. This allows you to start a span yourself, and can be useful in situations
       * where you cannot use callbacks. However, spans started with `startSpan` will not be marked as the "current span",
       * so `currentSpan()` and `traced()` will be no-ops. If you want to mark a span as current, use `traced` instead.
       *
       * See {@link traced} for full details.
       */
      startSpan(args) {
        this.calledStartSpan = true;
        return this.startSpanImpl(args);
      }
      startSpanImpl(args) {
        return new SpanImpl({
          ...args,
          // Sometimes `args` gets passed directly into this function, and it contains an undefined value for `state`.
          // To ensure that we always use this experiment's state, we override the `state` argument no matter what.
          state: this.state,
          ...startSpanParentArgs({
            state: this.state,
            parent: args?.parent,
            parentObjectType: this.parentObjectType(),
            parentObjectId: this.lazyId,
            parentComputeObjectMetadataArgs: void 0,
            parentSpanIds: void 0,
            propagatedEvent: args?.propagatedEvent
          }),
          defaultRootType: "eval"
          /* EVAL */
        });
      }
      async fetchBaseExperiment() {
        const state = await this.getState();
        const conn = state.appConn();
        try {
          const resp = await conn.post("/api/base_experiment/get_id", {
            id: await this.id
          });
          const base = await resp.json();
          return {
            id: base["base_exp_id"],
            name: base["base_exp_name"]
          };
        } catch (e) {
          if (e instanceof FailedHTTPResponse && e.status === 400) {
            return null;
          } else {
            throw e;
          }
        }
      }
      /**
       * Summarize the experiment, including the scores (compared to the closest reference experiment) and metadata.
       *
       * @param options Options for summarizing the experiment.
       * @param options.summarizeScores Whether to summarize the scores. If False, only the metadata will be returned.
       * @param options.comparisonExperimentId The experiment to compare against. If None, the most recent experiment on the origin's main branch will be used.
       * @returns A summary of the experiment, including the scores (compared to the closest reference experiment) and metadata.
       */
      async summarize(options = {}) {
        let { summarizeScores = true, comparisonExperimentId = void 0 } = options || {};
        const state = await this.getState();
        const projectUrl = `${state.appPublicUrl}/app/${encodeURIComponent(
          state.orgName
        )}/p/${encodeURIComponent((await this.project).name)}`;
        const experimentUrl = `${projectUrl}/experiments/${encodeURIComponent(
          await this.name
        )}`;
        let scores = void 0;
        let metrics2 = void 0;
        let comparisonExperimentName = void 0;
        if (summarizeScores) {
          await this.flush();
          if (comparisonExperimentId === void 0) {
            const baseExperiment = await this.fetchBaseExperiment();
            if (baseExperiment !== null) {
              comparisonExperimentId = baseExperiment.id;
              comparisonExperimentName = baseExperiment.name;
            }
          }
          try {
            const results = await state.apiConn().get_json(
              "/experiment-comparison2",
              {
                experiment_id: await this.id,
                base_experiment_id: comparisonExperimentId
              },
              3
            );
            scores = results["scores"];
            metrics2 = results["metrics"];
          } catch (e) {
            console.warn(
              `Failed to fetch experiment scores and metrics: ${e}

View complete results in Braintrust or run experiment.summarize() again.`
            );
            scores = {};
            metrics2 = {};
          }
        }
        return {
          projectName: (await this.project).name,
          experimentName: await this.name,
          projectId: (await this.project).id,
          experimentId: await this.id,
          projectUrl,
          experimentUrl,
          comparisonExperimentName,
          scores: scores ?? {},
          metrics: metrics2 ?? {}
        };
      }
      /**
       * Log feedback to an event in the experiment. Feedback is used to save feedback scores, set an expected value, or add a comment.
       *
       * @param event
       * @param event.id The id of the event to log feedback for. This is the `id` returned by `log` or accessible as the `id` field of a span.
       * @param event.scores (Optional) a dictionary of numeric values (between 0 and 1) to log. These scores will be merged into the existing scores for the event.
       * @param event.expected (Optional) the ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not.
       * @param event.comment (Optional) an optional comment string to log about the event.
       * @param event.metadata (Optional) a dictionary with additional data about the feedback. If you have a `user_id`, you can log it here and access it in the Braintrust UI. Note, this metadata does not correspond to the main event itself, but rather the audit log attached to the event.
       * @param event.source (Optional) the source of the feedback. Must be one of "external" (default), "app", or "api".
       */
      logFeedback(event) {
        logFeedbackImpl(this.state, this.parentObjectType(), this.lazyId, event);
      }
      /**
       * Update a span in the experiment using its id. It is important that you only update a span once the original span has been fully written and flushed,
       * since otherwise updates to the span may conflict with the original span.
       *
       * @param event The event data to update the span with. Must include `id`. See {@link Experiment.log} for a full list of valid fields.
       */
      updateSpan(event) {
        const { id, ...eventRest } = event;
        if (!id) {
          throw new Error("Span id is required to update a span");
        }
        updateSpanImpl({
          state: this.state,
          parentObjectType: this.parentObjectType(),
          parentObjectId: this.lazyId,
          id,
          event: eventRest
        });
      }
      /**
       * Return a serialized representation of the experiment that can be used to start subspans in other places.
       *
       * See {@link Span.startSpan} for more details.
       */
      async export() {
        return new (getSpanComponentsClass())({
          object_type: this.parentObjectType(),
          object_id: await this.id
        }).toStr();
      }
      /**
       * Flush any pending rows to the server.
       */
      async flush() {
        return await this.state.bgLogger().flush();
      }
      /**
       * @deprecated This function is deprecated. You can simply remove it from your code.
       */
      async close() {
        console.warn(
          "close is deprecated and will be removed in a future version of braintrust. It is now a no-op and can be removed"
        );
        return this.id;
      }
    };
    ReadonlyExperiment = class extends ObjectFetcher {
      static {
        __name(this, "ReadonlyExperiment");
      }
      constructor(state, lazyMetadata) {
        super("experiment", void 0, (r) => enrichAttachments(r, state));
        this.state = state;
        this.lazyMetadata = lazyMetadata;
      }
      get id() {
        return (async () => {
          return (await this.lazyMetadata.get()).experiment.id;
        })();
      }
      get name() {
        return (async () => {
          return (await this.lazyMetadata.get()).experiment.name;
        })();
      }
      get loggingState() {
        return this.state;
      }
      async getState() {
        await this.lazyMetadata.get();
        return this.state;
      }
      async *asDataset() {
        const records = this.fetch();
        for await (const record of records) {
          if (record.root_span_id !== record.span_id) {
            continue;
          }
          const { output, expected: expectedRecord, metadata } = record;
          const expected = expectedRecord ?? output;
          yield {
            input: record.input,
            tags: record.tags,
            expected,
            metadata
          };
        }
      }
    };
    executionCounter = 0;
    SpanImpl = class _SpanImpl {
      static {
        __name(this, "_SpanImpl");
      }
      _state;
      isMerge;
      loggedEndTime;
      propagatedEvent;
      // For internal use only.
      parentObjectType;
      parentObjectId;
      parentComputeObjectMetadataArgs;
      _id;
      _spanId;
      _rootSpanId;
      _spanParents;
      kind = "span";
      constructor(args) {
        this._state = args.state;
        const spanAttributes = args.spanAttributes ?? {};
        const rawEvent = args.event ?? {};
        const type = args.type ?? (args.parentSpanIds ? void 0 : args.defaultRootType);
        this.loggedEndTime = void 0;
        this.parentObjectType = args.parentObjectType;
        this.parentObjectId = args.parentObjectId;
        this.parentComputeObjectMetadataArgs = args.parentComputeObjectMetadataArgs;
        this.propagatedEvent = args.propagatedEvent;
        if (this.propagatedEvent) {
          mergeDicts(rawEvent, this.propagatedEvent);
        }
        const { id: eventId, ...event } = rawEvent;
        const callerLocation = isomorph_default.getCallerLocation();
        const name = (() => {
          if (args.name) return args.name;
          if (!args.parentSpanIds) return "root";
          if (callerLocation) {
            const pathComponents = callerLocation.caller_filename.split("/");
            const filename = pathComponents[pathComponents.length - 1];
            return [callerLocation.caller_functionname].concat(
              filename ? [`${filename}:${callerLocation.caller_lineno}`] : []
            ).join(":");
          }
          return "subspan";
        })();
        const internalData = {
          metrics: {
            start: args.startTime ?? getCurrentUnixTimestamp()
          },
          context: { ...callerLocation },
          span_attributes: {
            name,
            type,
            ...spanAttributes,
            exec_counter: executionCounter++
          },
          created: (/* @__PURE__ */ new Date()).toISOString()
        };
        this._id = eventId ?? this._state.idGenerator.getSpanId();
        const resolvedIds = _resolveSpanIds(
          args.spanId,
          args.parentSpanIds,
          true,
          // Always lookup span parent from context manager unless explicit parent provided
          this._state.idGenerator,
          this._state.contextManager
        );
        this._spanId = resolvedIds.spanId;
        this._rootSpanId = resolvedIds.rootSpanId;
        this._spanParents = resolvedIds.spanParents;
        this.isMerge = false;
        this.logInternal({ event, internalData });
        this.isMerge = true;
      }
      get id() {
        return this._id;
      }
      get spanId() {
        return this._spanId;
      }
      get rootSpanId() {
        return this._rootSpanId;
      }
      get spanParents() {
        return this._spanParents ?? [];
      }
      setAttributes(args) {
        this.logInternal({ internalData: { span_attributes: args } });
      }
      setSpanParents(parents) {
        this.logInternal({ internalData: { span_parents: parents } });
      }
      log(event) {
        this.logInternal({ event });
      }
      logInternal({
        event,
        internalData
      }) {
        const [serializableInternalData, lazyInternalData] = splitLoggingData({
          event,
          internalData
        });
        const partialRecord = deepCopyEvent({
          id: this.id,
          span_id: this._spanId,
          root_span_id: this._rootSpanId,
          span_parents: this._spanParents,
          ...serializableInternalData,
          [IS_MERGE_FIELD]: this.isMerge
        });
        if (partialRecord.metrics?.end) {
          this.loggedEndTime = partialRecord.metrics?.end;
        }
        if ((partialRecord.tags ?? []).length > 0 && this._spanParents?.length) {
          throw new Error("Tags can only be logged to the root span");
        }
        const computeRecord = /* @__PURE__ */ __name(async () => ({
          ...partialRecord,
          ...Object.fromEntries(
            await Promise.all(
              Object.entries(lazyInternalData).map(async ([key, value]) => [
                key,
                await value.get()
              ])
            )
          ),
          ...new SpanComponentsV3({
            object_type: this.parentObjectType,
            object_id: await this.parentObjectId.get()
          }).objectIdFields()
        }), "computeRecord");
        this._state.bgLogger().log([new LazyValue(computeRecord)]);
      }
      logFeedback(event) {
        logFeedbackImpl(this._state, this.parentObjectType, this.parentObjectId, {
          ...event,
          id: this.id
        });
      }
      traced(callback, args) {
        const { setCurrent, ...argsRest } = args ?? {};
        const span = this.startSpan(argsRest);
        return runCatchFinally(
          () => {
            if (setCurrent ?? true) {
              return withCurrent(span, callback);
            } else {
              return callback(span);
            }
          },
          (e) => {
            logError(span, e);
            throw e;
          },
          () => span.end()
        );
      }
      startSpan(args) {
        const parentSpanIds = args?.parent ? void 0 : { spanId: this._spanId, rootSpanId: this._rootSpanId };
        return new _SpanImpl({
          state: this._state,
          ...args,
          ...startSpanParentArgs({
            state: this._state,
            parent: args?.parent,
            parentObjectType: this.parentObjectType,
            parentObjectId: this.parentObjectId,
            parentComputeObjectMetadataArgs: this.parentComputeObjectMetadataArgs,
            parentSpanIds,
            propagatedEvent: args?.propagatedEvent ?? this.propagatedEvent
          })
        });
      }
      startSpanWithParents(spanId, spanParents, args) {
        const parentSpanIds = {
          parentSpanIds: spanParents,
          rootSpanId: this._rootSpanId
        };
        return new _SpanImpl({
          state: this._state,
          ...args,
          ...startSpanParentArgs({
            state: this._state,
            parent: args?.parent,
            parentObjectType: this.parentObjectType,
            parentObjectId: this.parentObjectId,
            parentComputeObjectMetadataArgs: this.parentComputeObjectMetadataArgs,
            parentSpanIds,
            propagatedEvent: args?.propagatedEvent ?? this.propagatedEvent
          }),
          spanId
        });
      }
      end(args) {
        let endTime;
        let internalData = {};
        if (!this.loggedEndTime) {
          endTime = args?.endTime ?? getCurrentUnixTimestamp();
          internalData = { metrics: { end: endTime } };
        } else {
          endTime = this.loggedEndTime;
        }
        this.logInternal({ internalData });
        return endTime;
      }
      async export() {
        return new (getSpanComponentsClass())({
          object_type: this.parentObjectType,
          ...this.parentComputeObjectMetadataArgs && !this.parentObjectId.hasSucceeded ? { compute_object_metadata_args: this.parentComputeObjectMetadataArgs } : { object_id: await this.parentObjectId.get() },
          row_id: this.id,
          span_id: this._spanId,
          root_span_id: this._rootSpanId,
          propagated_event: this.propagatedEvent
        }).toStr();
      }
      async permalink() {
        return await permalink(await this.export(), {
          state: this._state
        });
      }
      link() {
        if (!this.id) {
          return NOOP_SPAN_PERMALINK;
        }
        try {
          const orgName = this._state.orgName;
          if (!orgName) {
            throw new Error("log-in-or-provide-org-name");
          }
          return this._link(orgName);
        } catch (e) {
          return getErrPermlink(e instanceof Error ? e.message : String(e));
        }
      }
      _link(orgName) {
        const appUrl = this._state.appUrl || "https://www.braintrust.dev";
        const baseUrl = `${appUrl}/app/${orgName}`;
        const args = this.parentComputeObjectMetadataArgs;
        switch (this.parentObjectType) {
          case 2: {
            const projectID = args?.project_id || this.parentObjectId.getSync().value;
            const projectName = args?.project_name;
            if (projectID) {
              return `${baseUrl}/object?object_type=project_logs&object_id=${projectID}&id=${this._id}`;
            } else if (projectName) {
              return `${baseUrl}/p/${projectName}/logs?oid=${this._id}`;
            } else {
              return getErrPermlink("provide-project-name-or-id");
            }
          }
          case 1: {
            const expID = args?.experiment_id || this.parentObjectId?.getSync()?.value;
            if (!expID) {
              return getErrPermlink("provide-experiment-id");
            } else {
              return `${baseUrl}/object?object_type=experiment&object_id=${expID}&id=${this._id}`;
            }
          }
          case 3: {
            return NOOP_SPAN_PERMALINK;
          }
          default: {
            const _exhaustive = this.parentObjectType;
            _exhaustive;
            return NOOP_SPAN_PERMALINK;
          }
        }
      }
      async flush() {
        return await this._state.bgLogger().flush();
      }
      close(args) {
        return this.end(args);
      }
      state() {
        return this._state;
      }
      /**
       * Internal method to get the OTEL parent string for this span.
       * This is used by OtelContextManager to set the braintrust.parent attribute.
       * @returns A string like "project_id:X" or "experiment_id:X", or undefined if no parent
       */
      _getOtelParent() {
        if (!this.parentObjectType) {
          return void 0;
        }
        try {
          if (this.parentObjectType === 2) {
            const syncResult = this.parentObjectId.getSync();
            const id = syncResult.value;
            const args = this.parentComputeObjectMetadataArgs;
            if (id) {
              return `project_id:${id}`;
            }
            const projectName = args?.project_name;
            if (projectName) {
              return `project_name:${projectName}`;
            }
          } else if (this.parentObjectType === 1) {
            const syncResult = this.parentObjectId.getSync();
            const id = syncResult.value;
            if (!syncResult.resolved) {
              this.parentObjectId.get().catch(() => {
              });
            }
            if (id) {
              return `experiment_id:${id}`;
            }
          }
        } catch (e) {
        }
        return void 0;
      }
      // Custom inspect for Node.js console.log
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `SpanImpl {
  kind: '${this.kind}',
  id: '${this.id}',
  spanId: '${this.spanId}',
  rootSpanId: '${this.rootSpanId}',
  spanParents: ${JSON.stringify(this.spanParents)}
}`;
      }
      // Custom toString
      toString() {
        return `SpanImpl(id=${this.id}, spanId=${this.spanId})`;
      }
    };
    Dataset2 = class extends ObjectFetcher {
      static {
        __name(this, "Dataset2");
      }
      constructor(state, lazyMetadata, pinnedVersion, legacy, _internal_btql) {
        const isLegacyDataset = legacy ?? DEFAULT_IS_LEGACY_DATASET;
        if (isLegacyDataset) {
          console.warn(
            `Records will be fetched from this dataset in the legacy format, with the "expected" field renamed to "output". Please update your code to use "expected", and use \`braintrust.initDataset()\` with \`{ useOutput: false }\`, which will become the default in a future version of Braintrust.`
          );
        }
        super(
          "dataset",
          pinnedVersion,
          (r) => (
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            ensureDatasetRecord(
              enrichAttachments(r, this.state),
              isLegacyDataset
            )
          ),
          _internal_btql
        );
        this.state = state;
        this.lazyMetadata = lazyMetadata;
      }
      lazyMetadata;
      __braintrust_dataset_marker = true;
      newRecords = 0;
      get id() {
        return (async () => {
          return (await this.lazyMetadata.get()).dataset.id;
        })();
      }
      get name() {
        return (async () => {
          return (await this.lazyMetadata.get()).dataset.name;
        })();
      }
      get project() {
        return (async () => {
          return (await this.lazyMetadata.get()).project;
        })();
      }
      get loggingState() {
        return this.state;
      }
      async getState() {
        await this.lazyMetadata.get();
        return this.state;
      }
      validateEvent({
        metadata,
        expected,
        output,
        tags
      }) {
        if (metadata !== void 0) {
          for (const key of Object.keys(metadata)) {
            if (typeof key !== "string") {
              throw new Error("metadata keys must be strings");
            }
          }
        }
        if (expected !== void 0 && output !== void 0) {
          throw new Error(
            "Only one of expected or output (deprecated) can be specified. Prefer expected."
          );
        }
        if (tags) {
          validateTags(tags);
        }
      }
      createArgs({
        id,
        input,
        expected,
        metadata,
        tags,
        output,
        isMerge
      }) {
        return new LazyValue(async () => {
          const dataset_id = await this.id;
          const expectedValue = expected === void 0 ? output : expected;
          const args = {
            id,
            input,
            expected: expectedValue,
            tags,
            dataset_id,
            created: !isMerge ? (/* @__PURE__ */ new Date()).toISOString() : void 0,
            //if we're merging/updating an event we will not add this ts
            metadata,
            ...!!isMerge ? {
              [IS_MERGE_FIELD]: true
            } : {}
          };
          return args;
        });
      }
      /**
       * Insert a single record to the dataset. The record will be batched and uploaded behind the scenes. If you pass in an `id`,
       * and a record with that `id` already exists, it will be overwritten (upsert).
       *
       * @param event The event to log.
       * @param event.input The argument that uniquely define an input case (an arbitrary, JSON serializable object).
       * @param event.expected The output of your application, including post-processing (an arbitrary, JSON serializable object).
       * @param event.tags (Optional) a list of strings that you can use to filter and group records later.
       * @param event.metadata (Optional) a dictionary with additional data about the test example, model outputs, or just
       * about anything else that's relevant, that you can use to help find and analyze examples later. For example, you could log the
       * `prompt`, example's `id`, or anything else that would be useful to slice/dice later. The values in `metadata` can be any
       * JSON-serializable type, but its keys must be strings.
       * @param event.id (Optional) a unique identifier for the event. If you don't provide one, Braintrust will generate one for you.
       * @param event.output: (Deprecated) The output of your application. Use `expected` instead.
       * @returns The `id` of the logged record.
       */
      insert({
        input,
        expected,
        metadata,
        tags,
        id,
        output
      }) {
        this.validateEvent({ metadata, expected, output, tags });
        const rowId = id || v4_default();
        const args = this.createArgs(
          deepCopyEvent({
            id: rowId,
            input,
            expected,
            metadata,
            tags,
            output,
            isMerge: false
          })
        );
        this.state.bgLogger().log([args]);
        this.newRecords++;
        return rowId;
      }
      /**
       * Update fields of a single record in the dataset. The updated fields will be batched and uploaded behind the scenes.
       * You must pass in an `id` of the record to update. Only the fields provided will be updated; other fields will remain unchanged.
       *
       * @param event The fields to update in the record.
       * @param event.id The unique identifier of the record to update.
       * @param event.input (Optional) The new input value for the record (an arbitrary, JSON serializable object).
       * @param event.expected (Optional) The new expected output value for the record (an arbitrary, JSON serializable object).
       * @param event.tags (Optional) A list of strings to update the tags of the record.
       * @param event.metadata (Optional) A dictionary to update the metadata of the record. The values in `metadata` can be any
       * JSON-serializable type, but its keys must be strings.
       * @returns The `id` of the updated record.
       */
      update({
        input,
        expected,
        metadata,
        tags,
        id
      }) {
        this.validateEvent({ metadata, expected, tags });
        const args = this.createArgs(
          deepCopyEvent({
            id,
            input,
            expected,
            metadata,
            tags,
            isMerge: true
          })
        );
        this.state.bgLogger().log([args]);
        return id;
      }
      delete(id) {
        const args = new LazyValue(async () => ({
          id,
          dataset_id: await this.id,
          created: (/* @__PURE__ */ new Date()).toISOString(),
          _object_delete: true
        }));
        this.state.bgLogger().log([args]);
        return id;
      }
      /**
       * Summarize the dataset, including high level metrics about its size and other metadata.
       * @param summarizeData Whether to summarize the data. If false, only the metadata will be returned.
       * @returns `DatasetSummary`
       * @returns A summary of the dataset.
       */
      async summarize(options = {}) {
        const { summarizeData = true } = options || {};
        await this.flush();
        const state = await this.getState();
        const projectUrl = `${state.appPublicUrl}/app/${encodeURIComponent(
          state.orgName
        )}/p/${encodeURIComponent((await this.project).name)}`;
        const datasetUrl = `${projectUrl}/datasets/${encodeURIComponent(
          await this.name
        )}`;
        let dataSummary;
        if (summarizeData) {
          const rawDataSummary = external_exports.object({
            total_records: external_exports.number()
          }).parse(
            await state.apiConn().get_json(
              "dataset-summary",
              {
                dataset_id: await this.id
              },
              3
            )
          );
          dataSummary = {
            newRecords: this.newRecords,
            totalRecords: rawDataSummary.total_records
          };
        }
        return {
          projectName: (await this.project).name,
          datasetName: await this.name,
          projectUrl,
          datasetUrl,
          dataSummary
        };
      }
      /**
       * Flush any pending rows to the server.
       */
      async flush() {
        return await this.state.bgLogger().flush();
      }
      /**
       * @deprecated This function is deprecated. You can simply remove it from your code.
       */
      async close() {
        console.warn(
          "close is deprecated and will be removed in a future version of braintrust. It is now a no-op and can be removed"
        );
        return this.id;
      }
      static isDataset(data) {
        return typeof data === "object" && data !== null && "__braintrust_dataset_marker" in data;
      }
    };
    Prompt2 = class _Prompt {
      static {
        __name(this, "_Prompt");
      }
      constructor(metadata, defaults2, noTrace) {
        this.metadata = metadata;
        this.defaults = defaults2;
        this.noTrace = noTrace;
      }
      parsedPromptData;
      hasParsedPromptData = false;
      __braintrust_prompt_marker = true;
      get id() {
        return this.metadata.id;
      }
      get projectId() {
        return this.metadata.project_id;
      }
      get name() {
        return "name" in this.metadata ? this.metadata.name : `Playground function ${this.metadata.id}`;
      }
      get slug() {
        return "slug" in this.metadata ? this.metadata.slug : this.metadata.id;
      }
      get prompt() {
        return this.getParsedPromptData()?.prompt;
      }
      get version() {
        return this.metadata[TRANSACTION_ID_FIELD];
      }
      get options() {
        return this.getParsedPromptData()?.options || {};
      }
      get promptData() {
        return this.getParsedPromptData();
      }
      /**
       * Build the prompt with the given formatting options. The args you pass in will
       * be forwarded to the mustache template that defines the prompt and rendered with
       * the `mustache-js` library.
       *
       * @param buildArgs Args to forward along to the prompt template.
       */
      build(buildArgs, options = {}) {
        return this.runBuild(buildArgs, {
          flavor: options.flavor ?? "chat",
          messages: options.messages,
          strict: options.strict
        });
      }
      /**
       * This is a special build method that first resolves attachment references, and then
       * calls the regular build method. You should use this if you are building prompts from
       * dataset rows that contain attachments.
       *
       * @param buildArgs Args to forward along to the prompt template.
       */
      async buildWithAttachments(buildArgs, options = {}) {
        const hydrated = buildArgs instanceof Object ? await resolveAttachmentsToBase64(buildArgs, options.state) : buildArgs;
        return this.runBuild(hydrated, {
          flavor: options.flavor ?? "chat",
          messages: options.messages,
          strict: options.strict
        });
      }
      runBuild(buildArgs, options) {
        const { flavor } = options;
        const params = {
          ...this.defaults,
          ...Object.fromEntries(
            Object.entries(this.options.params || {}).filter(
              ([k, _v]) => !BRAINTRUST_PARAMS.includes(k)
            )
          ),
          ...!isEmpty(this.options.model) ? {
            model: this.options.model
          } : {}
        };
        if (!("model" in params) || isEmpty(params.model)) {
          throw new Error(
            "No model specified. Either specify it in the prompt or as a default"
          );
        }
        const spanInfo = this.noTrace ? {} : {
          span_info: {
            metadata: {
              prompt: this.id ? {
                variables: buildArgs,
                id: this.id,
                project_id: this.projectId,
                version: this.version,
                ..."prompt_session_id" in this.metadata ? { prompt_session_id: this.metadata.prompt_session_id } : {}
              } : void 0
            }
          }
        };
        const prompt = this.prompt;
        if (!prompt) {
          throw new Error("Empty prompt");
        }
        const dictArgParsed = external_exports.record(external_exports.unknown()).safeParse(buildArgs);
        const variables = {
          input: buildArgs,
          ...dictArgParsed.success ? dictArgParsed.data : {}
        };
        const renderedPrompt = _Prompt.renderPrompt({
          prompt,
          buildArgs,
          options
        });
        if (flavor === "chat") {
          if (renderedPrompt.type !== "chat") {
            throw new Error(
              "Prompt is a completion prompt. Use buildCompletion() instead"
            );
          }
          return {
            ...renderPromptParams(params, variables, { strict: options.strict }),
            ...spanInfo,
            messages: renderedPrompt.messages,
            ...renderedPrompt.tools ? {
              tools: ChatCompletionTool.array().parse(JSON.parse(renderedPrompt.tools))
            } : void 0
          };
        } else if (flavor === "completion") {
          if (renderedPrompt.type !== "completion") {
            throw new Error(`Prompt is a chat prompt. Use flavor: 'chat' instead`);
          }
          return {
            ...renderPromptParams(params, variables, { strict: options.strict }),
            ...spanInfo,
            prompt: renderedPrompt.content
          };
        } else {
          throw new Error("never!");
        }
      }
      static renderPrompt({
        prompt,
        buildArgs,
        options
      }) {
        const escape2 = /* @__PURE__ */ __name((v) => {
          if (v === void 0) {
            throw new Error("Missing!");
          } else if (typeof v === "string") {
            return v;
          } else if (v instanceof ReadonlyAttachment) {
            throw new Error(
              "Use buildWithAttachments() to build prompts with attachments"
            );
          } else {
            return JSON.stringify(v);
          }
        }, "escape");
        const dictArgParsed = external_exports.record(external_exports.unknown()).safeParse(buildArgs);
        const variables = {
          input: buildArgs,
          ...dictArgParsed.success ? dictArgParsed.data : {}
        };
        if (prompt.type === "chat") {
          const render3 = /* @__PURE__ */ __name((template) => {
            if (options.strict) {
              lintTemplate(template, variables);
            }
            return mustache_default.render(template, variables, void 0, {
              escape: escape2
            });
          }, "render");
          const baseMessages = (prompt.messages || []).map(
            (m) => renderMessage(render3, m)
          );
          const hasSystemPrompt = baseMessages.some((m) => m.role === "system");
          const messages = [
            ...baseMessages,
            ...(options.messages ?? []).filter(
              (m) => !(hasSystemPrompt && m.role === "system")
            )
          ];
          return {
            type: "chat",
            messages,
            ...prompt.tools?.trim() ? {
              tools: render3(prompt.tools)
            } : void 0
          };
        } else if (prompt.type === "completion") {
          if (options.messages) {
            throw new Error(
              "extra messages are not supported for completion prompts"
            );
          }
          if (options.strict) {
            lintTemplate(prompt.content, variables);
          }
          return {
            type: "completion",
            content: mustache_default.render(prompt.content, variables, void 0, {
              escape: escape2
            })
          };
        } else {
          const _ = prompt;
          throw new Error(`Invalid prompt type: ${_}`);
        }
      }
      getParsedPromptData() {
        if (!this.hasParsedPromptData) {
          this.parsedPromptData = PromptData.parse(this.metadata.prompt_data);
          this.hasParsedPromptData = true;
        }
        return this.parsedPromptData;
      }
      static isPrompt(data) {
        return typeof data === "object" && data !== null && "__braintrust_prompt_marker" in data;
      }
      static fromPromptData(name, promptData) {
        return new _Prompt(
          {
            name,
            slug: name,
            prompt_data: promptData
          },
          {},
          false
        );
      }
    };
    TEST_API_KEY = "___TEST_API_KEY__THIS_IS_NOT_REAL___";
    _exportsForTestingOnly = {
      extractAttachments,
      deepCopyEvent,
      useTestBackgroundLogger,
      clearTestBackgroundLogger,
      simulateLoginForTests,
      simulateLogoutForTests,
      setInitialTestState,
      initTestExperiment,
      isGeneratorFunction,
      isAsyncGeneratorFunction,
      resetIdGenStateForTests
    };
  }
});
init_isomorph();
var COMMON_BASE_BRANCHES = ["main", "master", "develop"];
async function currentRepo() {
  try {
    const git = simpleGit();
    if (await git.checkIsRepo()) {
      return git;
    } else {
      return null;
    }
  } catch (e) {
    return null;
  }
}
__name(currentRepo, "currentRepo");
var _baseBranch = null;
async function getBaseBranch(remote = void 0) {
  if (_baseBranch === null) {
    const git = await currentRepo();
    if (git === null) {
      throw new Error("Not in a git repo");
    }
    const remoteName = remote ?? (await git.getRemotes())[0]?.name;
    if (!remoteName) {
      throw new Error("No remote found");
    }
    let branch = null;
    const repoBranches = new Set((await git.branchLocal()).all);
    const matchingBaseBranches = COMMON_BASE_BRANCHES.filter(
      (b) => repoBranches.has(b)
    );
    if (matchingBaseBranches.length === 1) {
      branch = matchingBaseBranches[0];
    } else {
      try {
        const remoteInfo = await git.remote(["show", remoteName]);
        if (!remoteInfo) {
          throw new Error(`Could not find remote ${remoteName}`);
        }
        const match = remoteInfo.match(/\s*HEAD branch:\s*(.*)$/m);
        if (!match) {
          throw new Error(`Could not find HEAD branch in remote ${remoteName}`);
        }
        branch = match[1];
      } catch {
        branch = "main";
      }
    }
    _baseBranch = { remote: remoteName, branch };
  }
  return _baseBranch;
}
__name(getBaseBranch, "getBaseBranch");
async function getBaseBranchAncestor(remote = void 0) {
  const git = await currentRepo();
  if (git === null) {
    throw new Error("Not in a git repo");
  }
  const { remote: remoteName, branch: baseBranch } = await getBaseBranch(remote);
  const isDirty2 = (await git.diffSummary()).files.length > 0;
  const head = isDirty2 ? "HEAD" : "HEAD^";
  try {
    const ancestor = await git.raw([
      "merge-base",
      head,
      `${remoteName}/${baseBranch}`
    ]);
    return ancestor.trim();
  } catch (e) {
    return void 0;
  }
}
__name(getBaseBranchAncestor, "getBaseBranchAncestor");
async function getPastNAncestors(n = 1e3, remote = void 0) {
  const git = await currentRepo();
  if (git === null) {
    return [];
  }
  let ancestor = void 0;
  try {
    ancestor = await getBaseBranchAncestor(remote);
  } catch (e) {
    console.warn(
      "Skipping git metadata. This is likely because the repository has not been published to a remote yet.",
      `${e}`
    );
  }
  if (!ancestor) {
    return [];
  }
  const commits = await git.log({ from: ancestor, to: "HEAD", maxCount: n });
  return commits.all.map((c) => c.hash);
}
__name(getPastNAncestors, "getPastNAncestors");
async function attempt(fn) {
  try {
    return await fn();
  } catch (e) {
    return void 0;
  }
}
__name(attempt, "attempt");
function truncateToByteLimit(s, byteLimit = 65536) {
  const encoded = new TextEncoder().encode(s);
  if (encoded.length <= byteLimit) {
    return s;
  }
  const truncated = encoded.subarray(0, byteLimit);
  return new TextDecoder().decode(truncated);
}
__name(truncateToByteLimit, "truncateToByteLimit");
async function getRepoInfo(settings) {
  if (settings && settings.collect === "none") {
    return void 0;
  }
  const repo = await repoInfo();
  if (!repo || !settings || settings.collect === "all") {
    return repo;
  }
  let sanitized = {};
  settings.fields?.forEach((field) => {
    sanitized = { ...sanitized, [field]: repo[field] };
  });
  return sanitized;
}
__name(getRepoInfo, "getRepoInfo");
async function repoInfo() {
  const git = await currentRepo();
  if (git === null) {
    return void 0;
  }
  let commit = void 0;
  let commit_message = void 0;
  let commit_time = void 0;
  let author_name = void 0;
  let author_email = void 0;
  let tag = void 0;
  let branch = void 0;
  let git_diff = void 0;
  const dirty = (await git.diffSummary()).files.length > 0;
  commit = await attempt(async () => await git.revparse(["HEAD"]));
  commit_message = await attempt(
    async () => (await git.raw(["log", "-1", "--pretty=%B"])).trim()
  );
  commit_time = await attempt(
    async () => (await git.raw(["log", "-1", "--pretty=%cI"])).trim()
  );
  author_name = await attempt(
    async () => (await git.raw(["log", "-1", "--pretty=%aN"])).trim()
  );
  author_email = await attempt(
    async () => (await git.raw(["log", "-1", "--pretty=%aE"])).trim()
  );
  tag = await attempt(
    async () => (await git.raw(["describe", "--tags", "--exact-match", "--always"])).trim()
  );
  branch = await attempt(
    async () => (await git.raw(["rev-parse", "--abbrev-ref", "HEAD"])).trim()
  );
  if (dirty) {
    git_diff = await attempt(
      async () => truncateToByteLimit(await git.raw(["--no-ext-diff", "diff", "HEAD"]))
    );
  }
  return {
    commit,
    branch,
    tag,
    dirty,
    author_name,
    author_email,
    commit_message,
    commit_time,
    git_diff
  };
}
__name(repoInfo, "repoInfo");
init_isomorph();
function getStackTrace() {
  const trace22 = new Error().stack;
  if (typeof trace22 !== "string") {
    return [];
  }
  const traceLines = trace22.split("\n");
  const out = [];
  const stackFrameRegex = /at(.*)\((.*):(\d+):(\d+)\)/;
  for (const traceLine of traceLines.slice(1)) {
    const matches = traceLine.match(stackFrameRegex);
    if (matches === null || matches.length !== 5) {
      continue;
    }
    const entry = {
      functionName: matches[1].trim(),
      fileName: matches[2],
      lineNo: parseInt(matches[3])
    };
    if (!isNaN(entry.lineNo)) {
      out.push(entry);
    }
  }
  return out;
}
__name(getStackTrace, "getStackTrace");
function getCallerLocation() {
  let thisDir = void 0;
  const entries = getStackTrace();
  for (const frame of entries) {
    if (thisDir === void 0) {
      thisDir = isomorph_default.pathDirname?.(frame.fileName);
    }
    if (isomorph_default.pathDirname?.(frame.fileName) !== thisDir) {
      return {
        caller_functionname: frame.functionName,
        caller_filename: frame.fileName,
        caller_lineno: frame.lineNo
      };
    }
  }
  return void 0;
}
__name(getCallerLocation, "getCallerLocation");
init_logger();
function configureNode() {
  isomorph_default.getRepoInfo = getRepoInfo;
  isomorph_default.getPastNAncestors = getPastNAncestors;
  isomorph_default.getEnv = (name) => process.env[name];
  isomorph_default.getCallerLocation = getCallerLocation;
  isomorph_default.newAsyncLocalStorage = () => new AsyncLocalStorage();
  isomorph_default.processOn = (event, handler) => {
    process.on(event, handler);
  };
  isomorph_default.pathJoin = path.join;
  isomorph_default.pathDirname = path.dirname;
  isomorph_default.mkdir = mkdir;
  isomorph_default.writeFile = writeFile;
  isomorph_default.readFile = readFile;
  isomorph_default.readdir = readdir;
  isomorph_default.stat = stat;
  isomorph_default.statSync = statSync;
  isomorph_default.utimes = utimes;
  isomorph_default.unlink = unlink;
  isomorph_default.homedir = homedir;
  isomorph_default.gzip = promisify(zlib.gzip);
  isomorph_default.gunzip = promisify(zlib.gunzip);
  isomorph_default.hash = (data) => crypto2.createHash("sha256").update(data).digest("hex");
  _internalSetInitialState();
}
__name(configureNode, "configureNode");
var exports_node_exports = {};
__export3(exports_node_exports, {
  AISpanProcessor: /* @__PURE__ */ __name(() => AISpanProcessor, "AISpanProcessor"),
  Attachment: /* @__PURE__ */ __name(() => Attachment, "Attachment"),
  BaseAttachment: /* @__PURE__ */ __name(() => BaseAttachment, "BaseAttachment"),
  BaseExperiment: /* @__PURE__ */ __name(() => BaseExperiment, "BaseExperiment"),
  BraintrustExporter: /* @__PURE__ */ __name(() => BraintrustExporter, "BraintrustExporter"),
  BraintrustMiddleware: /* @__PURE__ */ __name(() => BraintrustMiddleware, "BraintrustMiddleware"),
  BraintrustSpanProcessor: /* @__PURE__ */ __name(() => BraintrustSpanProcessor, "BraintrustSpanProcessor"),
  BraintrustState: /* @__PURE__ */ __name(() => BraintrustState, "BraintrustState"),
  BraintrustStream: /* @__PURE__ */ __name(() => BraintrustStream, "BraintrustStream"),
  CodeFunction: /* @__PURE__ */ __name(() => CodeFunction, "CodeFunction"),
  CodePrompt: /* @__PURE__ */ __name(() => CodePrompt, "CodePrompt"),
  ContextManager: /* @__PURE__ */ __name(() => ContextManager, "ContextManager"),
  Dataset: /* @__PURE__ */ __name(() => Dataset2, "Dataset"),
  ERR_PERMALINK: /* @__PURE__ */ __name(() => ERR_PERMALINK, "ERR_PERMALINK"),
  Eval: /* @__PURE__ */ __name(() => Eval, "Eval"),
  EvalResultWithSummary: /* @__PURE__ */ __name(() => EvalResultWithSummary, "EvalResultWithSummary"),
  Experiment: /* @__PURE__ */ __name(() => Experiment2, "Experiment"),
  ExternalAttachment: /* @__PURE__ */ __name(() => ExternalAttachment, "ExternalAttachment"),
  FailedHTTPResponse: /* @__PURE__ */ __name(() => FailedHTTPResponse, "FailedHTTPResponse"),
  IDGenerator: /* @__PURE__ */ __name(() => IDGenerator, "IDGenerator"),
  INTERNAL_BTQL_LIMIT: /* @__PURE__ */ __name(() => INTERNAL_BTQL_LIMIT, "INTERNAL_BTQL_LIMIT"),
  JSONAttachment: /* @__PURE__ */ __name(() => JSONAttachment, "JSONAttachment"),
  LEGACY_CACHED_HEADER: /* @__PURE__ */ __name(() => LEGACY_CACHED_HEADER, "LEGACY_CACHED_HEADER"),
  LazyValue: /* @__PURE__ */ __name(() => LazyValue, "LazyValue"),
  Logger: /* @__PURE__ */ __name(() => Logger, "Logger"),
  NOOP_SPAN: /* @__PURE__ */ __name(() => NOOP_SPAN, "NOOP_SPAN"),
  NOOP_SPAN_PERMALINK: /* @__PURE__ */ __name(() => NOOP_SPAN_PERMALINK, "NOOP_SPAN_PERMALINK"),
  NoopSpan: /* @__PURE__ */ __name(() => NoopSpan, "NoopSpan"),
  OTELIDGenerator: /* @__PURE__ */ __name(() => OTELIDGenerator, "OTELIDGenerator"),
  Project: /* @__PURE__ */ __name(() => Project2, "Project"),
  ProjectNameIdMap: /* @__PURE__ */ __name(() => ProjectNameIdMap, "ProjectNameIdMap"),
  Prompt: /* @__PURE__ */ __name(() => Prompt2, "Prompt"),
  PromptBuilder: /* @__PURE__ */ __name(() => PromptBuilder, "PromptBuilder"),
  ReadonlyAttachment: /* @__PURE__ */ __name(() => ReadonlyAttachment, "ReadonlyAttachment"),
  ReadonlyExperiment: /* @__PURE__ */ __name(() => ReadonlyExperiment, "ReadonlyExperiment"),
  Reporter: /* @__PURE__ */ __name(() => Reporter, "Reporter"),
  ScorerBuilder: /* @__PURE__ */ __name(() => ScorerBuilder, "ScorerBuilder"),
  SpanImpl: /* @__PURE__ */ __name(() => SpanImpl, "SpanImpl"),
  TestBackgroundLogger: /* @__PURE__ */ __name(() => TestBackgroundLogger, "TestBackgroundLogger"),
  ToolBuilder: /* @__PURE__ */ __name(() => ToolBuilder, "ToolBuilder"),
  UUIDGenerator: /* @__PURE__ */ __name(() => UUIDGenerator, "UUIDGenerator"),
  X_CACHED_HEADER: /* @__PURE__ */ __name(() => X_CACHED_HEADER, "X_CACHED_HEADER"),
  _exportsForTestingOnly: /* @__PURE__ */ __name(() => _exportsForTestingOnly, "_exportsForTestingOnly"),
  _internalGetGlobalState: /* @__PURE__ */ __name(() => _internalGetGlobalState, "_internalGetGlobalState"),
  _internalSetInitialState: /* @__PURE__ */ __name(() => _internalSetInitialState, "_internalSetInitialState"),
  braintrustStreamChunkSchema: /* @__PURE__ */ __name(() => braintrustStreamChunkSchema, "braintrustStreamChunkSchema"),
  buildLocalSummary: /* @__PURE__ */ __name(() => buildLocalSummary, "buildLocalSummary"),
  createFinalValuePassThroughStream: /* @__PURE__ */ __name(() => createFinalValuePassThroughStream, "createFinalValuePassThroughStream"),
  currentExperiment: /* @__PURE__ */ __name(() => currentExperiment, "currentExperiment"),
  currentLogger: /* @__PURE__ */ __name(() => currentLogger, "currentLogger"),
  currentSpan: /* @__PURE__ */ __name(() => currentSpan, "currentSpan"),
  deepCopyEvent: /* @__PURE__ */ __name(() => deepCopyEvent, "deepCopyEvent"),
  defaultErrorScoreHandler: /* @__PURE__ */ __name(() => defaultErrorScoreHandler, "defaultErrorScoreHandler"),
  deserializePlainStringAsJSON: /* @__PURE__ */ __name(() => deserializePlainStringAsJSON, "deserializePlainStringAsJSON"),
  devNullWritableStream: /* @__PURE__ */ __name(() => devNullWritableStream, "devNullWritableStream"),
  flush: /* @__PURE__ */ __name(() => flush, "flush"),
  getContextManager: /* @__PURE__ */ __name(() => getContextManager, "getContextManager"),
  getIdGenerator: /* @__PURE__ */ __name(() => getIdGenerator, "getIdGenerator"),
  getPromptVersions: /* @__PURE__ */ __name(() => getPromptVersions, "getPromptVersions"),
  getSpanParentObject: /* @__PURE__ */ __name(() => getSpanParentObject, "getSpanParentObject"),
  graph: /* @__PURE__ */ __name(() => graph_framework_exports, "graph"),
  init: /* @__PURE__ */ __name(() => init, "init"),
  initDataset: /* @__PURE__ */ __name(() => initDataset, "initDataset"),
  initExperiment: /* @__PURE__ */ __name(() => initExperiment, "initExperiment"),
  initFunction: /* @__PURE__ */ __name(() => initFunction, "initFunction"),
  initLogger: /* @__PURE__ */ __name(() => initLogger, "initLogger"),
  invoke: /* @__PURE__ */ __name(() => invoke, "invoke"),
  loadPrompt: /* @__PURE__ */ __name(() => loadPrompt, "loadPrompt"),
  log: /* @__PURE__ */ __name(() => log3, "log"),
  logError: /* @__PURE__ */ __name(() => logError, "logError"),
  login: /* @__PURE__ */ __name(() => login, "login"),
  loginToState: /* @__PURE__ */ __name(() => loginToState, "loginToState"),
  newId: /* @__PURE__ */ __name(() => newId, "newId"),
  parseCachedHeader: /* @__PURE__ */ __name(() => parseCachedHeader, "parseCachedHeader"),
  permalink: /* @__PURE__ */ __name(() => permalink, "permalink"),
  projects: /* @__PURE__ */ __name(() => projects, "projects"),
  promptContentsSchema: /* @__PURE__ */ __name(() => promptContentsSchema, "promptContentsSchema"),
  promptDefinitionSchema: /* @__PURE__ */ __name(() => promptDefinitionSchema, "promptDefinitionSchema"),
  promptDefinitionToPromptData: /* @__PURE__ */ __name(() => promptDefinitionToPromptData, "promptDefinitionToPromptData"),
  promptDefinitionWithToolsSchema: /* @__PURE__ */ __name(() => promptDefinitionWithToolsSchema, "promptDefinitionWithToolsSchema"),
  renderMessage: /* @__PURE__ */ __name(() => renderMessage, "renderMessage"),
  renderPromptParams: /* @__PURE__ */ __name(() => renderPromptParams, "renderPromptParams"),
  reportFailures: /* @__PURE__ */ __name(() => reportFailures, "reportFailures"),
  runEvaluator: /* @__PURE__ */ __name(() => runEvaluator, "runEvaluator"),
  setFetch: /* @__PURE__ */ __name(() => setFetch, "setFetch"),
  setMaskingFunction: /* @__PURE__ */ __name(() => setMaskingFunction, "setMaskingFunction"),
  spanComponentsToObjectId: /* @__PURE__ */ __name(() => spanComponentsToObjectId, "spanComponentsToObjectId"),
  startSpan: /* @__PURE__ */ __name(() => startSpan, "startSpan"),
  summarize: /* @__PURE__ */ __name(() => summarize, "summarize"),
  toolFunctionDefinitionSchema: /* @__PURE__ */ __name(() => ToolFunctionDefinition, "toolFunctionDefinitionSchema"),
  traceable: /* @__PURE__ */ __name(() => traceable, "traceable"),
  traced: /* @__PURE__ */ __name(() => traced, "traced"),
  updateSpan: /* @__PURE__ */ __name(() => updateSpan, "updateSpan"),
  withCurrent: /* @__PURE__ */ __name(() => withCurrent, "withCurrent"),
  withDataset: /* @__PURE__ */ __name(() => withDataset, "withDataset"),
  withExperiment: /* @__PURE__ */ __name(() => withExperiment, "withExperiment"),
  withLogger: /* @__PURE__ */ __name(() => withLogger, "withLogger"),
  withParent: /* @__PURE__ */ __name(() => withParent, "withParent"),
  wrapAISDK: /* @__PURE__ */ __name(() => wrapAISDK, "wrapAISDK"),
  wrapAISDKModel: /* @__PURE__ */ __name(() => wrapAISDKModel, "wrapAISDKModel"),
  wrapAnthropic: /* @__PURE__ */ __name(() => wrapAnthropic, "wrapAnthropic"),
  wrapClaudeAgentSDK: /* @__PURE__ */ __name(() => wrapClaudeAgentSDK, "wrapClaudeAgentSDK"),
  wrapMastraAgent: /* @__PURE__ */ __name(() => wrapMastraAgent, "wrapMastraAgent"),
  wrapOpenAI: /* @__PURE__ */ __name(() => wrapOpenAI, "wrapOpenAI"),
  wrapOpenAIv4: /* @__PURE__ */ __name(() => wrapOpenAIv4, "wrapOpenAIv4"),
  wrapTraced: /* @__PURE__ */ __name(() => wrapTraced, "wrapTraced")
});
init_logger();
init_stream();
init_generated_types();
init_logger();
init_stream();
async function invoke(args) {
  const {
    orgName,
    apiKey,
    appUrl,
    forceLogin,
    fetch: fetch2,
    input,
    messages,
    parent: parentArg,
    metadata,
    tags,
    state: stateArg,
    stream,
    mode,
    schema,
    strict,
    ...functionIdArgs
  } = args;
  const state = stateArg ?? _internalGetGlobalState();
  await state.login({
    orgName,
    apiKey,
    appUrl,
    forceLogin,
    fetch: fetch2
  });
  const parent = parentArg ? typeof parentArg === "string" ? parentArg : await parentArg.export() : await getSpanParentObject().export();
  const functionId = FunctionId.safeParse({
    function_id: functionIdArgs.function_id,
    project_name: functionIdArgs.projectName,
    slug: functionIdArgs.slug,
    global_function: functionIdArgs.globalFunction,
    prompt_session_id: functionIdArgs.promptSessionId,
    prompt_session_function_id: functionIdArgs.promptSessionFunctionId,
    version: functionIdArgs.version
  });
  if (!functionId.success) {
    throw new Error(
      `Invalid function ID arguments: ${functionId.error.message}`
    );
  }
  const request = {
    ...functionId.data,
    input,
    messages,
    parent,
    metadata,
    tags,
    stream,
    mode,
    strict
  };
  const resp = await state.proxyConn().post(`function/invoke`, request, {
    headers: {
      Accept: stream ? "text/event-stream" : "application/json"
    }
  });
  if (stream) {
    if (!resp.body) {
      throw new Error("Received empty stream body");
    }
    return new BraintrustStream(resp.body);
  } else {
    const data = await resp.json();
    return schema ? schema.parse(data) : data;
  }
}
__name(invoke, "invoke");
function initFunction({
  projectName,
  slug,
  version: version2
}) {
  const f = /* @__PURE__ */ __name(async (input) => {
    return await invoke({
      projectName,
      slug,
      version: version2,
      input
    });
  }, "f");
  Object.defineProperty(f, "name", {
    value: `initFunction-${projectName}-${slug}-${version2 ?? "latest"}`
  });
  return f;
}
__name(initFunction, "initFunction");
init_id_gen();
init_util2();
function initialParams(fn) {
  return function(...args) {
    var callback = args.pop();
    return fn.call(this, args, callback);
  };
}
__name(initialParams, "initialParams");
var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
function fallback(fn) {
  setTimeout(fn, 0);
}
__name(fallback, "fallback");
function wrap(defer) {
  return (fn, ...args) => defer(() => fn(...args));
}
__name(wrap, "wrap");
var _defer$1;
if (hasQueueMicrotask) {
  _defer$1 = queueMicrotask;
} else if (hasSetImmediate) {
  _defer$1 = setImmediate;
} else if (hasNextTick) {
  _defer$1 = process.nextTick;
} else {
  _defer$1 = fallback;
}
var setImmediate$1 = wrap(_defer$1);
function asyncify(func) {
  if (isAsync2(func)) {
    return function(...args) {
      const callback = args.pop();
      const promise = func.apply(this, args);
      return handlePromise(promise, callback);
    };
  }
  return initialParams(function(args, callback) {
    var result;
    try {
      result = func.apply(this, args);
    } catch (e) {
      return callback(e);
    }
    if (result && typeof result.then === "function") {
      return handlePromise(result, callback);
    } else {
      callback(null, result);
    }
  });
}
__name(asyncify, "asyncify");
function handlePromise(promise, callback) {
  return promise.then((value) => {
    invokeCallback(callback, null, value);
  }, (err) => {
    invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
  });
}
__name(handlePromise, "handlePromise");
function invokeCallback(callback, error22, value) {
  try {
    callback(error22, value);
  } catch (err) {
    setImmediate$1((e) => {
      throw e;
    }, err);
  }
}
__name(invokeCallback, "invokeCallback");
function isAsync2(fn) {
  return fn[Symbol.toStringTag] === "AsyncFunction";
}
__name(isAsync2, "isAsync");
function isAsyncGenerator(fn) {
  return fn[Symbol.toStringTag] === "AsyncGenerator";
}
__name(isAsyncGenerator, "isAsyncGenerator");
function isAsyncIterable(obj) {
  return typeof obj[Symbol.asyncIterator] === "function";
}
__name(isAsyncIterable, "isAsyncIterable");
function wrapAsync(asyncFn) {
  if (typeof asyncFn !== "function") throw new Error("expected a function");
  return isAsync2(asyncFn) ? asyncify(asyncFn) : asyncFn;
}
__name(wrapAsync, "wrapAsync");
function awaitify(asyncFn, arity) {
  if (!arity) arity = asyncFn.length;
  if (!arity) throw new Error("arity is undefined");
  function awaitable(...args) {
    if (typeof args[arity - 1] === "function") {
      return asyncFn.apply(this, args);
    }
    return new Promise((resolve, reject2) => {
      args[arity - 1] = (err, ...cbArgs) => {
        if (err) return reject2(err);
        resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
      };
      asyncFn.apply(this, args);
    });
  }
  __name(awaitable, "awaitable");
  return awaitable;
}
__name(awaitify, "awaitify");
function applyEach$1(eachfn) {
  return /* @__PURE__ */ __name(function applyEach2(fns, ...callArgs) {
    const go = awaitify(function(callback) {
      var that = this;
      return eachfn(fns, (fn, cb) => {
        wrapAsync(fn).apply(that, callArgs.concat(cb));
      }, callback);
    });
    return go;
  }, "applyEach2");
}
__name(applyEach$1, "applyEach$1");
function _asyncMap(eachfn, arr, iteratee, callback) {
  arr = arr || [];
  var results = [];
  var counter = 0;
  var _iteratee = wrapAsync(iteratee);
  return eachfn(arr, (value, _, iterCb) => {
    var index = counter++;
    _iteratee(value, (err, v) => {
      results[index] = v;
      iterCb(err);
    });
  }, (err) => {
    callback(err, results);
  });
}
__name(_asyncMap, "_asyncMap");
function isArrayLike2(value) {
  return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
}
__name(isArrayLike2, "isArrayLike");
var breakLoop = {};
function once2(fn) {
  function wrapper(...args) {
    if (fn === null) return;
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  }
  __name(wrapper, "wrapper");
  Object.assign(wrapper, fn);
  return wrapper;
}
__name(once2, "once");
function getIterator(coll) {
  return coll[Symbol.iterator] && coll[Symbol.iterator]();
}
__name(getIterator, "getIterator");
function createArrayIterator(coll) {
  var i = -1;
  var len = coll.length;
  return /* @__PURE__ */ __name(function next2() {
    return ++i < len ? { value: coll[i], key: i } : null;
  }, "next");
}
__name(createArrayIterator, "createArrayIterator");
function createES2015Iterator(iterator) {
  var i = -1;
  return /* @__PURE__ */ __name(function next2() {
    var item = iterator.next();
    if (item.done)
      return null;
    i++;
    return { value: item.value, key: i };
  }, "next");
}
__name(createES2015Iterator, "createES2015Iterator");
function createObjectIterator(obj) {
  var okeys = obj ? Object.keys(obj) : [];
  var i = -1;
  var len = okeys.length;
  return /* @__PURE__ */ __name(function next2() {
    var key = okeys[++i];
    if (key === "__proto__") {
      return next2();
    }
    return i < len ? { value: obj[key], key } : null;
  }, "next");
}
__name(createObjectIterator, "createObjectIterator");
function createIterator(coll) {
  if (isArrayLike2(coll)) {
    return createArrayIterator(coll);
  }
  var iterator = getIterator(coll);
  return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}
__name(createIterator, "createIterator");
function onlyOnce(fn) {
  return function(...args) {
    if (fn === null) throw new Error("Callback was already called.");
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  };
}
__name(onlyOnce, "onlyOnce");
function asyncEachOfLimit(generator, limit2, iteratee, callback) {
  let done = false;
  let canceled = false;
  let awaiting = false;
  let running = 0;
  let idx = 0;
  function replenish() {
    if (running >= limit2 || awaiting || done) return;
    awaiting = true;
    generator.next().then(({ value, done: iterDone }) => {
      if (canceled || done) return;
      awaiting = false;
      if (iterDone) {
        done = true;
        if (running <= 0) {
          callback(null);
        }
        return;
      }
      running++;
      iteratee(value, idx, iterateeCallback);
      idx++;
      replenish();
    }).catch(handleError);
  }
  __name(replenish, "replenish");
  function iterateeCallback(err, result) {
    running -= 1;
    if (canceled) return;
    if (err) return handleError(err);
    if (err === false) {
      done = true;
      canceled = true;
      return;
    }
    if (result === breakLoop || done && running <= 0) {
      done = true;
      return callback(null);
    }
    replenish();
  }
  __name(iterateeCallback, "iterateeCallback");
  function handleError(err) {
    if (canceled) return;
    awaiting = false;
    done = true;
    callback(err);
  }
  __name(handleError, "handleError");
  replenish();
}
__name(asyncEachOfLimit, "asyncEachOfLimit");
var eachOfLimit$2 = /* @__PURE__ */ __name((limit2) => {
  return (obj, iteratee, callback) => {
    callback = once2(callback);
    if (limit2 <= 0) {
      throw new RangeError("concurrency limit cannot be less than 1");
    }
    if (!obj) {
      return callback(null);
    }
    if (isAsyncGenerator(obj)) {
      return asyncEachOfLimit(obj, limit2, iteratee, callback);
    }
    if (isAsyncIterable(obj)) {
      return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit2, iteratee, callback);
    }
    var nextElem = createIterator(obj);
    var done = false;
    var canceled = false;
    var running = 0;
    var looping = false;
    function iterateeCallback(err, value) {
      if (canceled) return;
      running -= 1;
      if (err) {
        done = true;
        callback(err);
      } else if (err === false) {
        done = true;
        canceled = true;
      } else if (value === breakLoop || done && running <= 0) {
        done = true;
        return callback(null);
      } else if (!looping) {
        replenish();
      }
    }
    __name(iterateeCallback, "iterateeCallback");
    function replenish() {
      looping = true;
      while (running < limit2 && !done) {
        var elem = nextElem();
        if (elem === null) {
          done = true;
          if (running <= 0) {
            callback(null);
          }
          return;
        }
        running += 1;
        iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
      }
      looping = false;
    }
    __name(replenish, "replenish");
    replenish();
  };
}, "eachOfLimit$2");
function eachOfLimit(coll, limit2, iteratee, callback) {
  return eachOfLimit$2(limit2)(coll, wrapAsync(iteratee), callback);
}
__name(eachOfLimit, "eachOfLimit");
var eachOfLimit$1 = awaitify(eachOfLimit, 4);
function eachOfArrayLike(coll, iteratee, callback) {
  callback = once2(callback);
  var index = 0, completed = 0, { length } = coll, canceled = false;
  if (length === 0) {
    callback(null);
  }
  function iteratorCallback(err, value) {
    if (err === false) {
      canceled = true;
    }
    if (canceled === true) return;
    if (err) {
      callback(err);
    } else if (++completed === length || value === breakLoop) {
      callback(null);
    }
  }
  __name(iteratorCallback, "iteratorCallback");
  for (; index < length; index++) {
    iteratee(coll[index], index, onlyOnce(iteratorCallback));
  }
}
__name(eachOfArrayLike, "eachOfArrayLike");
function eachOfGeneric(coll, iteratee, callback) {
  return eachOfLimit$1(coll, Infinity, iteratee, callback);
}
__name(eachOfGeneric, "eachOfGeneric");
function eachOf(coll, iteratee, callback) {
  var eachOfImplementation = isArrayLike2(coll) ? eachOfArrayLike : eachOfGeneric;
  return eachOfImplementation(coll, wrapAsync(iteratee), callback);
}
__name(eachOf, "eachOf");
var eachOf$1 = awaitify(eachOf, 3);
function map(coll, iteratee, callback) {
  return _asyncMap(eachOf$1, coll, iteratee, callback);
}
__name(map, "map");
var map$1 = awaitify(map, 3);
var applyEach = applyEach$1(map$1);
function eachOfSeries(coll, iteratee, callback) {
  return eachOfLimit$1(coll, 1, iteratee, callback);
}
__name(eachOfSeries, "eachOfSeries");
var eachOfSeries$1 = awaitify(eachOfSeries, 3);
function mapSeries(coll, iteratee, callback) {
  return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
}
__name(mapSeries, "mapSeries");
var mapSeries$1 = awaitify(mapSeries, 3);
var applyEachSeries = applyEach$1(mapSeries$1);
var PROMISE_SYMBOL = Symbol("promiseCallback");
var DLL = class {
  static {
    __name(this, "DLL");
  }
  constructor() {
    this.head = this.tail = null;
    this.length = 0;
  }
  removeLink(node) {
    if (node.prev) node.prev.next = node.next;
    else this.head = node.next;
    if (node.next) node.next.prev = node.prev;
    else this.tail = node.prev;
    node.prev = node.next = null;
    this.length -= 1;
    return node;
  }
  empty() {
    while (this.head) this.shift();
    return this;
  }
  insertAfter(node, newNode) {
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next) node.next.prev = newNode;
    else this.tail = newNode;
    node.next = newNode;
    this.length += 1;
  }
  insertBefore(node, newNode) {
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev) node.prev.next = newNode;
    else this.head = newNode;
    node.prev = newNode;
    this.length += 1;
  }
  unshift(node) {
    if (this.head) this.insertBefore(this.head, node);
    else setInitial(this, node);
  }
  push(node) {
    if (this.tail) this.insertAfter(this.tail, node);
    else setInitial(this, node);
  }
  shift() {
    return this.head && this.removeLink(this.head);
  }
  pop() {
    return this.tail && this.removeLink(this.tail);
  }
  toArray() {
    return [...this];
  }
  *[Symbol.iterator]() {
    var cur = this.head;
    while (cur) {
      yield cur.data;
      cur = cur.next;
    }
  }
  remove(testFn) {
    var curr = this.head;
    while (curr) {
      var { next: next2 } = curr;
      if (testFn(curr)) {
        this.removeLink(curr);
      }
      curr = next2;
    }
    return this;
  }
};
function setInitial(dll, node) {
  dll.length = 1;
  dll.head = dll.tail = node;
}
__name(setInitial, "setInitial");
function queue$1(worker, concurrency, payload) {
  if (concurrency == null) {
    concurrency = 1;
  } else if (concurrency === 0) {
    throw new RangeError("Concurrency must not be zero");
  }
  var _worker = wrapAsync(worker);
  var numRunning = 0;
  var workersList = [];
  const events = {
    error: [],
    drain: [],
    saturated: [],
    unsaturated: [],
    empty: []
  };
  function on2(event, handler) {
    events[event].push(handler);
  }
  __name(on2, "on");
  function once22(event, handler) {
    const handleAndRemove = /* @__PURE__ */ __name((...args) => {
      off2(event, handleAndRemove);
      handler(...args);
    }, "handleAndRemove");
    events[event].push(handleAndRemove);
  }
  __name(once22, "once2");
  function off2(event, handler) {
    if (!event) return Object.keys(events).forEach((ev) => events[ev] = []);
    if (!handler) return events[event] = [];
    events[event] = events[event].filter((ev) => ev !== handler);
  }
  __name(off2, "off");
  function trigger(event, ...args) {
    events[event].forEach((handler) => handler(...args));
  }
  __name(trigger, "trigger");
  var processingScheduled = false;
  function _insert(data, insertAtFront, rejectOnError, callback) {
    if (callback != null && typeof callback !== "function") {
      throw new Error("task callback must be a function");
    }
    q.started = true;
    var res, rej;
    function promiseCallback(err, ...args) {
      if (err) return rejectOnError ? rej(err) : res();
      if (args.length <= 1) return res(args[0]);
      res(args);
    }
    __name(promiseCallback, "promiseCallback");
    var item = q._createTaskItem(
      data,
      rejectOnError ? promiseCallback : callback || promiseCallback
    );
    if (insertAtFront) {
      q._tasks.unshift(item);
    } else {
      q._tasks.push(item);
    }
    if (!processingScheduled) {
      processingScheduled = true;
      setImmediate$1(() => {
        processingScheduled = false;
        q.process();
      });
    }
    if (rejectOnError || !callback) {
      return new Promise((resolve, reject2) => {
        res = resolve;
        rej = reject2;
      });
    }
  }
  __name(_insert, "_insert");
  function _createCB(tasks) {
    return function(err, ...args) {
      numRunning -= 1;
      for (var i = 0, l = tasks.length; i < l; i++) {
        var task = tasks[i];
        var index = workersList.indexOf(task);
        if (index === 0) {
          workersList.shift();
        } else if (index > 0) {
          workersList.splice(index, 1);
        }
        task.callback(err, ...args);
        if (err != null) {
          trigger("error", err, task.data);
        }
      }
      if (numRunning <= q.concurrency - q.buffer) {
        trigger("unsaturated");
      }
      if (q.idle()) {
        trigger("drain");
      }
      q.process();
    };
  }
  __name(_createCB, "_createCB");
  function _maybeDrain(data) {
    if (data.length === 0 && q.idle()) {
      setImmediate$1(() => trigger("drain"));
      return true;
    }
    return false;
  }
  __name(_maybeDrain, "_maybeDrain");
  const eventMethod = /* @__PURE__ */ __name((name) => (handler) => {
    if (!handler) {
      return new Promise((resolve, reject2) => {
        once22(name, (err, data) => {
          if (err) return reject2(err);
          resolve(data);
        });
      });
    }
    off2(name);
    on2(name, handler);
  }, "eventMethod");
  var isProcessing = false;
  var q = {
    _tasks: new DLL(),
    _createTaskItem(data, callback) {
      return {
        data,
        callback
      };
    },
    *[Symbol.iterator]() {
      yield* q._tasks[Symbol.iterator]();
    },
    concurrency,
    payload,
    buffer: concurrency / 4,
    started: false,
    paused: false,
    push(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data)) return;
        return data.map((datum) => _insert(datum, false, false, callback));
      }
      return _insert(data, false, false, callback);
    },
    pushAsync(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data)) return;
        return data.map((datum) => _insert(datum, false, true, callback));
      }
      return _insert(data, false, true, callback);
    },
    kill() {
      off2();
      q._tasks.empty();
    },
    unshift(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data)) return;
        return data.map((datum) => _insert(datum, true, false, callback));
      }
      return _insert(data, true, false, callback);
    },
    unshiftAsync(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data)) return;
        return data.map((datum) => _insert(datum, true, true, callback));
      }
      return _insert(data, true, true, callback);
    },
    remove(testFn) {
      q._tasks.remove(testFn);
    },
    process() {
      if (isProcessing) {
        return;
      }
      isProcessing = true;
      while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
        var tasks = [], data = [];
        var l = q._tasks.length;
        if (q.payload) l = Math.min(l, q.payload);
        for (var i = 0; i < l; i++) {
          var node = q._tasks.shift();
          tasks.push(node);
          workersList.push(node);
          data.push(node.data);
        }
        numRunning += 1;
        if (q._tasks.length === 0) {
          trigger("empty");
        }
        if (numRunning === q.concurrency) {
          trigger("saturated");
        }
        var cb = onlyOnce(_createCB(tasks));
        _worker(data, cb);
      }
      isProcessing = false;
    },
    length() {
      return q._tasks.length;
    },
    running() {
      return numRunning;
    },
    workersList() {
      return workersList;
    },
    idle() {
      return q._tasks.length + numRunning === 0;
    },
    pause() {
      q.paused = true;
    },
    resume() {
      if (q.paused === false) {
        return;
      }
      q.paused = false;
      setImmediate$1(q.process);
    }
  };
  Object.defineProperties(q, {
    saturated: {
      writable: false,
      value: eventMethod("saturated")
    },
    unsaturated: {
      writable: false,
      value: eventMethod("unsaturated")
    },
    empty: {
      writable: false,
      value: eventMethod("empty")
    },
    drain: {
      writable: false,
      value: eventMethod("drain")
    },
    error: {
      writable: false,
      value: eventMethod("error")
    }
  });
  return q;
}
__name(queue$1, "queue$1");
function reduce(coll, memo, iteratee, callback) {
  callback = once2(callback);
  var _iteratee = wrapAsync(iteratee);
  return eachOfSeries$1(coll, (x, i, iterCb) => {
    _iteratee(memo, x, (err, v) => {
      memo = v;
      iterCb(err);
    });
  }, (err) => callback(err, memo));
}
__name(reduce, "reduce");
var reduce$1 = awaitify(reduce, 4);
function mapLimit(coll, limit2, iteratee, callback) {
  return _asyncMap(eachOfLimit$2(limit2), coll, iteratee, callback);
}
__name(mapLimit, "mapLimit");
var mapLimit$1 = awaitify(mapLimit, 4);
function concatLimit(coll, limit2, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(coll, limit2, (val, iterCb) => {
    _iteratee(val, (err, ...args) => {
      if (err) return iterCb(err);
      return iterCb(err, args);
    });
  }, (err, mapResults) => {
    var result = [];
    for (var i = 0; i < mapResults.length; i++) {
      if (mapResults[i]) {
        result = result.concat(...mapResults[i]);
      }
    }
    return callback(err, result);
  });
}
__name(concatLimit, "concatLimit");
var concatLimit$1 = awaitify(concatLimit, 4);
function concat(coll, iteratee, callback) {
  return concatLimit$1(coll, Infinity, iteratee, callback);
}
__name(concat, "concat");
var concat$1 = awaitify(concat, 3);
function concatSeries(coll, iteratee, callback) {
  return concatLimit$1(coll, 1, iteratee, callback);
}
__name(concatSeries, "concatSeries");
var concatSeries$1 = awaitify(concatSeries, 3);
function _createTester(check, getResult) {
  return (eachfn, arr, _iteratee, cb) => {
    var testPassed = false;
    var testResult;
    const iteratee = wrapAsync(_iteratee);
    eachfn(arr, (value, _, callback) => {
      iteratee(value, (err, result) => {
        if (err || err === false) return callback(err);
        if (check(result) && !testResult) {
          testPassed = true;
          testResult = getResult(true, value);
          return callback(null, breakLoop);
        }
        callback();
      });
    }, (err) => {
      if (err) return cb(err);
      cb(null, testPassed ? testResult : getResult(false));
    });
  };
}
__name(_createTester, "_createTester");
function detect(coll, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
}
__name(detect, "detect");
var detect$1 = awaitify(detect, 3);
function detectLimit(coll, limit2, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(limit2), coll, iteratee, callback);
}
__name(detectLimit, "detectLimit");
var detectLimit$1 = awaitify(detectLimit, 4);
function detectSeries(coll, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback);
}
__name(detectSeries, "detectSeries");
var detectSeries$1 = awaitify(detectSeries, 3);
function consoleFunc(name) {
  return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
    if (typeof console === "object") {
      if (err) {
        if (console.error) {
          console.error(err);
        }
      } else if (console[name]) {
        resultArgs.forEach((x) => console[name](x));
      }
    }
  });
}
__name(consoleFunc, "consoleFunc");
var dir3 = consoleFunc("dir");
function doWhilst(iteratee, test, callback) {
  callback = onlyOnce(callback);
  var _fn = wrapAsync(iteratee);
  var _test = wrapAsync(test);
  var results;
  function next2(err, ...args) {
    if (err) return callback(err);
    if (err === false) return;
    results = args;
    _test(...args, check);
  }
  __name(next2, "next");
  function check(err, truth) {
    if (err) return callback(err);
    if (err === false) return;
    if (!truth) return callback(null, ...results);
    _fn(next2);
  }
  __name(check, "check");
  return check(null, true);
}
__name(doWhilst, "doWhilst");
var doWhilst$1 = awaitify(doWhilst, 3);
function _withoutIndex(iteratee) {
  return (value, index, callback) => iteratee(value, callback);
}
__name(_withoutIndex, "_withoutIndex");
function eachLimit$2(coll, iteratee, callback) {
  return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
__name(eachLimit$2, "eachLimit$2");
var each = awaitify(eachLimit$2, 3);
function eachLimit(coll, limit2, iteratee, callback) {
  return eachOfLimit$2(limit2)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
__name(eachLimit, "eachLimit");
var eachLimit$1 = awaitify(eachLimit, 4);
function eachSeries(coll, iteratee, callback) {
  return eachLimit$1(coll, 1, iteratee, callback);
}
__name(eachSeries, "eachSeries");
var eachSeries$1 = awaitify(eachSeries, 3);
function ensureAsync(fn) {
  if (isAsync2(fn)) return fn;
  return function(...args) {
    var callback = args.pop();
    var sync = true;
    args.push((...innerArgs) => {
      if (sync) {
        setImmediate$1(() => callback(...innerArgs));
      } else {
        callback(...innerArgs);
      }
    });
    fn.apply(this, args);
    sync = false;
  };
}
__name(ensureAsync, "ensureAsync");
function every(coll, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
}
__name(every, "every");
var every$1 = awaitify(every, 3);
function everyLimit(coll, limit2, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOfLimit$2(limit2), coll, iteratee, callback);
}
__name(everyLimit, "everyLimit");
var everyLimit$1 = awaitify(everyLimit, 4);
function everySeries(coll, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
}
__name(everySeries, "everySeries");
var everySeries$1 = awaitify(everySeries, 3);
function filterArray2(eachfn, arr, iteratee, callback) {
  var truthValues = new Array(arr.length);
  eachfn(arr, (x, index, iterCb) => {
    iteratee(x, (err, v) => {
      truthValues[index] = !!v;
      iterCb(err);
    });
  }, (err) => {
    if (err) return callback(err);
    var results = [];
    for (var i = 0; i < arr.length; i++) {
      if (truthValues[i]) results.push(arr[i]);
    }
    callback(null, results);
  });
}
__name(filterArray2, "filterArray");
function filterGeneric(eachfn, coll, iteratee, callback) {
  var results = [];
  eachfn(coll, (x, index, iterCb) => {
    iteratee(x, (err, v) => {
      if (err) return iterCb(err);
      if (v) {
        results.push({ index, value: x });
      }
      iterCb(err);
    });
  }, (err) => {
    if (err) return callback(err);
    callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
  });
}
__name(filterGeneric, "filterGeneric");
function _filter(eachfn, coll, iteratee, callback) {
  var filter2 = isArrayLike2(coll) ? filterArray2 : filterGeneric;
  return filter2(eachfn, coll, wrapAsync(iteratee), callback);
}
__name(_filter, "_filter");
function filter(coll, iteratee, callback) {
  return _filter(eachOf$1, coll, iteratee, callback);
}
__name(filter, "filter");
var filter$1 = awaitify(filter, 3);
function filterLimit(coll, limit2, iteratee, callback) {
  return _filter(eachOfLimit$2(limit2), coll, iteratee, callback);
}
__name(filterLimit, "filterLimit");
var filterLimit$1 = awaitify(filterLimit, 4);
function filterSeries(coll, iteratee, callback) {
  return _filter(eachOfSeries$1, coll, iteratee, callback);
}
__name(filterSeries, "filterSeries");
var filterSeries$1 = awaitify(filterSeries, 3);
function forever(fn, errback) {
  var done = onlyOnce(errback);
  var task = wrapAsync(ensureAsync(fn));
  function next2(err) {
    if (err) return done(err);
    if (err === false) return;
    task(next2);
  }
  __name(next2, "next");
  return next2();
}
__name(forever, "forever");
var forever$1 = awaitify(forever, 2);
function groupByLimit(coll, limit2, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(coll, limit2, (val, iterCb) => {
    _iteratee(val, (err, key) => {
      if (err) return iterCb(err);
      return iterCb(err, { key, val });
    });
  }, (err, mapResults) => {
    var result = {};
    var { hasOwnProperty } = Object.prototype;
    for (var i = 0; i < mapResults.length; i++) {
      if (mapResults[i]) {
        var { key } = mapResults[i];
        var { val } = mapResults[i];
        if (hasOwnProperty.call(result, key)) {
          result[key].push(val);
        } else {
          result[key] = [val];
        }
      }
    }
    return callback(err, result);
  });
}
__name(groupByLimit, "groupByLimit");
var groupByLimit$1 = awaitify(groupByLimit, 4);
var log22 = consoleFunc("log");
function mapValuesLimit(obj, limit2, iteratee, callback) {
  callback = once2(callback);
  var newObj = {};
  var _iteratee = wrapAsync(iteratee);
  return eachOfLimit$2(limit2)(obj, (val, key, next2) => {
    _iteratee(val, key, (err, result) => {
      if (err) return next2(err);
      newObj[key] = result;
      next2(err);
    });
  }, (err) => callback(err, newObj));
}
__name(mapValuesLimit, "mapValuesLimit");
var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
var _defer;
if (hasNextTick) {
  _defer = process.nextTick;
} else if (hasSetImmediate) {
  _defer = setImmediate;
} else {
  _defer = fallback;
}
var nextTick2 = wrap(_defer);
var _parallel = awaitify((eachfn, tasks, callback) => {
  var results = isArrayLike2(tasks) ? [] : {};
  eachfn(tasks, (task, key, taskCb) => {
    wrapAsync(task)((err, ...result) => {
      if (result.length < 2) {
        [result] = result;
      }
      results[key] = result;
      taskCb(err);
    });
  }, (err) => callback(err, results));
}, 3);
function queue(worker, concurrency) {
  var _worker = wrapAsync(worker);
  return queue$1((items, cb) => {
    _worker(items[0], cb);
  }, concurrency, 1);
}
__name(queue, "queue");
function race(tasks, callback) {
  callback = once2(callback);
  if (!Array.isArray(tasks)) return callback(new TypeError("First argument to race must be an array of functions"));
  if (!tasks.length) return callback();
  for (var i = 0, l = tasks.length; i < l; i++) {
    wrapAsync(tasks[i])(callback);
  }
}
__name(race, "race");
var race$1 = awaitify(race, 2);
function reject$2(eachfn, arr, _iteratee, callback) {
  const iteratee = wrapAsync(_iteratee);
  return _filter(eachfn, arr, (value, cb) => {
    iteratee(value, (err, v) => {
      cb(err, !v);
    });
  }, callback);
}
__name(reject$2, "reject$2");
function reject(coll, iteratee, callback) {
  return reject$2(eachOf$1, coll, iteratee, callback);
}
__name(reject, "reject");
var reject$1 = awaitify(reject, 3);
function rejectLimit(coll, limit2, iteratee, callback) {
  return reject$2(eachOfLimit$2(limit2), coll, iteratee, callback);
}
__name(rejectLimit, "rejectLimit");
var rejectLimit$1 = awaitify(rejectLimit, 4);
function rejectSeries(coll, iteratee, callback) {
  return reject$2(eachOfSeries$1, coll, iteratee, callback);
}
__name(rejectSeries, "rejectSeries");
var rejectSeries$1 = awaitify(rejectSeries, 3);
function some(coll, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
}
__name(some, "some");
var some$1 = awaitify(some, 3);
function someLimit(coll, limit2, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOfLimit$2(limit2), coll, iteratee, callback);
}
__name(someLimit, "someLimit");
var someLimit$1 = awaitify(someLimit, 4);
function someSeries(coll, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
}
__name(someSeries, "someSeries");
var someSeries$1 = awaitify(someSeries, 3);
function sortBy(coll, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return map$1(coll, (x, iterCb) => {
    _iteratee(x, (err, criteria) => {
      if (err) return iterCb(err);
      iterCb(err, { value: x, criteria });
    });
  }, (err, results) => {
    if (err) return callback(err);
    callback(null, results.sort(comparator).map((v) => v.value));
  });
  function comparator(left, right) {
    var a = left.criteria, b = right.criteria;
    return a < b ? -1 : a > b ? 1 : 0;
  }
  __name(comparator, "comparator");
}
__name(sortBy, "sortBy");
var sortBy$1 = awaitify(sortBy, 3);
function tryEach(tasks, callback) {
  var error22 = null;
  var result;
  return eachSeries$1(tasks, (task, taskCb) => {
    wrapAsync(task)((err, ...args) => {
      if (err === false) return taskCb(err);
      if (args.length < 2) {
        [result] = args;
      } else {
        result = args;
      }
      error22 = err;
      taskCb(err ? null : {});
    });
  }, () => callback(error22, result));
}
__name(tryEach, "tryEach");
var tryEach$1 = awaitify(tryEach);
function whilst(test, iteratee, callback) {
  callback = onlyOnce(callback);
  var _fn = wrapAsync(iteratee);
  var _test = wrapAsync(test);
  var results = [];
  function next2(err, ...rest) {
    if (err) return callback(err);
    results = rest;
    if (err === false) return;
    _test(check);
  }
  __name(next2, "next");
  function check(err, truth) {
    if (err) return callback(err);
    if (err === false) return;
    if (!truth) return callback(null, ...results);
    _fn(next2);
  }
  __name(check, "check");
  return _test(check);
}
__name(whilst, "whilst");
var whilst$1 = awaitify(whilst, 3);
function waterfall(tasks, callback) {
  callback = once2(callback);
  if (!Array.isArray(tasks)) return callback(new Error("First argument to waterfall must be an array of functions"));
  if (!tasks.length) return callback();
  var taskIndex = 0;
  function nextTask(args) {
    var task = wrapAsync(tasks[taskIndex++]);
    task(...args, onlyOnce(next2));
  }
  __name(nextTask, "nextTask");
  function next2(err, ...args) {
    if (err === false) return;
    if (err || taskIndex === tasks.length) {
      return callback(err, ...args);
    }
    nextTask(args);
  }
  __name(next2, "next");
  nextTask([]);
}
__name(waterfall, "waterfall");
var waterfall$1 = awaitify(waterfall);
init_logger();
var MAX_NAME_LENGTH = 40;
function fitNameToSpaces(name, length) {
  const padded = name.padEnd(length);
  if (padded.length <= length) {
    return padded;
  }
  return padded.substring(0, length - 3) + "...";
}
__name(fitNameToSpaces, "fitNameToSpaces");
var BarProgressReporter = class {
  static {
    __name(this, "BarProgressReporter");
  }
  multiBar;
  bars = {};
  constructor() {
    this.multiBar = new cliProgress.MultiBar(
      {
        clearOnComplete: false,
        format: " {bar} | {evaluator} | {percentage}% | {value}/{total} datapoints",
        autopadding: true
      },
      cliProgress.Presets.shades_grey
    );
  }
  start(name, total) {
    const bar = this.multiBar.create(total, 0);
    this.bars[name] = bar;
  }
  stop() {
    this.multiBar.stop();
  }
  increment(name) {
    this.bars[name].increment({
      evaluator: fitNameToSpaces(name, MAX_NAME_LENGTH)
    });
  }
};
init_util22();
init_logger();
init_generated_types();
init_util2();
init_logger();
var ProjectBuilder = class {
  static {
    __name(this, "ProjectBuilder");
  }
  create(opts) {
    return new Project2(opts);
  }
};
var projects = new ProjectBuilder();
var Project2 = class {
  static {
    __name(this, "Project2");
  }
  name;
  id;
  tools;
  prompts;
  scorers;
  _publishableCodeFunctions = [];
  _publishablePrompts = [];
  constructor(args) {
    _initializeSpanContext();
    this.name = "name" in args ? args.name : void 0;
    this.id = "id" in args ? args.id : void 0;
    this.tools = new ToolBuilder(this);
    this.prompts = new PromptBuilder(this);
    this.scorers = new ScorerBuilder(this);
  }
  addPrompt(prompt) {
    this._publishablePrompts.push(prompt);
    if (globalThis._lazy_load) {
      globalThis._evals.prompts.push(prompt);
    }
  }
  addCodeFunction(fn) {
    this._publishableCodeFunctions.push(fn);
    if (globalThis._lazy_load) {
      globalThis._evals.functions.push(fn);
    }
  }
  async publish() {
    if (globalThis._lazy_load) {
      console.warn("publish() is a no-op when running `braintrust push`.");
      return;
    }
    await login();
    const projectMap = new ProjectNameIdMap();
    const functionDefinitions = [];
    if (this._publishableCodeFunctions.length > 0) {
      console.warn(
        "Code functions cannot be published directly. Use `braintrust push` instead."
      );
    }
    if (this._publishablePrompts.length > 0) {
      for (const prompt of this._publishablePrompts) {
        const functionDefinition = await prompt.toFunctionDefinition(projectMap);
        functionDefinitions.push(functionDefinition);
      }
    }
    await _internalGetGlobalState().apiConn().post_json("insert-functions", {
      functions: functionDefinitions
    });
  }
};
var ToolBuilder = class {
  static {
    __name(this, "ToolBuilder");
  }
  constructor(project) {
    this.project = project;
  }
  taskCounter = 0;
  // This type definition is just a catch all so that the implementation can be
  // less specific than the two more specific declarations above.
  create(opts) {
    this.taskCounter++;
    opts = opts ?? {};
    const { handler, name, slug, parameters, returns, ...rest } = opts;
    let resolvedName = name ?? handler.name;
    if (resolvedName.trim().length === 0) {
      resolvedName = `Tool ${path2.basename(__filename)} ${this.taskCounter}`;
    }
    const tool = new CodeFunction(this.project, {
      handler,
      name: resolvedName,
      slug: slug ?? (0, import_slugify.default)(resolvedName, { lower: true, strict: true }),
      type: "tool",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/consistent-type-assertions
      parameters,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/consistent-type-assertions
      returns,
      ...rest
    });
    this.project.addCodeFunction(tool);
    return tool;
  }
};
var ScorerBuilder = class {
  static {
    __name(this, "ScorerBuilder");
  }
  constructor(project) {
    this.project = project;
  }
  taskCounter = 0;
  create(opts) {
    this.taskCounter++;
    let resolvedName = opts.name;
    if (!resolvedName && "handler" in opts) {
      resolvedName = opts.handler.name;
    }
    if (!resolvedName || resolvedName.trim().length === 0) {
      resolvedName = `Scorer ${path2.basename(__filename)} ${this.taskCounter}`;
    }
    const slug = opts.slug ?? (0, import_slugify.default)(resolvedName, { lower: true, strict: true });
    if ("handler" in opts) {
      const scorer = new CodeFunction(this.project, {
        ...opts,
        name: resolvedName,
        slug,
        type: "scorer"
      });
      this.project.addCodeFunction(scorer);
    } else {
      const promptBlock = "messages" in opts ? {
        type: "chat",
        messages: opts.messages
      } : {
        type: "completion",
        content: opts.prompt
      };
      const promptData = {
        prompt: promptBlock,
        options: {
          model: opts.model,
          params: opts.params
        },
        parser: {
          type: "llm_classifier",
          use_cot: opts.useCot,
          choice_scores: opts.choiceScores
        }
      };
      const codePrompt = new CodePrompt(
        this.project,
        promptData,
        [],
        {
          ...opts,
          name: resolvedName,
          slug
        },
        "scorer"
      );
      this.project.addPrompt(codePrompt);
    }
  }
};
var CodeFunction = class {
  static {
    __name(this, "CodeFunction");
  }
  constructor(project, opts) {
    this.project = project;
    this.handler = opts.handler;
    this.name = opts.name;
    this.slug = opts.slug;
    this.description = opts.description;
    this.type = opts.type;
    this.ifExists = opts.ifExists;
    this.parameters = opts.parameters;
    this.returns = opts.returns;
    if (this.returns && !this.parameters) {
      throw new Error("parameters are required if return type is defined");
    }
  }
  handler;
  name;
  slug;
  type;
  description;
  parameters;
  returns;
  ifExists;
  key() {
    return JSON.stringify([
      this.project.id ?? "",
      this.project.name ?? "",
      this.slug
    ]);
  }
};
var CodePrompt = class {
  static {
    __name(this, "CodePrompt");
  }
  project;
  name;
  slug;
  prompt;
  ifExists;
  description;
  id;
  functionType;
  toolFunctions;
  constructor(project, prompt, toolFunctions, opts, functionType2) {
    this.project = project;
    this.name = opts.name;
    this.slug = opts.slug;
    this.prompt = prompt;
    this.toolFunctions = toolFunctions;
    this.ifExists = opts.ifExists;
    this.description = opts.description;
    this.id = opts.id;
    this.functionType = functionType2;
  }
  async toFunctionDefinition(projectNameToId) {
    const prompt_data = {
      ...this.prompt
    };
    if (this.toolFunctions.length > 0) {
      const resolvableToolFunctions = await Promise.all(
        this.toolFunctions.map(async (fn) => {
          if ("slug" in fn) {
            return {
              type: "slug",
              project_id: await projectNameToId.resolve(fn.project),
              slug: fn.slug
            };
          } else {
            return fn;
          }
        })
      );
      prompt_data.tool_functions = // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
      resolvableToolFunctions;
    }
    return {
      project_id: await projectNameToId.resolve(this.project),
      name: this.name,
      slug: this.slug,
      description: this.description ?? "",
      function_data: {
        type: "prompt"
      },
      function_type: this.functionType,
      prompt_data,
      if_exists: this.ifExists
    };
  }
};
var promptContentsSchema = external_exports.union([
  external_exports.object({
    prompt: external_exports.string()
  }),
  external_exports.object({
    messages: external_exports.array(ChatCompletionMessageParam)
  })
]);
var promptDefinitionSchema = promptContentsSchema.and(
  external_exports.object({
    model: external_exports.string(),
    params: ModelParams.optional()
  })
);
var promptDefinitionWithToolsSchema = promptDefinitionSchema.and(
  external_exports.object({
    tools: external_exports.array(ToolFunctionDefinition).optional()
  })
);
var PromptBuilder = class {
  static {
    __name(this, "PromptBuilder");
  }
  constructor(project) {
    this.project = project;
  }
  create(opts) {
    const toolFunctions = [];
    const rawTools = [];
    for (const tool of opts.tools ?? []) {
      if (tool instanceof CodeFunction) {
        toolFunctions.push(tool);
      } else if ("type" in tool && !("function" in tool)) {
        toolFunctions.push(tool);
      } else {
        rawTools.push(tool);
      }
    }
    const slug = opts.slug ?? (0, import_slugify.default)(opts.name, { lower: true, strict: true });
    const promptData = promptDefinitionToPromptData(opts, rawTools);
    const promptRow = {
      id: opts.id,
      _xact_id: opts.version ? loadPrettyXact(opts.version) : void 0,
      name: opts.name,
      slug,
      prompt_data: promptData,
      ...this.project.id !== void 0 ? { project_id: this.project.id } : {}
    };
    const prompt = new Prompt2(
      promptRow,
      {},
      // It doesn't make sense to specify defaults here.
      opts.noTrace ?? false
    );
    const codePrompt = new CodePrompt(this.project, promptData, toolFunctions, {
      ...opts,
      slug
    });
    this.project.addPrompt(codePrompt);
    return prompt;
  }
};
function promptDefinitionToPromptData(promptDefinition, rawTools) {
  const promptBlock = "messages" in promptDefinition ? {
    type: "chat",
    messages: promptDefinition.messages,
    tools: rawTools && rawTools.length > 0 ? JSON.stringify(rawTools) : void 0
  } : {
    type: "completion",
    content: promptDefinition.prompt
  };
  return {
    prompt: promptBlock,
    options: {
      model: promptDefinition.model,
      params: promptDefinition.params
    }
  };
}
__name(promptDefinitionToPromptData, "promptDefinitionToPromptData");
var ProjectNameIdMap = class {
  static {
    __name(this, "ProjectNameIdMap");
  }
  nameToId = {};
  idToName = {};
  async getId(projectName) {
    if (!(projectName in this.nameToId)) {
      const response = await _internalGetGlobalState().appConn().post_json("api/project/register", {
        project_name: projectName
      });
      const result = external_exports.object({
        project: Project
      }).parse(response);
      const projectId = result.project.id;
      this.nameToId[projectName] = projectId;
      this.idToName[projectId] = projectName;
    }
    return this.nameToId[projectName];
  }
  async getName(projectId) {
    if (!(projectId in this.idToName)) {
      const response = await _internalGetGlobalState().appConn().post_json("api/project/get", {
        id: projectId
      });
      const result = external_exports.array(Project).nonempty().parse(response);
      const projectName = result[0].name;
      this.idToName[projectId] = projectName;
      this.nameToId[projectName] = projectId;
    }
    return this.idToName[projectId];
  }
  async resolve(project) {
    if (project.id) {
      return project.id;
    }
    return this.getId(project.name);
  }
};
init_generated_types();
var evalParametersSchema = external_exports.record(
  external_exports.string(),
  external_exports.union([
    external_exports.object({
      type: external_exports.literal("prompt"),
      default: promptDefinitionWithToolsSchema.optional(),
      description: external_exports.string().optional()
    }),
    external_exports.instanceof(external_exports.ZodType)
    // For Zod schemas
  ])
);
function validateParameters(parameters, parameterSchema) {
  return Object.fromEntries(
    Object.entries(parameterSchema).map(([name, schema]) => {
      const value = parameters[name];
      try {
        if ("type" in schema && schema.type === "prompt") {
          const promptData = value ? PromptData.parse(value) : schema.default ? promptDefinitionToPromptData(
            schema.default,
            schema.default.tools
          ) : void 0;
          if (!promptData) {
            throw new Error(`Parameter '${name}' is required`);
          }
          return [name, Prompt2.fromPromptData(name, promptData)];
        } else {
          const schemaCasted = schema;
          return [name, schemaCasted.parse(value)];
        }
      } catch (e) {
        console.error("Error validating parameter", name, e);
        throw Error(
          `Invalid parameter '${name}': ${e instanceof Error ? e.message : String(e)}`
        );
      }
    })
  );
}
__name(validateParameters, "validateParameters");
function BaseExperiment(options = {}) {
  return { _type: "BaseExperiment", ...options };
}
__name(BaseExperiment, "BaseExperiment");
var EvalResultWithSummary = class {
  static {
    __name(this, "EvalResultWithSummary");
  }
  constructor(summary, results) {
    this.summary = summary;
    this.results = results;
  }
  toString() {
    return formatExperimentSummary(this.summary);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `EvalResultWithSummary(summary="...", results=[...])`;
  }
  toJSON() {
    return {
      summary: this.summary,
      results: this.results
    };
  }
};
function makeEvalName(projectName, experimentName) {
  let out = projectName;
  if (experimentName) {
    out += ` [experimentName=${experimentName}]`;
  }
  return out;
}
__name(makeEvalName, "makeEvalName");
function initExperiment2(state, options = {}) {
  return init({
    state,
    ...options,
    setCurrent: false
  });
}
__name(initExperiment2, "initExperiment2");
function callEvaluatorData(data) {
  const dataResult = typeof data === "function" ? data() : data;
  let baseExperiment = void 0;
  if ("_type" in dataResult && dataResult._type === "BaseExperiment") {
    baseExperiment = dataResult.name;
  }
  return {
    data: dataResult,
    baseExperiment
  };
}
__name(callEvaluatorData, "callEvaluatorData");
globalThis._evals = {
  functions: [],
  prompts: [],
  evaluators: {},
  reporters: {}
};
function _initializeSpanContext() {
  globalThis._spanContext = { currentSpan, withCurrent, startSpan, NOOP_SPAN };
}
__name(_initializeSpanContext, "_initializeSpanContext");
async function Eval(name, evaluator, reporterOrOpts) {
  const options = isEmpty(reporterOrOpts) ? {} : typeof reporterOrOpts === "string" ? { reporter: reporterOrOpts } : "name" in reporterOrOpts ? { reporter: reporterOrOpts } : reporterOrOpts;
  let evalName = makeEvalName(name, evaluator.experimentName);
  if (globalThis._evals.evaluators[evalName]) {
    evalName = `${evalName}_${Object.keys(_evals).length}`;
  }
  if (globalThis._lazy_load) {
    globalThis._evals.evaluators[evalName] = {
      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
      evaluator: {
        evalName,
        projectName: name,
        ...evaluator
      },
      reporter: options.reporter
    };
    _initializeSpanContext();
    return new EvalResultWithSummary(
      {
        scores: {},
        metrics: {},
        projectName: "",
        experimentName: ""
      },
      []
    );
  }
  const progressReporter = options.progress ?? new BarProgressReporter();
  if (typeof options.reporter === "string") {
    throw new Error(
      "Must specify a reporter object, not a name. Can only specify reporter names when running 'braintrust eval'"
    );
  }
  const resolvedReporter = options.reporter || defaultReporter;
  try {
    const { data, baseExperiment: defaultBaseExperiment } = callEvaluatorData(
      evaluator.data
    );
    const experiment = options.parent || options.noSendLogs ? null : initExperiment2(evaluator.state, {
      ...evaluator.projectId ? { projectId: evaluator.projectId } : { project: name },
      experiment: evaluator.experimentName,
      description: evaluator.description,
      metadata: evaluator.metadata,
      isPublic: evaluator.isPublic,
      update: evaluator.update,
      baseExperiment: evaluator.baseExperimentName ?? defaultBaseExperiment,
      baseExperimentId: evaluator.baseExperimentId,
      gitMetadataSettings: evaluator.gitMetadataSettings,
      repoInfo: evaluator.repoInfo,
      dataset: Dataset2.isDataset(data) ? data : void 0
    });
    if (experiment && typeof process !== "undefined" && process.env?.BRAINTRUST_OTEL_COMPAT?.toLowerCase() === "true") {
      await experiment._waitForId();
    }
    if (experiment && options.onStart) {
      const summary = await experiment.summarize({ summarizeScores: false });
      options.onStart(summary);
    }
    try {
      const evalDef = {
        evalName,
        projectName: name,
        ...evaluator,
        data
      };
      let ret;
      if (options.parent) {
        ret = await withParent(
          options.parent,
          () => runEvaluator(
            null,
            evalDef,
            progressReporter,
            [],
            options.stream,
            options.parameters
          ),
          evaluator.state
        );
      } else {
        ret = await runEvaluator(
          experiment,
          evalDef,
          progressReporter,
          [],
          options.stream,
          options.parameters
        );
      }
      progressReporter.stop();
      resolvedReporter.reportEval(evalDef, ret, {
        verbose: true,
        jsonl: false
      });
      return ret;
    } finally {
      if (experiment) {
        experiment.flush().catch(console.error);
      } else if (options.parent) {
        flush().catch(console.error);
      }
    }
  } finally {
    progressReporter.stop();
  }
}
__name(Eval, "Eval");
function Reporter(name, reporter) {
  const ret = { name, ...reporter };
  if (_evals.reporters[name]) {
    throw new Error(`Reporter ${name} already exists`);
  }
  if (globalThis._lazy_load) {
    _evals.reporters[name] = ret;
  }
  return ret;
}
__name(Reporter, "Reporter");
function serializeJSONWithPlainString(v) {
  if (typeof v === "string") {
    return v;
  } else {
    return JSON.stringify(v);
  }
}
__name(serializeJSONWithPlainString, "serializeJSONWithPlainString");
function evaluateFilter(object, filter2) {
  const { path: path32, pattern } = filter2;
  const key = path32.reduce(
    (acc, p) => typeof acc === "object" && acc !== null ? (
      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
      acc[p]
    ) : void 0,
    object
  );
  if (key === void 0) {
    return false;
  }
  return pattern.test(serializeJSONWithPlainString(key));
}
__name(evaluateFilter, "evaluateFilter");
function scorerName(scorer, scorer_idx) {
  return scorer.name || `scorer_${scorer_idx}`;
}
__name(scorerName, "scorerName");
async function runEvaluator(experiment, evaluator, progressReporter, filters, stream, parameters) {
  return await runEvaluatorInternal(
    experiment,
    evaluator,
    progressReporter,
    filters,
    stream,
    parameters
  );
}
__name(runEvaluator, "runEvaluator");
var defaultErrorScoreHandler = /* @__PURE__ */ __name(({
  rootSpan,
  data: _,
  unhandledScores
}) => {
  const scores = Object.fromEntries(unhandledScores.map((s) => [s, 0]));
  rootSpan.log({ scores });
  return scores;
}, "defaultErrorScoreHandler");
async function runEvaluatorInternal(experiment, evaluator, progressReporter, filters, stream, parameters) {
  if (typeof evaluator.data === "string") {
    throw new Error("Unimplemented: string data paths");
  }
  let dataResult = typeof evaluator.data === "function" ? evaluator.data() : evaluator.data;
  parameters = validateParameters(parameters ?? {}, evaluator.parameters ?? {});
  if ("_type" in dataResult) {
    if (dataResult._type !== "BaseExperiment") {
      throw new Error("Invalid _type");
    }
    if (!experiment) {
      throw new Error(
        "Cannot use BaseExperiment() without connecting to Braintrust (you most likely set --no-send-logs)"
      );
    }
    let name = dataResult.name;
    if (isEmpty(name)) {
      const baseExperiment = await experiment.fetchBaseExperiment();
      if (!baseExperiment) {
        throw new Error("BaseExperiment() failed to fetch base experiment");
      }
      name = baseExperiment.name;
    }
    dataResult = initExperiment2(evaluator.state, {
      ...evaluator.projectId ? { projectId: evaluator.projectId } : { project: evaluator.projectName },
      experiment: name,
      open: true
    }).asDataset();
  }
  let data = [];
  if (dataResult instanceof Promise) {
    data = await dataResult;
  } else if (Symbol.asyncIterator in dataResult) {
    data = [];
    for await (const d of dataResult) {
      data.push(d);
    }
  } else {
    data = dataResult;
  }
  const dataWithTrials = data.filter((d) => filters.every((f) => evaluateFilter(d, f))).flatMap(
    (datum) => [...Array(evaluator.trialCount ?? 1).keys()].map((trialIndex) => ({
      datum,
      trialIndex
    }))
  );
  progressReporter.start(evaluator.evalName, dataWithTrials.length);
  const results = [];
  const q = queue(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async ({
      datum,
      trialIndex
    }) => {
      const eventDataset = experiment ? experiment.dataset : Dataset2.isDataset(evaluator.data) ? evaluator.data : void 0;
      const baseEvent = {
        name: "eval",
        spanAttributes: {
          type: "eval"
          /* EVAL */
        },
        event: {
          input: datum.input,
          expected: "expected" in datum ? datum.expected : void 0,
          tags: datum.tags,
          origin: eventDataset && datum.id && datum._xact_id ? {
            object_type: "dataset",
            object_id: await eventDataset.id,
            id: datum.id,
            created: datum.created,
            _xact_id: datum._xact_id
          } : void 0,
          ...datum.upsert_id ? { id: datum.upsert_id } : {}
        }
      };
      const callback = /* @__PURE__ */ __name(async (rootSpan) => {
        let metadata = {
          ..."metadata" in datum ? datum.metadata : {}
        };
        const expected = "expected" in datum ? datum.expected : void 0;
        let output = void 0;
        let error22 = void 0;
        let tags = [...datum.tags ?? []];
        const scores = {};
        const scorerNames = evaluator.scores.map(scorerName);
        let unhandledScores = scorerNames;
        try {
          const meta = /* @__PURE__ */ __name((o) => metadata = { ...metadata, ...o }, "meta");
          await rootSpan.traced(
            async (span) => {
              const hooksForTask = {
                meta,
                metadata,
                expected,
                span,
                parameters: parameters ?? {},
                reportProgress: /* @__PURE__ */ __name((event) => {
                  stream?.({
                    ...event,
                    id: rootSpan.id,
                    origin: baseEvent.event?.origin,
                    name: evaluator.evalName,
                    object_type: "task"
                  });
                }, "reportProgress"),
                trialIndex,
                tags
              };
              const outputResult = evaluator.task(datum.input, hooksForTask);
              if (outputResult instanceof Promise) {
                output = await outputResult;
              } else {
                output = outputResult;
              }
              tags = hooksForTask.tags ?? [];
              span.log({ output });
            },
            {
              name: "task",
              spanAttributes: {
                type: "task"
                /* TASK */
              },
              event: { input: datum.input }
            }
          );
          if (tags.length) {
            rootSpan.log({ output, metadata, expected, tags });
          } else {
            rootSpan.log({ output, metadata, expected });
          }
          const scoringArgs = {
            input: datum.input,
            expected: "expected" in datum ? datum.expected : void 0,
            metadata,
            output
          };
          const scoreResults = await Promise.all(
            evaluator.scores.map(async (score, score_idx) => {
              try {
                const runScorer = /* @__PURE__ */ __name(async (span) => {
                  const scoreResult = score(scoringArgs);
                  const scoreValue = scoreResult instanceof Promise ? await scoreResult : scoreResult;
                  if (scoreValue === null) {
                    return null;
                  }
                  if (Array.isArray(scoreValue)) {
                    for (const s of scoreValue) {
                      if (!(typeof s === "object" && !isEmpty(s))) {
                        throw new Error(
                          `When returning an array of scores, each score must be a non-empty object. Got: ${JSON.stringify(
                            s
                          )}`
                        );
                      }
                    }
                  }
                  const results3 = Array.isArray(scoreValue) ? scoreValue : typeof scoreValue === "object" && !isEmpty(scoreValue) ? [scoreValue] : [
                    {
                      name: scorerNames[score_idx],
                      score: scoreValue
                    }
                  ];
                  const getOtherFields = /* @__PURE__ */ __name((s) => {
                    const { metadata: _metadata, name: _name, ...rest } = s;
                    return rest;
                  }, "getOtherFields");
                  const resultMetadata = results3.length === 1 ? results3[0].metadata : results3.reduce(
                    (prev, s) => mergeDicts(prev, {
                      [s.name]: s.metadata
                    }),
                    {}
                  );
                  const resultOutput = results3.length === 1 ? getOtherFields(results3[0]) : results3.reduce(
                    (prev, s) => mergeDicts(prev, { [s.name]: getOtherFields(s) }),
                    {}
                  );
                  const scores2 = results3.reduce(
                    (prev, s) => mergeDicts(prev, { [s.name]: s.score }),
                    {}
                  );
                  span.log({
                    output: resultOutput,
                    metadata: resultMetadata,
                    scores: scores2
                  });
                  return results3;
                }, "runScorer");
                const results2 = await rootSpan.traced(runScorer, {
                  name: scorerNames[score_idx],
                  spanAttributes: {
                    type: "score"
                    /* SCORE */
                  },
                  event: { input: scoringArgs }
                });
                return { kind: "score", value: results2 };
              } catch (e) {
                return { kind: "error", value: e };
              }
            })
          );
          const failingScorersAndResults = [];
          scoreResults.forEach((results2, i) => {
            const name = scorerNames[i];
            if (results2.kind === "score") {
              (results2.value || []).forEach((result) => {
                scores[result.name] = result.score;
              });
            } else {
              failingScorersAndResults.push({ name, error: results2.value });
            }
          });
          unhandledScores = null;
          if (failingScorersAndResults.length) {
            const scorerErrors = Object.fromEntries(
              failingScorersAndResults.map(({ name, error: error32 }) => [
                name,
                error32 instanceof Error ? error32.stack : `${error32}`
              ])
            );
            metadata["scorer_errors"] = scorerErrors;
            rootSpan.log({
              metadata: { scorer_errors: scorerErrors }
            });
            const names = Object.keys(scorerErrors).join(", ");
            const errors = failingScorersAndResults.map((item) => item.error);
            unhandledScores = Object.keys(scorerErrors);
            console.warn(
              `Found exceptions for the following scorers: ${names}`,
              errors
            );
          }
        } catch (e) {
          logError(rootSpan, e);
          error22 = e;
        } finally {
          progressReporter.increment(evaluator.evalName);
        }
        results.push({
          input: datum.input,
          ..."expected" in datum ? { expected: datum.expected } : {},
          output,
          tags: tags.length ? tags : void 0,
          metadata,
          scores: {
            ...evaluator.errorScoreHandler && unhandledScores ? evaluator.errorScoreHandler({
              rootSpan,
              data: datum,
              unhandledScores
            }) : void 0,
            ...scores
          },
          error: error22,
          origin: baseEvent.event?.origin
        });
      }, "callback");
      if (!experiment) {
        return await traced(callback, {
          ...baseEvent,
          state: evaluator.state
        });
      } else {
        return await experiment.traced(callback, baseEvent);
      }
    },
    Math.max(evaluator.maxConcurrency ?? dataWithTrials.length, 1)
  );
  q.push(dataWithTrials);
  const cancel = /* @__PURE__ */ __name(async () => {
    await new Promise((_, reject2) => {
      if (evaluator.timeout) {
        setTimeout(() => {
          reject2(new InternalAbortError("Evaluator timed out"));
        }, evaluator.timeout);
      }
      if (evaluator.signal) {
        evaluator.signal.addEventListener("abort", () => {
          reject2(new InternalAbortError("Evaluator aborted"));
        });
      }
    });
  }, "cancel");
  try {
    await Promise.race([q.drain(), cancel()]);
  } catch (e) {
    if (e instanceof InternalAbortError) {
      q.kill();
    }
    throw e;
  }
  const summary = experiment ? await experiment.summarize({ summarizeScores: evaluator.summarizeScores }) : buildLocalSummary(evaluator, results);
  return new EvalResultWithSummary(summary, results);
}
__name(runEvaluatorInternal, "runEvaluatorInternal");
var error3 = import_chalk.default.bold.red;
var warning = import_chalk.default.hex("#FFA500");
function logError2(e, verbose) {
  if (!verbose) {
    console.error(`${e}`);
  } else {
    console.error(e);
  }
}
__name(logError2, "logError2");
function buildLocalSummary(evaluator, results) {
  const scoresByName = {};
  for (const result of results) {
    for (const [name, score] of Object.entries(result.scores)) {
      const { total, count: count3 } = scoresByName[name] || { total: 0, count: 0 };
      if (score === null) {
        continue;
      }
      scoresByName[name] = { total: total + score, count: count3 + 1 };
    }
  }
  return {
    projectName: evaluator.projectName,
    experimentName: evaluator.evalName,
    scores: Object.fromEntries(
      Object.entries(scoresByName).map(([name, { total, count: count3 }]) => [
        name,
        {
          name,
          score: total / count3,
          improvements: 0,
          regressions: 0
        }
      ])
    )
  };
}
__name(buildLocalSummary, "buildLocalSummary");
function reportFailures(evaluator, failingResults, { verbose, jsonl }) {
  if (failingResults.length > 0) {
    console.error(
      warning(
        `Evaluator ${evaluator.evalName} failed with ${(0, import_pluralize.default)(
          "error",
          failingResults.length,
          true
        )}. This evaluation ("${evaluator.evalName}") will not be fully logged.`
      )
    );
    if (jsonl) {
      console.log(
        JSON.stringify({
          evaluatorName: evaluator.evalName,
          errors: failingResults.map(
            (r) => `${r.error instanceof Error ? r.error.stack : r.error}`
          )
        })
      );
    } else {
      for (const result of failingResults) {
        logError2(result.error, verbose);
      }
    }
    if (!verbose && !jsonl) {
      console.error(warning("Add --verbose to see full stack traces."));
    }
  }
}
__name(reportFailures, "reportFailures");
var defaultReporter = {
  name: "Braintrust default reporter",
  async reportEval(evaluator, result, { verbose, jsonl }) {
    const { results, summary } = result;
    const failingResults = results.filter(
      (r) => r.error !== void 0
    );
    if (failingResults.length > 0) {
      reportFailures(evaluator, failingResults, { verbose, jsonl });
    }
    process.stdout.write(
      jsonl ? JSON.stringify(summary) : formatExperimentSummary(summary)
    );
    process.stdout.write("\n");
    return failingResults.length === 0;
  },
  async reportRun(evalReports) {
    return evalReports.every((r) => r);
  }
};
function formatExperimentSummary(summary) {
  let comparisonLine = "";
  if (summary.comparisonExperimentName) {
    comparisonLine = `${summary.experimentName} compared to ${summary.comparisonExperimentName}:
`;
  }
  const longestScoreName = Math.max(
    ...Object.values(summary.scores).map((score) => score.name.length)
  );
  const longestMetricName = Math.max(
    ...Object.values(summary.metrics ?? {}).map((metric) => metric.name.length)
  );
  return `
=========================SUMMARY=========================
${comparisonLine}` + Object.values(summary.scores).map((score) => formatScoreSummary(score, longestScoreName)).join("\n") + (Object.keys(summary.scores).length ? "\n\n" : "") + Object.values(summary.metrics ?? {}).map((metric) => formatMetricSummary(metric, longestMetricName)).join("\n") + (Object.keys(summary.metrics ?? {}).length ? "\n\n" : "") + (summary.experimentUrl ? `See results for ${summary.experimentName} at ${summary.experimentUrl}` : "");
}
__name(formatExperimentSummary, "formatExperimentSummary");
function formatScoreSummary(summary, longestScoreName) {
  const diffString = isEmpty(summary.diff) ? "" : ` (${summary.diff > 0 ? "+" : ""}${(summary.diff * 100).toFixed(2)}%)`;
  const scoreName = `'${summary.name}'`.padEnd(longestScoreName + 2);
  return `${(summary.score * 100).toFixed(
    2
  )}%${diffString} ${scoreName} score	(${summary.improvements} improvements, ${summary.regressions} regressions)`;
}
__name(formatScoreSummary, "formatScoreSummary");
function formatMetricSummary(summary, longestMetricName) {
  const fractionDigits = Number.isInteger(summary.metric) ? 0 : 2;
  const metricName = `'${summary.name}'`.padEnd(longestMetricName + 2);
  return `${summary.metric.toFixed(fractionDigits)}${summary.unit} ${metricName}	(${summary.improvements} improvements, ${summary.regressions} regressions)`;
}
__name(formatMetricSummary, "formatMetricSummary");
var graph_framework_exports = {};
__export3(graph_framework_exports, {
  AggregatorNode: /* @__PURE__ */ __name(() => AggregatorNode, "AggregatorNode"),
  GateNode: /* @__PURE__ */ __name(() => GateNode, "GateNode"),
  GraphBuilder: /* @__PURE__ */ __name(() => GraphBuilder, "GraphBuilder"),
  InputNode: /* @__PURE__ */ __name(() => InputNode, "InputNode"),
  LiteralNode: /* @__PURE__ */ __name(() => LiteralNode, "LiteralNode"),
  OutputNode: /* @__PURE__ */ __name(() => OutputNode, "OutputNode"),
  PromptNode: /* @__PURE__ */ __name(() => PromptNode, "PromptNode"),
  PromptTemplateNode: /* @__PURE__ */ __name(() => PromptTemplateNode, "PromptTemplateNode"),
  createGraph: /* @__PURE__ */ __name(() => createGraph, "createGraph"),
  default: /* @__PURE__ */ __name(() => graph_framework_default, "default"),
  escapePath: /* @__PURE__ */ __name(() => escapePath, "escapePath"),
  unescapePath: /* @__PURE__ */ __name(() => unescapePath, "unescapePath")
});
init_logger();
var GraphBuilder = class {
  static {
    __name(this, "GraphBuilder");
  }
  nodes = /* @__PURE__ */ new Map();
  edges = {};
  nodeLikeNodes = /* @__PURE__ */ new Map();
  // Maps node-like objects, like prompts, to their nodes
  // Special nodes
  IN;
  OUT;
  constructor() {
    this.IN = this.createInputNode();
    this.OUT = this.createOutputNode();
  }
  // Create the final GraphData object
  async build(context22) {
    const nodes = await Promise.all(
      Array.from(this.nodes.values()).map(async (node) => [
        node.id,
        await node.build(context22)
      ])
    );
    return {
      type: "graph",
      nodes: Object.fromEntries(nodes),
      // XXX Need to resolve the lazy nodes
      edges: this.edges
    };
  }
  addEdge({
    source,
    sourceVar,
    target,
    targetVar,
    expr,
    purpose
  }) {
    const [sourceNode, sourcePath] = this.resolveNode(source);
    if (sourcePath.length > 0) {
      throw new Error("Source path must be empty");
    }
    const [targetNode, targetPath] = this.resolveNode(target);
    if (targetPath.length > 0) {
      throw new Error("Target path must be empty");
    }
    const id = this.generateId();
    sourceVar = sourceVar ?? "output";
    targetVar = targetVar ?? (purpose === "data" ? "input" : this.generateId("control"));
    for (const edge of Object.values(this.edges)) {
      if (edge.target.node === targetNode.id && edge.target.variable === targetVar) {
        throw new Error(
          `Variable name ${targetVar} already set on ${targetNode.id}`
        );
      }
    }
    this.edges[id] = {
      source: { node: sourceNode.id, variable: sourceVar },
      target: { node: targetNode.id, variable: targetVar },
      purpose
    };
  }
  resolveNode(node) {
    if (node instanceof Prompt2) {
      const cached = this.nodeLikeNodes.get(node);
      if (cached) {
        return [cached, []];
      }
      const promptNode = this.createPromptNode(node);
      this.nodeLikeNodes.set(node, promptNode);
      return [promptNode, []];
    } else if (isProxyVariable(node)) {
      return proxyVariableToNode(node);
    } else {
      return [node, []];
    }
  }
  // Create a literal node
  literal(value) {
    const preview = (typeof value === "string" ? value : JSON.stringify(value)).slice(0, 16);
    const id = this.generateId(`literal-${preview}`);
    const literalNode = new LiteralNode(this, id, value);
    this.nodes.set(id, literalNode);
    return literalNode;
  }
  gate(options) {
    const id = this.generateId("gate");
    const gateNode = new GateNode(this, id, options.condition);
    this.nodes.set(id, gateNode);
    return gateNode;
  }
  aggregator() {
    const id = this.generateId("aggregator");
    const aggregatorNode = new AggregatorNode(this, id);
    this.nodes.set(id, aggregatorNode);
    return aggregatorNode;
  }
  promptTemplate(options) {
    const id = this.generateId("prompt-template");
    const promptTemplateNode = new PromptTemplateNode(this, id, options.prompt);
    this.nodes.set(id, promptTemplateNode);
    return promptTemplateNode;
  }
  // public call(node: NodeLike, input: CallArgs): Node {
  //   const [resolvedNode, path] = this.resolveNode(node);
  //   if (resolvedNode instanceof SingleInputNode) {
  //     return resolvedNode.call(input, path);
  //   } else {
  //     throw new Error("Node must be a SingleInputNode");
  //   }
  // }
  // Helper to generate node IDs
  generateId(name) {
    const uuid42 = newId();
    if (name) {
      return `${name}-${uuid42.slice(0, 8)}`;
    } else {
      return uuid42;
    }
  }
  // Create an input node
  createInputNode() {
    const id = this.generateId("input");
    const inputNode = new InputNode(this, id);
    this.nodes.set(id, inputNode);
    return inputNode;
  }
  // Create an output node
  createOutputNode() {
    const id = this.generateId("output");
    const outputNode = new OutputNode(this, id);
    this.nodes.set(id, outputNode);
    return outputNode;
  }
  // Create a prompt node from a CodePrompt
  createPromptNode(prompt) {
    const id = this.generateId(`prompt-${prompt.slug}`);
    const promptNode = new PromptNode(this, id, prompt);
    this.nodes.set(id, promptNode);
    return promptNode;
  }
};
function isProxyVariable(node) {
  return typeof node === "object" && node !== null && "__type" in node && // @ts-ignore
  node.__type === "proxy-variable";
}
__name(isProxyVariable, "isProxyVariable");
function proxyVariableToNode(proxy) {
  return [proxy.__node, proxy.__path];
}
__name(proxyVariableToNode, "proxyVariableToNode");
var BaseNode = class {
  static {
    __name(this, "BaseNode");
  }
  constructor(graph, id) {
    this.graph = graph;
    this.id = id;
  }
  __type = "node";
  dependencies = [];
  addDependency(dependency) {
    this.dependencies.push(dependency);
  }
};
var InputNode = class extends BaseNode {
  static {
    __name(this, "InputNode");
  }
  constructor(graph, id) {
    super(graph, id);
  }
  async build(context22) {
    return {
      type: "input",
      description: "Input to the graph"
    };
  }
};
var OutputNode = class extends BaseNode {
  static {
    __name(this, "OutputNode");
  }
  constructor(graph, id) {
    super(graph, id);
  }
  async build(context22) {
    return {
      type: "output",
      description: "Output of the graph"
    };
  }
};
var PromptNode = class extends BaseNode {
  static {
    __name(this, "PromptNode");
  }
  constructor(graph, id, prompt) {
    super(graph, id);
    this.prompt = prompt;
  }
  async build(context22) {
    return {
      type: "function",
      function: await context22.getFunctionId(this.prompt)
    };
  }
};
var GateNode = class extends BaseNode {
  static {
    __name(this, "GateNode");
  }
  constructor(graph, id, condition) {
    super(graph, id);
    this.condition = condition;
  }
  async build(context22) {
    return {
      type: "gate",
      description: "Conditional gate",
      condition: this.condition
    };
  }
};
var AggregatorNode = class extends BaseNode {
  static {
    __name(this, "AggregatorNode");
  }
  constructor(graph, id) {
    super(graph, id);
  }
  async build(context22) {
    return {
      type: "aggregator",
      description: "Aggregator"
    };
  }
};
var PromptTemplateNode = class extends BaseNode {
  static {
    __name(this, "PromptTemplateNode");
  }
  constructor(graph, id, prompt) {
    super(graph, id);
    this.prompt = prompt;
  }
  async build(context22) {
    return {
      type: "prompt_template",
      prompt: this.prompt
    };
  }
};
var LiteralNode = class extends BaseNode {
  static {
    __name(this, "LiteralNode");
  }
  constructor(graph, id, value) {
    super(graph, id);
    this.value = value;
  }
  async build(context22) {
    return {
      type: "literal",
      value: this.value
    };
  }
};
function createGraph() {
  const graphBuilder = new GraphBuilder();
  return graphBuilder;
}
__name(createGraph, "createGraph");
function escapePath(parts) {
  if (parts.length === 0) {
    return void 0;
  }
  return parts.map((part) => {
    if (/[^\w-]/.test(part)) {
      const escaped = part.replace(/["\\]/g, "\\$&");
      return `"${escaped}"`;
    }
    return part;
  }).join(".");
}
__name(escapePath, "escapePath");
function unescapePath(path32) {
  const regex = /"((?:\\["\\]|[^"\\])*)"|([^\.]+)/g;
  const matches = path32.match(regex);
  return matches ? matches.map((match) => {
    if (match.startsWith('"')) {
      return match.slice(1, -1).replace(/\\(["\\])/g, "$1");
    }
    return match;
  }) : [];
}
__name(unescapePath, "unescapePath");
var graph_framework_default = { createGraph };
init_util22();
init_util2();
init_logger();
init_util22();
init_util2();
init_util22();
init_logger();
init_util2();
function responsesProxy(openai) {
  if (!openai.responses) {
    return openai;
  }
  return new Proxy(openai.responses, {
    get(target, name, receiver) {
      if (name === "create") {
        return responsesCreateProxy(target.create.bind(target));
      } else if (name === "stream") {
        return responsesStreamProxy(target.stream.bind(target));
      } else if (name === "parse") {
        return responsesParseProxy(target.parse.bind(target));
      }
      return Reflect.get(target, name, receiver);
    }
  });
}
__name(responsesProxy, "responsesProxy");
function responsesCreateProxy(target) {
  const hooks = {
    name: "openai.responses",
    toSpanFunc: parseSpanFromResponseCreateParams,
    resultToEventFunc: parseEventFromResponseCreateResult,
    traceStreamFunc: traceResponseCreateStream
  };
  return proxyCreate(target, hooks);
}
__name(responsesCreateProxy, "responsesCreateProxy");
function parseSpanFromResponseCreateParams(params) {
  const spanArgs = {
    name: "openai.responses.create",
    spanAttributes: {
      type: "llm"
    },
    event: {
      input: params.input,
      metadata: {
        ...filterFrom(params, ["input"]),
        provider: "openai"
      }
    },
    startTime: getCurrentUnixTimestamp()
  };
  return {
    span: startSpan(spanArgs),
    start: spanArgs.startTime
  };
}
__name(parseSpanFromResponseCreateParams, "parseSpanFromResponseCreateParams");
function parseEventFromResponseCreateResult(result) {
  const data = {};
  if (result?.output !== void 0) {
    data.output = processImagesInOutput(result.output);
  }
  if (result) {
    const { output, usage, ...metadata } = result;
    if (Object.keys(metadata).length > 0) {
      data.metadata = metadata;
    }
  }
  data.metrics = parseMetricsFromUsage(result?.usage);
  return data;
}
__name(parseEventFromResponseCreateResult, "parseEventFromResponseCreateResult");
function processImagesInOutput(output) {
  if (Array.isArray(output)) {
    return output.map(processImagesInOutput);
  }
  if (isObject(output)) {
    if (output.type === "image_generation_call" && output.result && typeof output.result === "string") {
      const fileExtension = output.output_format || "png";
      const contentType = `image/${fileExtension}`;
      const baseFilename = output.revised_prompt && typeof output.revised_prompt === "string" ? output.revised_prompt.slice(0, 50).replace(/[^a-zA-Z0-9]/g, "_") : "generated_image";
      const filename = `${baseFilename}.${fileExtension}`;
      const binaryString = atob(output.result);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      const blob = new Blob([bytes], { type: contentType });
      const attachment = new Attachment({
        data: blob,
        filename,
        contentType
      });
      return {
        ...output,
        result: attachment
      };
    }
  }
  return output;
}
__name(processImagesInOutput, "processImagesInOutput");
function parseSpanFromResponseParseParams(params) {
  const spanArgs = {
    name: "openai.responses.parse",
    spanAttributes: {
      type: "llm"
    },
    event: {
      input: params.input,
      metadata: {
        ...filterFrom(params, ["input"]),
        provider: "openai"
      }
    },
    startTime: getCurrentUnixTimestamp()
  };
  return {
    span: startSpan(spanArgs),
    start: spanArgs.startTime
  };
}
__name(parseSpanFromResponseParseParams, "parseSpanFromResponseParseParams");
function parseEventFromResponseParseResult(result) {
  const data = {};
  if (result?.output !== void 0) {
    data.output = processImagesInOutput(result.output);
  }
  if (result) {
    const { output, usage, ...metadata } = result;
    if (Object.keys(metadata).length > 0) {
      data.metadata = metadata;
    }
  }
  data.metrics = parseMetricsFromUsage(result?.usage);
  return data;
}
__name(parseEventFromResponseParseResult, "parseEventFromResponseParseResult");
function traceResponseCreateStream(stream, timedSpan) {
  const span = timedSpan.span;
  let ttft = -1;
  return async function(...args) {
    const result = await stream.next(...args);
    if (ttft === -1) {
      ttft = getCurrentUnixTimestamp() - timedSpan.start;
      span.log({ metrics: { time_to_first_token: ttft } });
    }
    if (result.done) {
      span.end();
      return result;
    }
    const item = result.value;
    if (!item || !item?.type || !item?.response) {
      return result;
    }
    const event = parseLogFromItem(item);
    if (!objectIsEmpty(event)) {
      span.log(event);
    }
    return result;
  };
}
__name(traceResponseCreateStream, "traceResponseCreateStream");
function parseLogFromItem(item) {
  if (!item || !item?.type || !item?.response) {
    return {};
  }
  const response = item.response;
  switch (item.type) {
    case "response.completed":
      const data = {};
      if (response?.output !== void 0) {
        data.output = processImagesInOutput(response.output);
      }
      if (response) {
        const { usage, output, ...metadata } = response;
        if (Object.keys(metadata).length > 0) {
          data.metadata = metadata;
        }
      }
      data.metrics = parseMetricsFromUsage(response?.usage);
      return data;
    default:
      return {};
  }
}
__name(parseLogFromItem, "parseLogFromItem");
function responsesStreamProxy(target) {
  return new Proxy(target, {
    apply(target2, thisArg, argArray) {
      const responseStream = Reflect.apply(target2, thisArg, argArray);
      if (!argArray || argArray.length === 0) {
        return responseStream;
      }
      const timedSpan = parseSpanFromResponseCreateParams(argArray[0]);
      const span = timedSpan.span;
      let ttft = -1;
      responseStream.on("event", (event) => {
        if (ttft === -1) {
          ttft = getCurrentUnixTimestamp() - timedSpan.start;
          span.log({ metrics: { time_to_first_token: ttft } });
        }
        const logEvent = parseLogFromItem(event);
        if (!objectIsEmpty(logEvent)) {
          span.log(logEvent);
        }
      });
      responseStream.on("end", () => {
        span.end();
      });
      return responseStream;
    }
  });
}
__name(responsesStreamProxy, "responsesStreamProxy");
function responsesParseProxy(target) {
  const hooks = {
    name: "openai.responses.parse",
    toSpanFunc: parseSpanFromResponseParseParams,
    resultToEventFunc: parseEventFromResponseParseResult,
    traceStreamFunc: traceResponseCreateStream
    // Reuse the same stream tracing
  };
  return proxyCreate(target, hooks);
}
__name(responsesParseProxy, "responsesParseProxy");
var TOKEN_NAME_MAP = {
  input_tokens: "prompt_tokens",
  output_tokens: "completion_tokens",
  total_tokens: "tokens"
};
var TOKEN_PREFIX_MAP = {
  input: "prompt",
  output: "completion"
};
function parseMetricsFromUsage(usage) {
  if (!usage) {
    return {};
  }
  const metrics2 = {};
  for (const [oai_name, value] of Object.entries(usage)) {
    if (typeof value === "number") {
      const metricName = TOKEN_NAME_MAP[oai_name] || oai_name;
      metrics2[metricName] = value;
    } else if (oai_name.endsWith("_tokens_details")) {
      if (!isObject(value)) {
        continue;
      }
      const rawPrefix = oai_name.slice(0, -"_tokens_details".length);
      const prefix = TOKEN_PREFIX_MAP[rawPrefix] || rawPrefix;
      for (const [key, n] of Object.entries(value)) {
        if (typeof n !== "number") {
          continue;
        }
        const metricName = `${prefix}_${key}`;
        metrics2[metricName] = n;
      }
    }
  }
  return metrics2;
}
__name(parseMetricsFromUsage, "parseMetricsFromUsage");
function proxyCreate(target, hooks) {
  return new Proxy(target, {
    apply(target2, thisArg, argArray) {
      if (!argArray || argArray.length === 0) {
        return Reflect.apply(target2, thisArg, argArray);
      }
      const params = argArray[0];
      const timedSpan = hooks.toSpanFunc(params);
      const apiPromise = Reflect.apply(target2, thisArg, argArray);
      const onThen = /* @__PURE__ */ __name(function(result) {
        if (params.stream) {
          return proxyIterable(result, timedSpan, hooks.traceStreamFunc);
        } else {
          const event = hooks.resultToEventFunc(result);
          const span = timedSpan.span;
          span.log(event);
          span.end();
          return result;
        }
      }, "onThen");
      return apiPromiseProxy(
        apiPromise,
        timedSpan,
        onThen,
        hooks.traceStreamFunc
      );
    }
  });
}
__name(proxyCreate, "proxyCreate");
function apiPromiseProxy(apiPromise, span, onThen, traceStreamFunc) {
  return new Proxy(apiPromise, {
    get(target, name, receiver) {
      if (name === "then") {
        const thenFunc = Reflect.get(target, name, receiver);
        return function(onF, onR) {
          return thenFunc.call(
            target,
            async (result) => {
              const processed = onThen(result);
              return onF ? onF(processed) : processed;
            },
            onR
            // FIXME[matt] error handling?
          );
        };
      }
      return Reflect.get(target, name, receiver);
    }
  });
}
__name(apiPromiseProxy, "apiPromiseProxy");
function proxyIterable(stream, span, onNext) {
  return new Proxy(stream, {
    get(target, prop, receiver) {
      if (prop === Symbol.asyncIterator) {
        const original = Reflect.get(target, prop, receiver);
        return function() {
          const iterator = original.call(target);
          return new Proxy(iterator, {
            get(iterTarget, iterProp, iterReceiver) {
              if (iterProp === "next") {
                return onNext(iterator, span);
              }
              return Reflect.get(iterTarget, iterProp, iterReceiver);
            }
          });
        };
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
__name(proxyIterable, "proxyIterable");
function wrapOpenAI(openai) {
  const oai = openai;
  if (oai && typeof oai === "object" && "chat" in oai && typeof oai.chat === "object" && oai.chat && "completions" in oai.chat && typeof oai.chat.completions === "object" && oai.chat.completions && "create" in oai.chat.completions) {
    return wrapOpenAIv4(oai);
  } else {
    console.warn("Unsupported OpenAI library (potentially v3). Not wrapping.");
    return openai;
  }
}
__name(wrapOpenAI, "wrapOpenAI");
globalThis.__inherited_braintrust_wrap_openai = wrapOpenAI;
function wrapOpenAIv4(openai) {
  const completionProxy = new Proxy(openai.chat.completions, {
    get(target, name, receiver) {
      const baseVal = Reflect.get(target, name, receiver);
      if (name === "create") {
        return wrapChatCompletion(baseVal.bind(target));
      } else if (name === "parse") {
        return wrapBetaChatCompletionParse(baseVal.bind(target));
      }
      return baseVal;
    }
  });
  const chatProxy = new Proxy(openai.chat, {
    get(target, name, receiver) {
      if (name === "completions") {
        return completionProxy;
      }
      return Reflect.get(target, name, receiver);
    }
  });
  const embeddingProxy = createEndpointProxy(openai.embeddings, wrapEmbeddings);
  const moderationProxy = createEndpointProxy(openai.moderations, wrapModerations);
  let betaProxy2;
  if (openai.beta?.chat?.completions?.stream) {
    const betaChatCompletionProxy = new Proxy(openai?.beta?.chat.completions, {
      get(target, name, receiver) {
        const baseVal = Reflect.get(target, name, receiver);
        if (name === "parse") {
          return wrapBetaChatCompletionParse(baseVal.bind(target));
        } else if (name === "stream") {
          return wrapBetaChatCompletionStream(baseVal.bind(target));
        }
        return baseVal;
      }
    });
    const betaChatProxy = new Proxy(openai.beta.chat, {
      get(target, name, receiver) {
        if (name === "completions") {
          return betaChatCompletionProxy;
        }
        return Reflect.get(target, name, receiver);
      }
    });
    betaProxy2 = new Proxy(openai.beta, {
      get(target, name, receiver) {
        if (name === "chat") {
          return betaChatProxy;
        }
        return Reflect.get(target, name, receiver);
      }
    });
  }
  return new Proxy(openai, {
    get(target, name, receiver) {
      switch (name) {
        case "chat":
          return chatProxy;
        case "embeddings":
          return embeddingProxy;
        case "moderations":
          return moderationProxy;
        case "responses":
          return responsesProxy(openai);
      }
      if (name === "beta" && betaProxy2) {
        return betaProxy2;
      }
      return Reflect.get(target, name, receiver);
    }
  });
}
__name(wrapOpenAIv4, "wrapOpenAIv4");
function logCompletionResponse(startTime, response, span) {
  const metrics2 = parseMetricsFromUsage(response?.usage);
  metrics2.time_to_first_token = getCurrentUnixTimestamp() - startTime;
  span.log({
    output: response.choices,
    metrics: metrics2
  });
}
__name(logCompletionResponse, "logCompletionResponse");
function wrapBetaChatCompletionParse(completion) {
  return async (allParams) => {
    const { span_info: _, ...params } = allParams;
    const span = startSpan(
      mergeDicts(
        {
          name: "Chat Completion",
          spanAttributes: {
            type: "llm"
            /* LLM */
          }
        },
        parseChatCompletionParams(allParams)
      )
    );
    const startTime = getCurrentUnixTimestamp();
    const ret = await completion(params);
    try {
      logCompletionResponse(startTime, ret, span);
      return ret;
    } finally {
      span.end();
    }
  };
}
__name(wrapBetaChatCompletionParse, "wrapBetaChatCompletionParse");
function wrapBetaChatCompletionStream(completion) {
  return (allParams) => {
    const { span_info: _, ...params } = allParams;
    const span = startSpan(
      mergeDicts(
        {
          name: "Chat Completion",
          spanAttributes: {
            type: "llm"
            /* LLM */
          }
        },
        parseChatCompletionParams(allParams)
      )
    );
    const startTime = getCurrentUnixTimestamp();
    const ret = completion(params);
    let first2 = true;
    ret.on("chunk", (_chunk) => {
      if (first2) {
        const now2 = getCurrentUnixTimestamp();
        span.log({
          metrics: {
            time_to_first_token: now2 - startTime
          }
        });
        first2 = false;
      }
    });
    ret.on("chatCompletion", (completion2) => {
      span.log({
        output: completion2.choices
      });
    });
    ret.on("end", () => {
      span.end();
    });
    return ret;
  };
}
__name(wrapBetaChatCompletionStream, "wrapBetaChatCompletionStream");
var LEGACY_CACHED_HEADER = "x-cached";
var X_CACHED_HEADER = "x-bt-cached";
function parseCachedHeader(value) {
  return isEmpty(value) ? void 0 : ["true", "hit"].includes(value.toLowerCase()) ? 1 : 0;
}
__name(parseCachedHeader, "parseCachedHeader");
function logHeaders(response, span) {
  const cachedHeader = response.headers.get(X_CACHED_HEADER);
  if (isEmpty(cachedHeader)) {
    const legacyCacheHeader = response.headers.get(LEGACY_CACHED_HEADER);
    if (!isEmpty(legacyCacheHeader)) {
      span.log({
        metrics: {
          cached: parseCachedHeader(legacyCacheHeader)
        }
      });
    }
  } else {
    span.log({
      metrics: {
        cached: parseCachedHeader(cachedHeader)
      }
    });
  }
}
__name(logHeaders, "logHeaders");
function wrapChatCompletion(completion) {
  return (allParams, options) => {
    const { span_info: _, ...params } = allParams;
    let executionPromise = null;
    let dataPromise = null;
    const ensureExecuted = /* @__PURE__ */ __name(() => {
      if (!executionPromise) {
        executionPromise = (async () => {
          const span = startSpan(
            mergeDicts(
              {
                name: "Chat Completion",
                spanAttributes: {
                  type: "llm"
                  /* LLM */
                }
              },
              parseChatCompletionParams(allParams)
            )
          );
          const startTime = getCurrentUnixTimestamp();
          if (params.stream) {
            const { data: ret, response } = await completion(
              // We could get rid of this type coercion if we could somehow enforce
              // that `P extends ChatParams` BUT does not have the property
              // `span_info`.
              // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
              params,
              options
            ).withResponse();
            logHeaders(response, span);
            const wrapperStream = new WrapperStream(
              span,
              startTime,
              ret.iterator()
            );
            ret.iterator = () => wrapperStream[Symbol.asyncIterator]();
            return { data: ret, response };
          } else {
            try {
              const completionResponse = completion(
                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                params,
                options
              );
              const { data: ret, response } = await completionResponse.withResponse();
              logHeaders(response, span);
              const { messages, ...rest } = params;
              span.log({
                input: messages,
                metadata: {
                  ...rest
                }
              });
              logCompletionResponse(startTime, ret, span);
              return { data: ret, response };
            } finally {
              span.end();
            }
          }
        })();
      }
      return executionPromise;
    }, "ensureExecuted");
    return new Proxy({}, {
      get(target, prop, receiver) {
        if (prop === "withResponse") {
          return () => ensureExecuted();
        }
        if (prop === "then" || prop === "catch" || prop === "finally" || prop in Promise.prototype) {
          if (!dataPromise) {
            dataPromise = ensureExecuted().then((result) => result.data);
          }
          const value = Reflect.get(dataPromise, prop, receiver);
          return typeof value === "function" ? value.bind(dataPromise) : value;
        }
        return Reflect.get(target, prop, receiver);
      }
    });
  };
}
__name(wrapChatCompletion, "wrapChatCompletion");
function parseBaseParams(allParams, inputField) {
  const { span_info, ...params } = allParams;
  const { metadata: spanInfoMetadata, ...spanInfoRest } = span_info ?? {};
  const ret = {
    ...spanInfoRest,
    event: {
      metadata: spanInfoMetadata
    }
  };
  const input = params[inputField];
  const paramsRest = { ...params, provider: "openai" };
  delete paramsRest[inputField];
  return mergeDicts(ret, { event: { input, metadata: paramsRest } });
}
__name(parseBaseParams, "parseBaseParams");
function createApiWrapper(name, create, processResponse, parseParams) {
  return async (allParams, options) => {
    const { span_info: _, ...params } = allParams;
    return traced(
      async (span) => {
        const { data: result, response } = await create(
          params,
          options
        ).withResponse();
        logHeaders(response, span);
        processResponse(result, span);
        return result;
      },
      mergeDicts(
        {
          name,
          spanAttributes: {
            type: "llm"
            /* LLM */
          }
        },
        parseParams(allParams)
      )
    );
  };
}
__name(createApiWrapper, "createApiWrapper");
function createEndpointProxy(target, wrapperFn) {
  return new Proxy(target, {
    get(target2, name, receiver) {
      const baseVal = Reflect.get(target2, name, receiver);
      if (name === "create") {
        return wrapperFn(baseVal.bind(target2));
      }
      return baseVal;
    }
  });
}
__name(createEndpointProxy, "createEndpointProxy");
function parseChatCompletionParams(params) {
  return parseBaseParams(params, "messages");
}
__name(parseChatCompletionParams, "parseChatCompletionParams");
function processEmbeddingResponse(result, span) {
  span.log({
    output: { embedding_length: result.data[0].embedding.length },
    metrics: parseMetricsFromUsage(result?.usage)
  });
}
__name(processEmbeddingResponse, "processEmbeddingResponse");
function processModerationResponse(result, span) {
  span.log({
    output: result.results
  });
}
__name(processModerationResponse, "processModerationResponse");
var wrapEmbeddings = /* @__PURE__ */ __name((create) => createApiWrapper(
  "Embedding",
  create,
  processEmbeddingResponse,
  (params) => parseBaseParams(params, "input")
), "wrapEmbeddings");
var wrapModerations = /* @__PURE__ */ __name((create) => createApiWrapper(
  "Moderation",
  create,
  processModerationResponse,
  (params) => parseBaseParams(params, "input")
), "wrapModerations");
function postprocessStreamingResults(allResults) {
  let role = void 0;
  let content = void 0;
  let tool_calls = void 0;
  let finish_reason = void 0;
  let metrics2 = {};
  for (const result of allResults) {
    if (result.usage) {
      metrics2 = {
        ...metrics2,
        ...parseMetricsFromUsage(result?.usage)
      };
    }
    const delta = result.choices?.[0]?.delta;
    if (!delta) {
      continue;
    }
    if (!role && delta.role) {
      role = delta.role;
    }
    if (delta.finish_reason) {
      finish_reason = delta.finish_reason;
    }
    if (delta.content) {
      content = (content || "") + delta.content;
    }
    if (delta.tool_calls) {
      const toolDelta = delta.tool_calls[0];
      if (!tool_calls || toolDelta.id && tool_calls[tool_calls.length - 1].id !== toolDelta.id) {
        tool_calls = [
          ...tool_calls || [],
          {
            id: toolDelta.id,
            type: toolDelta.type,
            function: toolDelta.function
          }
        ];
      } else {
        tool_calls[tool_calls.length - 1].function.arguments += toolDelta.function.arguments;
      }
    }
  }
  return {
    metrics: metrics2,
    output: [
      {
        index: 0,
        message: {
          role,
          content,
          tool_calls
        },
        logprobs: null,
        finish_reason
      }
    ]
  };
}
__name(postprocessStreamingResults, "postprocessStreamingResults");
var WrapperStream = class {
  static {
    __name(this, "WrapperStream");
  }
  span;
  iter;
  startTime;
  constructor(span, startTime, iter) {
    this.span = span;
    this.iter = iter;
    this.startTime = startTime;
  }
  async *[Symbol.asyncIterator]() {
    let first2 = true;
    const allResults = [];
    try {
      for await (const item of this.iter) {
        if (first2) {
          const now2 = getCurrentUnixTimestamp();
          this.span.log({
            metrics: {
              time_to_first_token: now2 - this.startTime
            }
          });
          first2 = false;
        }
        allResults.push(item);
        yield item;
      }
      this.span.log({
        ...postprocessStreamingResults(allResults)
      });
    } finally {
      this.span.end();
    }
  }
};
init_util2();
init_logger();
function finalizeAnthropicTokens(metrics2) {
  const prompt_tokens = (metrics2.prompt_tokens || 0) + (metrics2.prompt_cached_tokens || 0) + (metrics2.prompt_cache_creation_tokens || 0);
  return {
    ...metrics2,
    prompt_tokens,
    tokens: prompt_tokens + (metrics2.completion_tokens || 0)
  };
}
__name(finalizeAnthropicTokens, "finalizeAnthropicTokens");
function extractAnthropicCacheTokens(cacheReadTokens = 0, cacheCreationTokens = 0) {
  const cacheTokens = {};
  if (cacheReadTokens > 0) {
    cacheTokens.prompt_cached_tokens = cacheReadTokens;
  }
  if (cacheCreationTokens > 0) {
    cacheTokens.prompt_cache_creation_tokens = cacheCreationTokens;
  }
  return cacheTokens;
}
__name(extractAnthropicCacheTokens, "extractAnthropicCacheTokens");
init_logger();
function detectProviderFromResult(result) {
  if (!result?.providerMetadata) {
    return void 0;
  }
  const keys = Object.keys(result.providerMetadata);
  return keys?.at(0);
}
__name(detectProviderFromResult, "detectProviderFromResult");
function extractModelFromResult(result) {
  if (result?.response?.modelId) {
    return result.response.modelId;
  }
  if (result?.request?.body?.model) {
    return result.request.body.model;
  }
  return void 0;
}
__name(extractModelFromResult, "extractModelFromResult");
function extractModelFromWrapGenerateCallback(model) {
  return model?.modelId;
}
__name(extractModelFromWrapGenerateCallback, "extractModelFromWrapGenerateCallback");
function camelToSnake(str2) {
  return str2.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}
__name(camelToSnake, "camelToSnake");
function extractModelParameters(params, excludeKeys) {
  const modelParams = {};
  for (const [key, value] of Object.entries(params)) {
    if (value !== void 0 && !excludeKeys.has(key)) {
      const snakeKey = camelToSnake(key);
      modelParams[snakeKey] = value;
    }
  }
  return modelParams;
}
__name(extractModelParameters, "extractModelParameters");
function getNumberProperty(obj, key) {
  if (!obj || typeof obj !== "object" || !(key in obj)) {
    return void 0;
  }
  const value = Reflect.get(obj, key);
  return typeof value === "number" ? value : void 0;
}
__name(getNumberProperty, "getNumberProperty");
function normalizeUsageMetrics(usage, provider, providerMetadata) {
  const metrics2 = {};
  const inputTokens = getNumberProperty(usage, "inputTokens");
  if (inputTokens !== void 0) {
    metrics2.prompt_tokens = inputTokens;
  }
  const outputTokens = getNumberProperty(usage, "outputTokens");
  if (outputTokens !== void 0) {
    metrics2.completion_tokens = outputTokens;
  }
  const totalTokens = getNumberProperty(usage, "totalTokens");
  if (totalTokens !== void 0) {
    metrics2.tokens = totalTokens;
  }
  const reasoningTokens = getNumberProperty(usage, "reasoningTokens");
  if (reasoningTokens !== void 0) {
    metrics2.completion_reasoning_tokens = reasoningTokens;
  }
  const cachedInputTokens = getNumberProperty(usage, "cachedInputTokens");
  if (cachedInputTokens !== void 0) {
    metrics2.prompt_cached_tokens = cachedInputTokens;
  }
  if (provider === "anthropic") {
    const anthropicMetadata = providerMetadata?.anthropic;
    if (anthropicMetadata) {
      const cacheReadTokens = getNumberProperty(anthropicMetadata.usage, "cache_read_input_tokens") || 0;
      const cacheCreationTokens = getNumberProperty(
        anthropicMetadata.usage,
        "cache_creation_input_tokens"
      ) || 0;
      const cacheTokens = extractAnthropicCacheTokens(
        cacheReadTokens,
        cacheCreationTokens
      );
      Object.assign(metrics2, cacheTokens);
      Object.assign(metrics2, finalizeAnthropicTokens(metrics2));
    }
  }
  return metrics2;
}
__name(normalizeUsageMetrics, "normalizeUsageMetrics");
function normalizeFinishReason(reason) {
  if (typeof reason !== "string") return void 0;
  return reason.replace(/-/g, "_");
}
__name(normalizeFinishReason, "normalizeFinishReason");
function extractToolCallsFromSteps(steps) {
  const toolCalls = [];
  if (!Array.isArray(steps)) return toolCalls;
  let idx = 0;
  for (const step of steps) {
    const blocks = step?.content;
    if (!Array.isArray(blocks)) continue;
    for (const block of blocks) {
      if (block && typeof block === "object" && block.type === "tool-call") {
        toolCalls.push({
          id: block.toolCallId,
          type: "function",
          index: idx++,
          function: {
            name: block.toolName,
            arguments: typeof block.input === "string" ? block.input : JSON.stringify(block.input ?? {})
          }
        });
      }
    }
  }
  return toolCalls;
}
__name(extractToolCallsFromSteps, "extractToolCallsFromSteps");
function buildAssistantOutputWithToolCalls(result, toolCalls) {
  return [
    {
      index: 0,
      logprobs: null,
      finish_reason: normalizeFinishReason(result?.finishReason) ?? (toolCalls.length ? "tool_calls" : void 0),
      message: {
        role: "assistant",
        tool_calls: toolCalls.length > 0 ? toolCalls : void 0
      }
    }
  ];
}
__name(buildAssistantOutputWithToolCalls, "buildAssistantOutputWithToolCalls");
function extractToolCallsFromBlocks(blocks) {
  if (!Array.isArray(blocks)) return [];
  return extractToolCallsFromSteps([{ content: blocks }]);
}
__name(extractToolCallsFromBlocks, "extractToolCallsFromBlocks");
function wrapTools(tools) {
  if (!tools) return tools;
  const inferName = /* @__PURE__ */ __name((tool, fallback2) => tool && (tool.name || tool.toolName || tool.id) || fallback2, "inferName");
  if (Array.isArray(tools)) {
    const arr = tools;
    const out = arr.map((tool, idx) => {
      if (tool != null && typeof tool === "object" && "execute" in tool && typeof tool.execute === "function") {
        const name = inferName(tool, `tool[${idx}]`);
        return {
          ...tool,
          execute: wrapTraced(tool.execute.bind(tool), {
            name,
            type: "tool"
          })
        };
      }
      return tool;
    });
    return out;
  }
  const wrappedTools = {};
  for (const [key, tool] of Object.entries(tools)) {
    if (tool != null && typeof tool === "object" && "execute" in tool && typeof tool.execute === "function") {
      wrappedTools[key] = {
        ...tool,
        execute: wrapTraced(tool.execute.bind(tool), {
          name: key,
          type: "tool"
        })
      };
    } else {
      wrappedTools[key] = tool;
    }
  }
  return wrappedTools;
}
__name(wrapTools, "wrapTools");
function extractInput(params) {
  return params?.prompt ?? params?.messages ?? params?.system;
}
__name(extractInput, "extractInput");
var V2_EXCLUDE_KEYS = /* @__PURE__ */ new Set([
  "prompt",
  // Already captured as input
  "system",
  // Already captured as input
  "messages",
  // Already captured as input
  "model",
  // Already captured in metadata.model
  "providerOptions"
  // Internal AI SDK configuration
]);
function BraintrustMiddleware(config2 = {}) {
  return {
    wrapGenerate: /* @__PURE__ */ __name(async ({
      doGenerate,
      params,
      model: modelFromWrapGenerate
    }) => {
      const spanArgs = {
        name: "ai-sdk.generateText",
        spanAttributes: {
          type: "llm"
          /* LLM */
        },
        event: {
          input: params.prompt,
          metadata: {
            ...extractModelParameters(params, V2_EXCLUDE_KEYS)
          }
        }
      };
      const span = startSpan(spanArgs);
      try {
        const result = await doGenerate();
        const metadata = {};
        const provider = detectProviderFromResult(result);
        if (provider !== void 0) {
          metadata.provider = provider;
        }
        if (result.finishReason !== void 0) {
          metadata.finish_reason = result.finishReason;
        }
        const model = extractModelFromResult(result);
        if (model !== void 0) {
          metadata.model = model;
        } else if (modelFromWrapGenerate) {
          const modelId = extractModelFromWrapGenerateCallback(
            modelFromWrapGenerate
          );
          if (modelId) {
            metadata.model = modelId;
          }
        }
        let toolCalls = extractToolCallsFromSteps(result?.steps);
        if (!toolCalls || toolCalls.length === 0) {
          toolCalls = extractToolCallsFromBlocks(result?.content);
        }
        span.log({
          output: toolCalls.length > 0 ? buildAssistantOutputWithToolCalls(result, toolCalls) : result?.content,
          metadata,
          metrics: normalizeUsageMetrics(
            result.usage,
            provider,
            result.providerMetadata
          )
        });
        return result;
      } catch (error22) {
        span.log({
          error: error22 instanceof Error ? error22.message : String(error22)
        });
        throw error22;
      } finally {
        span.end();
      }
    }, "wrapGenerate"),
    wrapStream: /* @__PURE__ */ __name(async ({ doStream, params }) => {
      const spanArgs = {
        name: "ai-sdk.streamText",
        spanAttributes: {
          type: "llm"
          /* LLM */
        },
        event: {
          input: params.prompt,
          metadata: {
            ...extractModelParameters(params, V2_EXCLUDE_KEYS)
          }
        }
      };
      const span = startSpan(spanArgs);
      try {
        const { stream, ...rest } = await doStream();
        const textChunks = [];
        const toolBlocks = [];
        let finalUsage = {};
        let finalFinishReason = void 0;
        let providerMetadata = {};
        const transformStream = new TransformStream({
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          transform(chunk, controller) {
            try {
              if (chunk.type === "text-delta" && chunk.delta) {
                textChunks.push(chunk.delta);
              }
              if (chunk.type === "tool-call" || chunk.type === "tool-result") {
                toolBlocks.push(chunk);
              }
              if (chunk.type === "finish") {
                finalFinishReason = chunk.finishReason;
                finalUsage = chunk.usage || {};
                providerMetadata = chunk.providerMetadata || {};
              }
              controller.enqueue(chunk);
            } catch (error22) {
              span.log({
                error: error22 instanceof Error ? error22.message : String(error22)
              });
              span.end();
              controller.error(error22);
            }
          },
          flush() {
            try {
              const generatedText = textChunks.join("");
              let output = generatedText ? [{ type: "text", text: generatedText }] : [];
              const resultForDetection = {
                providerMetadata,
                response: rest.response,
                ...rest,
                finishReason: finalFinishReason
              };
              const metadata = {};
              const provider = detectProviderFromResult(resultForDetection);
              if (provider !== void 0) {
                metadata.provider = provider;
              }
              if (finalFinishReason !== void 0) {
                metadata.finish_reason = finalFinishReason;
              }
              const model = extractModelFromResult(resultForDetection);
              if (model !== void 0) {
                metadata.model = model;
              }
              if (toolBlocks.length > 0) {
                const toolCalls = extractToolCallsFromSteps([
                  { content: toolBlocks }
                ]);
                if (toolCalls.length > 0) {
                  output = buildAssistantOutputWithToolCalls(
                    resultForDetection,
                    toolCalls
                  );
                }
              }
              span.log({
                output,
                metadata,
                metrics: normalizeUsageMetrics(
                  finalUsage,
                  provider,
                  providerMetadata
                )
              });
              span.end();
            } catch (error22) {
              span.log({
                error: error22 instanceof Error ? error22.message : String(error22)
              });
              span.end();
              throw error22;
            }
          }
        });
        return {
          stream: stream.pipeThrough(transformStream),
          ...rest
        };
      } catch (error22) {
        span.log({
          error: error22 instanceof Error ? error22.message : String(error22)
        });
        span.end();
        throw error22;
      }
    }, "wrapStream")
  };
}
__name(BraintrustMiddleware, "BraintrustMiddleware");
init_logger();
init_util22();
function wrapAISDKModel(model) {
  const m = model;
  if (m?.specificationVersion === "v1" && typeof m?.provider === "string" && typeof m?.modelId === "string") {
    return new BraintrustLanguageModelWrapper(m);
  } else {
    console.warn("Unsupported AI SDK model. Not wrapping.");
    return model;
  }
}
__name(wrapAISDKModel, "wrapAISDKModel");
var BraintrustLanguageModelWrapper = class {
  static {
    __name(this, "BraintrustLanguageModelWrapper");
  }
  constructor(model) {
    this.model = model;
    if (typeof this.model.supportsUrl === "function") {
      this.supportsUrl = (url) => this.model.supportsUrl(url);
    }
  }
  supportsUrl;
  get specificationVersion() {
    return this.model.specificationVersion;
  }
  get provider() {
    return this.model.provider;
  }
  get modelId() {
    return this.model.modelId;
  }
  get defaultObjectGenerationMode() {
    return this.model.defaultObjectGenerationMode;
  }
  get supportsImageUrls() {
    return this.model.supportsImageUrls;
  }
  get supportsStructuredOutputs() {
    return this.model.supportsStructuredOutputs;
  }
  // For the first cut, do not support custom span_info arguments. We can
  // propagate those via async local storage
  async doGenerate(options) {
    const span = startSpan({
      name: "Chat Completion",
      spanAttributes: {
        type: "llm"
      }
    });
    const { prompt, mode, ...rest } = options;
    const startTime = getCurrentUnixTimestamp();
    try {
      const ret = await this.model.doGenerate(options);
      span.log({
        input: postProcessPrompt(prompt),
        metadata: {
          model: this.modelId,
          ...rest,
          ..."tools" in mode && mode.tools ? { tools: convertTools(mode.tools) } : "tool" in mode && mode.tool ? { tools: convertTools([mode.tool]) } : {}
        },
        output: postProcessOutput(ret.text, ret.toolCalls, ret.finishReason),
        metrics: {
          time_to_first_token: getCurrentUnixTimestamp() - startTime,
          tokens: !isEmpty(ret.usage) ? ret.usage.promptTokens + ret.usage.completionTokens : void 0,
          prompt_tokens: ret.usage?.promptTokens,
          completion_tokens: ret.usage?.completionTokens,
          cached: parseCachedHeader(
            ret.rawResponse?.headers?.[X_CACHED_HEADER] ?? ret.rawResponse?.headers?.[LEGACY_CACHED_HEADER]
          )
        }
      });
      return ret;
    } finally {
      span.end();
    }
  }
  async doStream(options) {
    const { prompt, mode, ...rest } = options;
    const startTime = getCurrentUnixTimestamp();
    const span = startSpan({
      name: "Chat Completion",
      spanAttributes: {
        type: "llm"
      }
    });
    span.log({
      input: postProcessPrompt(prompt),
      metadata: {
        model: this.modelId,
        ...rest,
        ..."tools" in mode && mode.tools ? { tools: convertTools(mode.tools) } : "tool" in mode && mode.tool ? { tools: convertTools([mode.tool]) } : {}
      }
    });
    let ended = false;
    const end = /* @__PURE__ */ __name(() => {
      if (!ended) {
        span.end();
        ended = true;
      }
    }, "end");
    try {
      const ret = await this.model.doStream(options);
      let time_to_first_token = void 0;
      let usage = void 0;
      let fullText = void 0;
      const toolCalls = {};
      let finishReason = void 0;
      return {
        ...ret,
        stream: ret.stream.pipeThrough(
          new TransformStream({
            transform(chunk, controller) {
              if (time_to_first_token === void 0) {
                time_to_first_token = getCurrentUnixTimestamp() - startTime;
                span.log({ metrics: { time_to_first_token } });
              }
              switch (chunk.type) {
                case "text-delta":
                  if (fullText === void 0) {
                    fullText = "";
                  }
                  fullText += chunk.textDelta;
                  break;
                case "tool-call":
                  toolCalls[chunk.toolCallId] = {
                    toolCallType: chunk.toolCallType,
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    args: chunk.args
                  };
                  break;
                case "tool-call-delta":
                  if (toolCalls[chunk.toolCallId] === void 0) {
                    toolCalls[chunk.toolCallId] = {
                      toolCallType: chunk.toolCallType,
                      toolCallId: chunk.toolCallId,
                      toolName: chunk.toolName,
                      args: ""
                    };
                  }
                  toolCalls[chunk.toolCallId].args += chunk.argsTextDelta;
                  break;
                case "finish":
                  usage = chunk.usage;
                  finishReason = chunk.finishReason;
                  break;
              }
              controller.enqueue(chunk);
            },
            async flush(controller) {
              span.log({
                output: postProcessOutput(
                  fullText,
                  Object.keys(toolCalls).length > 0 ? Object.values(toolCalls) : void 0,
                  finishReason
                ),
                metrics: {
                  time_to_first_token,
                  tokens: !isEmpty(usage) ? usage.promptTokens + usage.completionTokens : void 0,
                  prompt_tokens: usage?.promptTokens,
                  completion_tokens: usage?.completionTokens,
                  cached: parseCachedHeader(
                    ret.rawResponse?.headers?.[X_CACHED_HEADER] ?? ret.rawResponse?.headers?.[LEGACY_CACHED_HEADER]
                  )
                }
              });
              end();
              controller.terminate();
            }
          })
        )
      };
    } finally {
      end();
    }
  }
};
function convertTools(tools) {
  return tools.map((tool) => {
    const { type: _, ...rest } = tool;
    return {
      type: tool.type,
      function: rest
    };
  });
}
__name(convertTools, "convertTools");
function postProcessPrompt(prompt) {
  return prompt.flatMap((message) => {
    switch (message.role) {
      case "system":
        return [
          {
            role: "system",
            content: message.content
          }
        ];
      case "assistant":
        const textPart = message.content.find(
          (part) => part.type === "text"
        );
        const toolCallParts = (
          // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
          message.content.filter(
            (part) => part.type === "tool-call"
          )
        );
        return [
          {
            role: "assistant",
            content: textPart?.text,
            ...toolCallParts.length > 0 ? {
              tool_calls: toolCallParts.map((part) => ({
                id: part.toolCallId,
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.args)
                },
                type: "function"
              }))
            } : {}
          }
        ];
      case "user":
        return [
          {
            role: "user",
            content: message.content.map((part) => {
              switch (part.type) {
                case "text":
                  return {
                    type: "text",
                    text: part.text,
                    ...part.providerMetadata ? { providerMetadata: part.providerMetadata } : {}
                  };
                case "image":
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.image.toString(),
                      ...part.providerMetadata ? { providerMetadata: part.providerMetadata } : {}
                    }
                  };
                default:
                  return part;
              }
            })
          }
        ];
      case "tool":
        return message.content.map((part) => ({
          role: "tool",
          tool_call_id: part.toolCallId,
          content: JSON.stringify(part.result)
        }));
    }
  });
}
__name(postProcessPrompt, "postProcessPrompt");
function postProcessOutput(text, toolCalls, finishReason) {
  return [
    {
      index: 0,
      message: {
        role: "assistant",
        content: text ?? "",
        ...toolCalls && toolCalls.length > 0 ? {
          tool_calls: toolCalls.map((toolCall) => ({
            id: toolCall.toolCallId,
            function: {
              name: toolCall.toolName,
              arguments: toolCall.args
            },
            type: "function"
          }))
        } : {}
      },
      finish_reason: finishReason
    }
  ];
}
__name(postProcessOutput, "postProcessOutput");
init_logger();
var V3_EXCLUDE_KEYS = /* @__PURE__ */ new Set([
  "prompt",
  // Already captured as input
  "system",
  // Already captured as input
  "messages",
  // Already captured as input
  "model",
  // Already captured in metadata.model
  "providerOptions",
  // Internal AI SDK configuration
  "tools"
  // Already captured in metadata.tools
]);
function wrapAISDK(ai) {
  const {
    wrapLanguageModel,
    generateText,
    streamText,
    generateObject,
    streamObject
  } = ai;
  const wrappedGenerateText = /* @__PURE__ */ __name((params) => {
    return traced(
      async (span) => {
        const wrappedModel = wrapLanguageModel({
          model: params.model,
          middleware: BraintrustMiddleware()
        });
        const result = await generateText({
          ...params,
          tools: params.tools ? wrapTools(params.tools) : void 0,
          model: wrappedModel
        });
        const provider = detectProviderFromResult(result);
        const model = extractModelFromResult(result);
        const finishReason = normalizeFinishReason(result?.finishReason);
        span.log({
          input: extractInput(params),
          output: result.text,
          metadata: {
            ...extractModelParameters(params, V3_EXCLUDE_KEYS),
            ...provider ? { provider } : {},
            ...model ? { model } : {},
            ...finishReason ? { finish_reason: finishReason } : {}
          }
        });
        return result;
      },
      {
        name: "ai-sdk.generateText"
      }
    );
  }, "wrappedGenerateText");
  const wrappedGenerateObject = /* @__PURE__ */ __name((params) => {
    return traced(
      async (span) => {
        const wrappedModel = wrapLanguageModel({
          model: params.model,
          middleware: BraintrustMiddleware()
        });
        const result = await generateObject({
          ...params,
          tools: params.tools ? wrapTools(params.tools) : void 0,
          model: wrappedModel
        });
        const provider = detectProviderFromResult(result);
        const model = extractModelFromResult(result);
        const finishReason = normalizeFinishReason(result.finishReason);
        span.log({
          input: extractInput(params),
          output: result.object,
          metadata: {
            ...extractModelParameters(params, V3_EXCLUDE_KEYS),
            ...provider ? { provider } : {},
            ...model ? { model } : {},
            ...finishReason ? { finish_reason: finishReason } : {}
          }
        });
        return result;
      },
      {
        name: "ai-sdk.generateObject"
      }
    );
  }, "wrappedGenerateObject");
  const wrappedStreamText = /* @__PURE__ */ __name((params) => {
    const span = startSpan({
      name: "ai-sdk.streamText",
      event: {
        input: extractInput(params),
        metadata: extractModelParameters(params, V3_EXCLUDE_KEYS)
      }
    });
    const userOnFinish = params.onFinish;
    const userOnError = params.onError;
    const userOnChunk = params.onChunk;
    try {
      const wrappedModel = wrapLanguageModel({
        model: params.model,
        middleware: BraintrustMiddleware()
      });
      const startTime = Date.now();
      let receivedFirst = false;
      const result = withCurrent(
        span,
        () => streamText({
          ...params,
          tools: params.tools ? wrapTools(params.tools) : void 0,
          model: wrappedModel,
          onChunk: /* @__PURE__ */ __name((chunk) => {
            if (!receivedFirst) {
              receivedFirst = true;
              span.log({
                metrics: {
                  time_to_first_token: (Date.now() - startTime) / 1e3
                }
              });
            }
            if (typeof userOnChunk === "function") {
              userOnChunk(chunk);
            }
          }, "onChunk"),
          onFinish: /* @__PURE__ */ __name(async (event) => {
            if (typeof userOnFinish === "function") {
              await userOnFinish(event);
            }
            const provider = detectProviderFromResult(event);
            const model = extractModelFromResult(event);
            const finishReason = normalizeFinishReason(event?.finishReason);
            span.log({
              output: event?.text,
              metadata: {
                ...extractModelParameters(params, V3_EXCLUDE_KEYS),
                ...provider ? { provider } : {},
                ...model ? { model } : {},
                ...finishReason ? { finish_reason: finishReason } : {}
              }
            });
            span.end();
          }, "onFinish"),
          onError: /* @__PURE__ */ __name(async (err) => {
            if (typeof userOnError === "function") {
              await userOnError(err);
            }
            span.log({
              error: err instanceof Error ? err.message : String(err)
            });
            span.end();
          }, "onError")
        })
      );
      return result;
    } catch (error22) {
      span.log({
        error: error22 instanceof Error ? error22.message : String(error22)
      });
      span.end();
      throw error22;
    }
  }, "wrappedStreamText");
  const wrappedStreamObject = /* @__PURE__ */ __name((params) => {
    const span = startSpan({
      name: "ai-sdk.streamObject",
      event: {
        input: extractInput(params),
        metadata: extractModelParameters(params, V3_EXCLUDE_KEYS)
      }
    });
    const userOnFinish = params.onFinish;
    const userOnError = params.onError;
    try {
      const wrappedModel = wrapLanguageModel({
        model: params.model,
        middleware: BraintrustMiddleware()
      });
      const result = withCurrent(
        span,
        () => streamObject({
          ...params,
          tools: params.tools ? wrapTools(params.tools) : void 0,
          model: wrappedModel,
          onFinish: /* @__PURE__ */ __name(async (event) => {
            if (typeof userOnFinish === "function") {
              await userOnFinish(event);
            }
            const provider = detectProviderFromResult(event);
            const model = extractModelFromResult(event);
            const finishReason = normalizeFinishReason(event?.finishReason);
            span.log({
              output: event?.object,
              metadata: {
                ...extractModelParameters(params, V3_EXCLUDE_KEYS),
                ...provider ? { provider } : {},
                ...model ? { model } : {},
                ...finishReason ? { finish_reason: finishReason } : {}
              }
            });
            span.end();
          }, "onFinish"),
          onError: /* @__PURE__ */ __name(async (err) => {
            if (typeof userOnError === "function") {
              await userOnError(err);
            }
            span.log({
              error: err instanceof Error ? err.message : String(err)
            });
            span.end();
          }, "onError")
        })
      );
      const startTime = Date.now();
      let receivedFirst = false;
      const trackFirstAccess = /* @__PURE__ */ __name(() => {
        if (!receivedFirst) {
          receivedFirst = true;
          span.log({
            metrics: {
              time_to_first_token: (Date.now() - startTime) / 1e3
            }
          });
        }
      }, "trackFirstAccess");
      const [stream1, stream2] = result.baseStream.tee();
      result.baseStream = stream2;
      stream1.pipeThrough(
        new TransformStream({
          transform(chunk, controller) {
            trackFirstAccess();
            controller.enqueue(chunk);
          }
        })
      ).pipeTo(
        new WritableStream({
          write() {
          }
        })
      ).catch(() => {
      });
      return result;
    } catch (error22) {
      span.log({
        error: error22 instanceof Error ? error22.message : String(error22)
      });
      span.end();
      throw error22;
    }
  }, "wrappedStreamObject");
  return {
    generateText: wrappedGenerateText,
    generateObject: wrappedGenerateObject,
    streamText: wrappedStreamText,
    streamObject: wrappedStreamObject
  };
}
__name(wrapAISDK, "wrapAISDK");
init_logger();
var aiSDKFormatWarning = false;
function wrapMastraAgent(agent, options) {
  const prefix = options?.name ?? options?.span_name ?? agent.name ?? "Agent";
  if (!hasAllMethods(agent)) {
    return agent;
  }
  if (agent.tools) {
    agent.__setTools(wrapTools(agent.tools));
  }
  return new Proxy(agent, {
    get(target, prop, receiver) {
      const value = Reflect.get(target, prop, receiver);
      if (prop === "generate" && typeof value === "function") {
        return wrapGenerate(value, target, prefix);
      }
      if (prop === "stream" && typeof value === "function") {
        return wrapStream(value, target, prefix);
      }
      if (typeof value === "function") {
        return value.bind(target);
      }
      return value;
    }
  });
}
__name(wrapMastraAgent, "wrapMastraAgent");
function hasAllMethods(a) {
  return typeof a.generate === "function" && typeof a.stream === "function";
}
__name(hasAllMethods, "hasAllMethods");
function wrapGenerate(original, target, prefix) {
  return function(...args) {
    const input = args[0];
    return traced(
      async (span) => {
        const result = await original.apply(target, args);
        const provider = detectProviderFromResult(result);
        const model = extractModelFromResult(result);
        const finishReason = normalizeFinishReason(result?.finishReason);
        const metrics2 = result?.usage ? normalizeUsageMetrics(
          result.usage,
          provider,
          result.providerMetadata
        ) : {};
        span.log({
          input,
          output: result,
          metadata: {
            agent_name: target.name ?? prefix,
            ...provider ? { provider } : {},
            ...model ? { model } : {},
            ...finishReason ? { finish_reason: finishReason } : {}
          },
          metrics: metrics2
        });
        return result;
      },
      {
        name: `${prefix}.generate`
      }
    );
  };
}
__name(wrapGenerate, "wrapGenerate");
function wrapStream(original, target, prefix) {
  return function(...args) {
    const input = args[0];
    const span = startSpan({
      name: `${prefix}.stream`,
      event: {
        input,
        metadata: {
          agent_name: target.name ?? prefix
        }
      }
    });
    const baseOpts = typeof args[1] === "object" && args[1] !== null ? args[1] : {};
    if (baseOpts.format && baseOpts.format !== "aisdk" && !aiSDKFormatWarning) {
      aiSDKFormatWarning = true;
      console.warn(
        `Braintrust Mastra wrapper: For best compatibility, use { format: 'aisdk' } (AI SDK v5) instead of format: '${baseOpts.format}'. See https://mastra.ai/en/docs/frameworks/agentic-uis/ai-sdk for more details.`
      );
    }
    const wrappedOpts = {
      ...baseOpts,
      format: baseOpts.format || "aisdk"
      // Default to AI SDK v5 format if not specified
    };
    const userOnChunk = baseOpts?.onChunk;
    const userOnFinish = baseOpts?.onFinish;
    const userOnError = baseOpts?.onError;
    const startTime = Date.now();
    let receivedFirst = false;
    wrappedOpts.onChunk = (chunk) => {
      try {
        userOnChunk?.(chunk);
      } finally {
        if (!receivedFirst) {
          receivedFirst = true;
          span.log({
            metrics: { time_to_first_token: (Date.now() - startTime) / 1e3 }
          });
        }
      }
    };
    wrappedOpts.onFinish = async (event) => {
      try {
        await userOnFinish?.(event);
      } finally {
        const e = event;
        const provider = detectProviderFromResult(e);
        const model = extractModelFromResult(e);
        const finishReason = normalizeFinishReason(e?.finishReason);
        const metrics2 = e?.usage ? normalizeUsageMetrics(e.usage, provider, e.providerMetadata) : {};
        span.log({
          output: e.text ?? e.content ?? e,
          metadata: {
            agent_name: target.name ?? prefix,
            ...provider ? { provider } : {},
            ...model ? { model } : {},
            ...finishReason ? { finish_reason: finishReason } : {}
          },
          metrics: metrics2
        });
        span.end();
      }
    };
    wrappedOpts.onError = async (err) => {
      try {
        await userOnError?.(err);
      } finally {
        logError(span, err);
        span.end();
      }
    };
    return withCurrent(
      span,
      () => original.apply(target, [args[0], wrappedOpts, ...args.slice(2)])
    );
  };
}
__name(wrapStream, "wrapStream");
init_logger();
init_util2();
init_util22();
init_util2();
function wrapAnthropic(anthropic) {
  const au = anthropic;
  if (au && typeof au === "object" && "messages" in au && typeof au.messages === "object" && au.messages && "create" in au.messages) {
    return anthropicProxy(au);
  } else {
    console.warn("Unsupported Anthropic library. Not wrapping.");
    return anthropic;
  }
}
__name(wrapAnthropic, "wrapAnthropic");
function anthropicProxy(anthropic) {
  return new Proxy(anthropic, {
    get(target, prop, receiver) {
      switch (prop) {
        case "beta":
          return betaProxy(target.beta);
        case "messages":
          return messagesProxy(target.messages);
        default:
          return Reflect.get(target, prop, receiver);
      }
    }
  });
}
__name(anthropicProxy, "anthropicProxy");
function betaProxy(beta) {
  return new Proxy(beta, {
    get(target, prop, receiver) {
      if (prop === "messages") {
        return messagesProxy(target.messages);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
__name(betaProxy, "betaProxy");
function messagesProxy(messages) {
  return new Proxy(messages, {
    get(target, prop, receiver) {
      switch (prop) {
        case "create":
          return createProxy(target.create);
        default:
          return Reflect.get(target, prop, receiver);
      }
    }
  });
}
__name(messagesProxy, "messagesProxy");
function createProxy(create) {
  return new Proxy(create, {
    apply(target, thisArg, argArray) {
      if (argArray.length === 0) {
        return Reflect.apply(target, thisArg, argArray);
      }
      const args = argArray[0];
      const input = coalesceInput(args["messages"] || [], args["system"]);
      const metadata = filterFrom(args, ["messages", "system"]);
      const spanArgs = {
        name: "anthropic.messages.create",
        spanAttributes: {
          type: "llm"
          /* LLM */
        },
        event: {
          input: processAttachmentsInInput(input),
          metadata: { ...metadata, provider: "anthropic" }
        },
        startTime: getCurrentUnixTimestamp()
      };
      const span = startSpan(spanArgs);
      const sspan = { span, startTime: spanArgs.startTime };
      const apiPromise = Reflect.apply(target, thisArg, argArray);
      const onThen = /* @__PURE__ */ __name(function(msgOrStream) {
        if (!args["stream"]) {
          const event = parseEventFromMessage(msgOrStream);
          span.log({
            ...event,
            metrics: event.metrics ? finalizeAnthropicTokens(event.metrics) : void 0
          });
          span.end();
          return msgOrStream;
        }
        return streamProxy(msgOrStream, sspan);
      }, "onThen");
      return apiPromiseProxy2(apiPromise, sspan, onThen);
    }
  });
}
__name(createProxy, "createProxy");
function apiPromiseProxy2(apiPromise, span, onThen) {
  return new Proxy(apiPromise, {
    get(target, prop, receiver) {
      if (prop === "then") {
        const thenFunc = Reflect.get(target, prop, receiver);
        return function(onFulfilled, onRejected) {
          return thenFunc.call(
            target,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            async (result) => {
              try {
                const processed = onThen(result);
                return onFulfilled ? onFulfilled(processed) : processed;
              } catch (error22) {
                return onRejected ? onRejected(error22) : Promise.reject(error22);
              }
            },
            onRejected
          );
        };
      } else if (prop === "withResponse") {
        const withResponseFunc = Reflect.get(target, prop, receiver);
        return () => {
          return withResponseFunc.call(target).then((withResponse) => {
            if (withResponse["data"]) {
              const { data: stream } = withResponse;
              withResponse.data = streamProxy(stream, span);
            }
            return Promise.resolve(withResponse);
          });
        };
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
__name(apiPromiseProxy2, "apiPromiseProxy2");
function streamProxy(stream, span) {
  return new Proxy(stream, {
    get(target, prop, receiver) {
      if (prop === Symbol.asyncIterator) {
        const original = Reflect.get(target, prop, receiver);
        return function() {
          const iterator = original.call(target);
          return new Proxy(iterator, {
            get(iterTarget, iterProp, iterReceiver) {
              if (iterProp === "next") {
                return streamNextProxy(iterator, span);
              }
              return Reflect.get(iterTarget, iterProp, iterReceiver);
            }
          });
        };
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
__name(streamProxy, "streamProxy");
function streamNextProxy(stream, sspan) {
  let ttft = -1;
  const deltas = [];
  let metadata = {};
  let totals = {};
  const span = sspan.span;
  const contentBlocks = [];
  return async function(...args) {
    const result = await stream.next(...args);
    if (ttft < 0) {
      ttft = getCurrentUnixTimestamp() - sspan.startTime;
      totals.time_to_first_token = ttft;
    }
    if (result.done) {
      const output = deltas.join("");
      span.log({
        output,
        metrics: finalizeAnthropicTokens(totals),
        metadata
      });
      span.end();
      return result;
    }
    const item = result.value;
    switch (item?.type) {
      case "message_start":
        const msg = item?.message;
        if (msg) {
          const event = parseEventFromMessage(msg);
          totals = { ...totals, ...event.metrics };
          span.log(event);
        }
        break;
      case "content_block_start":
        if (item.content_block) {
          contentBlocks[item.index] = item.content_block;
        }
        break;
      case "content_block_delta":
        if (item.delta?.type === "text_delta") {
          const text = item?.delta?.text;
          if (text) {
            deltas.push(text);
          }
        }
        break;
      case "message_delta":
        const usage = item?.usage;
        if (usage) {
          const metrics2 = parseMetricsFromUsage2(usage);
          totals = { ...totals, ...metrics2 };
        }
        const delta = item?.delta;
        if (delta) {
          metadata = { ...metadata, ...delta };
        }
        break;
      case "message_stop":
        break;
    }
    return result;
  };
}
__name(streamNextProxy, "streamNextProxy");
function parseEventFromMessage(message) {
  const output = message ? { role: message.role, content: message.content } : null;
  const metrics2 = parseMetricsFromUsage2(message?.usage);
  const metas = ["stop_reason", "stop_sequence"];
  const metadata = {};
  for (const m of metas) {
    if (message[m] !== void 0) {
      metadata[m] = message[m];
    }
  }
  return {
    output,
    metrics: metrics2,
    metadata
  };
}
__name(parseEventFromMessage, "parseEventFromMessage");
function parseMetricsFromUsage2(usage) {
  if (!usage) {
    return void 0;
  }
  const metrics2 = {};
  function saveIfExistsTo(source, target) {
    const value = usage[source];
    if (value !== void 0 && value !== null) {
      metrics2[target] = value;
    }
  }
  __name(saveIfExistsTo, "saveIfExistsTo");
  saveIfExistsTo("input_tokens", "prompt_tokens");
  saveIfExistsTo("output_tokens", "completion_tokens");
  saveIfExistsTo("cache_read_input_tokens", "prompt_cached_tokens");
  saveIfExistsTo("cache_creation_input_tokens", "prompt_cache_creation_tokens");
  return metrics2;
}
__name(parseMetricsFromUsage2, "parseMetricsFromUsage2");
function convertBase64ToAttachment(source, contentType) {
  const mediaType = typeof source.media_type === "string" ? source.media_type : "image/png";
  const base64Data = source.data;
  if (base64Data && typeof base64Data === "string") {
    const binaryString = atob(base64Data);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    const blob = new Blob([bytes], { type: mediaType });
    const extension = mediaType.split("/")[1] || "bin";
    const prefix = contentType === "document" ? "document" : "image";
    const filename = `${prefix}.${extension}`;
    const attachment = new Attachment({
      data: blob,
      filename,
      contentType: mediaType
    });
    return {
      ...source,
      data: attachment
    };
  }
  return source;
}
__name(convertBase64ToAttachment, "convertBase64ToAttachment");
function processAttachmentsInInput(input) {
  if (Array.isArray(input)) {
    return input.map(processAttachmentsInInput);
  }
  if (isObject(input)) {
    if ((input.type === "image" || input.type === "document") && isObject(input.source) && input.source.type === "base64") {
      return {
        ...input,
        source: convertBase64ToAttachment(input.source, input.type)
      };
    }
    const processed = {};
    for (const [key, value] of Object.entries(input)) {
      processed[key] = processAttachmentsInInput(value);
    }
    return processed;
  }
  return input;
}
__name(processAttachmentsInInput, "processAttachmentsInInput");
function coalesceInput(messages, system) {
  const input = (messages || []).slice();
  if (system) {
    input.push({ role: "system", content: system });
  }
  return input;
}
__name(coalesceInput, "coalesceInput");
init_logger();
init_util22();
init_util2();
function filterSerializableOptions(options) {
  const allowedKeys = [
    "model",
    "maxTurns",
    "cwd",
    "continue",
    "allowedTools",
    "disallowedTools",
    "additionalDirectories",
    "permissionMode",
    "debug",
    "apiKey",
    "apiKeySource",
    "agentName",
    "instructions"
  ];
  const filtered = {};
  for (const key of allowedKeys) {
    if (options[key] !== void 0) {
      filtered[key] = options[key];
    }
  }
  return filtered;
}
__name(filterSerializableOptions, "filterSerializableOptions");
function wrapClaudeAgentQuery(queryFn, defaultThis) {
  const proxy = new Proxy(queryFn, {
    apply(target, thisArg, argArray) {
      const params = argArray[0] ?? {};
      const { prompt, options = {} } = params;
      const span = startSpan({
        name: "Claude Agent",
        spanAttributes: {
          type: "task"
          /* TASK */
        },
        event: {
          input: typeof prompt === "string" ? prompt : { type: "streaming", description: "AsyncIterable<SDKMessage>" },
          metadata: filterSerializableOptions(options)
        }
      });
      const finalResults = [];
      let finalUsageMetrics;
      let accumulatedOutputTokens = 0;
      let currentMessageId;
      let currentMessageStartTime = getCurrentUnixTimestamp();
      const currentMessages = [];
      const createLLMSpan = /* @__PURE__ */ __name(async () => {
        const finalMessageContent = await _createLLMSpanForMessages(
          currentMessages,
          prompt,
          finalResults,
          options,
          currentMessageStartTime,
          await span.export()
        );
        if (finalMessageContent) {
          finalResults.push(finalMessageContent);
        }
        const lastMessage = currentMessages[currentMessages.length - 1];
        if (lastMessage?.message?.usage) {
          const outputTokens = getNumberProperty(lastMessage.message.usage, "output_tokens") || 0;
          accumulatedOutputTokens += outputTokens;
        }
        currentMessages.length = 0;
      }, "createLLMSpan");
      const wrappedGenerator = async function* () {
        try {
          const invocationTarget = thisArg === proxy || thisArg === void 0 ? defaultThis ?? thisArg : thisArg;
          const generator = withCurrent(
            span,
            () => Reflect.apply(target, invocationTarget, argArray)
          );
          for await (const message of generator) {
            const currentTime = getCurrentUnixTimestamp();
            const messageId = message.message?.id;
            if (messageId && messageId !== currentMessageId) {
              await createLLMSpan();
              currentMessageId = messageId;
              currentMessageStartTime = currentTime;
            }
            if (message.type === "assistant" && message.message?.usage) {
              currentMessages.push(message);
            }
            if (message.type === "result" && message.usage) {
              finalUsageMetrics = _extractUsageFromMessage(message);
              if (currentMessages.length > 0 && finalUsageMetrics.completion_tokens !== void 0) {
                const lastMessage = currentMessages[currentMessages.length - 1];
                if (lastMessage?.message?.usage) {
                  const adjustedTokens = finalUsageMetrics.completion_tokens - accumulatedOutputTokens;
                  if (adjustedTokens >= 0) {
                    lastMessage.message.usage.output_tokens = adjustedTokens;
                  }
                }
              }
              const result_metadata = {};
              if (message.num_turns !== void 0) {
                result_metadata.num_turns = message.num_turns;
              }
              if (message.session_id !== void 0) {
                result_metadata.session_id = message.session_id;
              }
              if (Object.keys(result_metadata).length > 0) {
                span.log({
                  metadata: result_metadata
                });
              }
            }
            yield message;
          }
          await createLLMSpan();
          span.log({
            output: finalResults.length > 0 ? finalResults[finalResults.length - 1] : void 0
          });
        } catch (error22) {
          span.log({
            error: error22 instanceof Error ? error22.message : String(error22)
          });
          throw error22;
        } finally {
          span.end();
        }
      }();
      return wrappedGenerator;
    }
  });
  return proxy;
}
__name(wrapClaudeAgentQuery, "wrapClaudeAgentQuery");
function wrapClaudeAgentTool(toolDef) {
  const originalHandler = toolDef.handler;
  const wrappedHandler = /* @__PURE__ */ __name((args, extra) => traced(
    async (span) => {
      span.log({
        input: args,
        metadata: {
          tool_name: toolDef.name,
          tool_description: toolDef.description
        }
      });
      const result = await originalHandler(args, extra);
      span.log({
        output: result
      });
      return result;
    },
    {
      name: `${toolDef.name}`,
      spanAttributes: {
        type: "tool"
        /* TOOL */
      }
    }
  ), "wrappedHandler");
  return {
    ...toolDef,
    handler: wrappedHandler
  };
}
__name(wrapClaudeAgentTool, "wrapClaudeAgentTool");
function _buildLLMInput(prompt, conversationHistory) {
  const promptMessage = typeof prompt === "string" ? { content: prompt, role: "user" } : void 0;
  const inputParts = [
    ...promptMessage ? [promptMessage] : [],
    ...conversationHistory
  ];
  return inputParts.length > 0 ? inputParts : void 0;
}
__name(_buildLLMInput, "_buildLLMInput");
function _extractUsageFromMessage(message) {
  const metrics2 = {};
  let usage;
  if (message.type === "assistant") {
    usage = message.message?.usage;
  } else if (message.type === "result") {
    usage = message.usage;
  }
  if (!usage || typeof usage !== "object") {
    return metrics2;
  }
  const inputTokens = getNumberProperty(usage, "input_tokens");
  if (inputTokens !== void 0) {
    metrics2.prompt_tokens = inputTokens;
  }
  const outputTokens = getNumberProperty(usage, "output_tokens");
  if (outputTokens !== void 0) {
    metrics2.completion_tokens = outputTokens;
  }
  const cacheReadTokens = getNumberProperty(usage, "cache_read_input_tokens") || 0;
  const cacheCreationTokens = getNumberProperty(usage, "cache_creation_input_tokens") || 0;
  if (cacheReadTokens > 0 || cacheCreationTokens > 0) {
    const cacheTokens = extractAnthropicCacheTokens(
      cacheReadTokens,
      cacheCreationTokens
    );
    Object.assign(metrics2, cacheTokens);
  }
  if (Object.keys(metrics2).length > 0) {
    Object.assign(metrics2, finalizeAnthropicTokens(metrics2));
  }
  return metrics2;
}
__name(_extractUsageFromMessage, "_extractUsageFromMessage");
async function _createLLMSpanForMessages(messages, prompt, conversationHistory, options, startTime, parentSpan) {
  if (messages.length === 0) return void 0;
  const lastMessage = messages[messages.length - 1];
  if (lastMessage.type !== "assistant" || !lastMessage.message?.usage) {
    return void 0;
  }
  const model = lastMessage.message.model || options.model;
  const usage = _extractUsageFromMessage(lastMessage);
  const input = _buildLLMInput(prompt, conversationHistory);
  const outputs = messages.map(
    (m) => m.message?.content && m.message?.role ? { content: m.message.content, role: m.message.role } : void 0
  ).filter((c) => c !== void 0);
  await traced(
    (llmSpan) => {
      llmSpan.log({
        input,
        output: outputs,
        metadata: model ? { model } : void 0,
        metrics: usage
      });
    },
    {
      name: "anthropic.messages.create",
      spanAttributes: {
        type: "llm"
        /* LLM */
      },
      startTime,
      parent: parentSpan
    }
  );
  return lastMessage.message?.content && lastMessage.message?.role ? { content: lastMessage.message.content, role: lastMessage.message.role } : void 0;
}
__name(_createLLMSpanForMessages, "_createLLMSpanForMessages");
function wrapClaudeAgentSDK(sdk) {
  const cache2 = /* @__PURE__ */ new Map();
  return new Proxy(sdk, {
    get(target, prop, receiver) {
      if (cache2.has(prop)) {
        return cache2.get(prop);
      }
      const value = Reflect.get(target, prop, receiver);
      if (prop === "query" && typeof value === "function") {
        const wrappedQuery = wrapClaudeAgentQuery(
          value,
          target
        );
        cache2.set(prop, wrappedQuery);
        return wrappedQuery;
      }
      if (prop === "tool" && typeof value === "function") {
        const toolFn = value;
        const wrappedToolFactory = new Proxy(toolFn, {
          apply(toolTarget, thisArg, argArray) {
            const invocationTarget = thisArg === receiver || thisArg === void 0 ? target : thisArg;
            const toolDef = Reflect.apply(
              toolTarget,
              invocationTarget,
              argArray
            );
            if (toolDef && typeof toolDef === "object" && "handler" in toolDef) {
              return wrapClaudeAgentTool(
                toolDef
              );
            }
            return toolDef;
          }
        });
        cache2.set(prop, wrappedToolFactory);
        return wrappedToolFactory;
      }
      if (typeof value === "function") {
        const bound = value.bind(target);
        cache2.set(prop, bound);
        return bound;
      }
      return value;
    }
  });
}
__name(wrapClaudeAgentSDK, "wrapClaudeAgentSDK");
var otelApi = null;
var otelSdk = null;
var OTEL_AVAILABLE2 = false;
try {
  otelApi = (init_esm(), __toCommonJS2(esm_exports));
  otelSdk = __require2("@opentelemetry/sdk-trace-base");
  OTEL_AVAILABLE2 = true;
} catch {
  console.warn(
    "OpenTelemetry packages are not installed. Install them with: npm install @opentelemetry/api @opentelemetry/sdk-trace-base @opentelemetry/exporter-trace-otlp-http @opentelemetry/resources @opentelemetry/semantic-conventions"
  );
  OTEL_AVAILABLE2 = false;
}
var FILTER_PREFIXES = [
  "gen_ai.",
  "braintrust.",
  "llm.",
  "ai.",
  "traceloop."
];
var AISpanProcessor = class _AISpanProcessor {
  static {
    __name(this, "_AISpanProcessor");
  }
  static checkOtelAvailable() {
    if (!OTEL_AVAILABLE2) {
      throw new Error(
        "OpenTelemetry packages are not installed. Install them with: npm install @opentelemetry/api @opentelemetry/sdk-trace-base @opentelemetry/exporter-trace-otlp-http @opentelemetry/resources @opentelemetry/semantic-conventions"
      );
    }
  }
  processor;
  customFilter;
  /**
   * Initialize the filter span processor.
   *
   * @param processor - The wrapped span processor that will receive filtered spans
   * @param customFilter - Optional function that takes a span and returns:
   *                      true to keep, false to drop,
   *                      null/undefined to not influence the decision
   */
  constructor(processor, customFilter) {
    _AISpanProcessor.checkOtelAvailable();
    this.processor = processor;
    this.customFilter = customFilter;
  }
  /**
   * Forward span start events to the inner processor.
   */
  onStart(span, parentContext) {
    this.processor.onStart(span, parentContext);
  }
  /**
   * Apply filtering logic and conditionally forward span end events.
   */
  onEnd(span) {
    const shouldKeep = this.shouldKeepFilteredSpan(span);
    if (shouldKeep) {
      this.processor.onEnd(span);
    }
  }
  /**
   * Shutdown the inner processor.
   */
  shutdown() {
    return this.processor.shutdown();
  }
  /**
   * Force flush the inner processor.
   */
  forceFlush() {
    return this.processor.forceFlush();
  }
  /**
   * Determine if a span should be kept based on filtering criteria.
   *
   * Keep spans if:
   * 1. It's a root span (no parent)
   * 2. Custom filter returns true/false (if provided)
   * 3. Span name starts with 'gen_ai.', 'braintrust.', 'llm.', 'ai.', or 'traceloop.'
   * 4. Any attribute name starts with those prefixes
   */
  shouldKeepFilteredSpan(span) {
    if (!span) {
      return false;
    }
    if (!span.parentSpanContext && !span.parentSpanId) {
      return true;
    }
    if (this.customFilter) {
      const customResult = this.customFilter(span);
      if (customResult === true) {
        return true;
      } else if (customResult === false) {
        return false;
      }
    }
    if (FILTER_PREFIXES.some((prefix) => span.name.startsWith(prefix))) {
      return true;
    }
    const attributes = span.attributes;
    if (attributes) {
      const attributeNames = Object.keys(attributes);
      if (attributeNames.some(
        (name) => FILTER_PREFIXES.some((prefix) => name.startsWith(prefix))
      )) {
        return true;
      }
    }
    return false;
  }
};
var BraintrustSpanProcessor = class _BraintrustSpanProcessor {
  static {
    __name(this, "_BraintrustSpanProcessor");
  }
  static checkOtelAvailable() {
    if (!OTEL_AVAILABLE2) {
      throw new Error(
        "OpenTelemetry packages are not installed. Install them with: npm install @opentelemetry/api @opentelemetry/sdk-trace-base @opentelemetry/exporter-trace-otlp-http @opentelemetry/resources @opentelemetry/semantic-conventions"
      );
    }
  }
  processor;
  aiSpanProcessor;
  constructor(options = {}) {
    _BraintrustSpanProcessor.checkOtelAvailable();
    const apiKey = options.apiKey || process.env.BRAINTRUST_API_KEY;
    if (!apiKey) {
      throw new Error(
        "Braintrust API key is required. Set BRAINTRUST_API_KEY environment variable or pass apiKey option."
      );
    }
    let apiUrl = options.apiUrl || process.env.BRAINTRUST_API_URL || "https://api.braintrust.dev";
    if (!apiUrl.endsWith("/")) {
      apiUrl += "/";
    }
    let parent = options.parent || process.env.BRAINTRUST_PARENT;
    if (!parent) {
      parent = "project_name:default-otel-project";
      console.info(
        `No parent specified, using default: ${parent}. Configure with BRAINTRUST_PARENT environment variable or parent parameter.`
      );
    }
    let exporter;
    try {
      const {
        OTLPTraceExporter
      } = __require2("@opentelemetry/exporter-trace-otlp-http");
      const headers = {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json",
        "x-bt-parent": parent,
        ...options.headers
      };
      const baseExporter = new OTLPTraceExporter({
        url: new URL("otel/v1/traces", apiUrl).href,
        headers
      });
      exporter = new Proxy(baseExporter, {
        get(target, prop, receiver) {
          if (prop === "export") {
            return function(spans, resultCallback) {
              const fixedSpans = spans.map((span) => {
                if (!span.instrumentationScope && span.instrumentationLibrary) {
                  span.instrumentationScope = span.instrumentationLibrary;
                }
                if (!span.parentSpanContext && span.parentSpanId) {
                  const spanContext = span.spanContext?.();
                  if (spanContext?.traceId) {
                    span.parentSpanContext = {
                      spanId: span.parentSpanId,
                      traceId: spanContext.traceId
                    };
                  }
                }
                return span;
              });
              return Reflect.apply(
                target.export,
                target,
                [fixedSpans, resultCallback]
              );
            };
          }
          return Reflect.get(target, prop, receiver);
        }
      });
    } catch (error22) {
      console.error(error22);
      throw new Error(
        "Failed to create OTLP exporter. Make sure @opentelemetry/exporter-trace-otlp-http is installed."
      );
    }
    if (!otelSdk) {
      throw new Error("OpenTelemetry SDK not available");
    }
    this.processor = new otelSdk.BatchSpanProcessor(exporter);
    if (options.filterAISpans === true) {
      this.aiSpanProcessor = new AISpanProcessor(
        this.processor,
        options.customFilter
      );
    } else {
      this.aiSpanProcessor = this.processor;
    }
  }
  onStart(span, parentContext) {
    try {
      let parentValue;
      if (otelApi && otelApi.context) {
        const currentContext = otelApi.context.active();
        const contextValue = currentContext.getValue?.("braintrust.parent");
        if (typeof contextValue === "string") {
          parentValue = contextValue;
        }
        if (!parentValue && parentContext) {
          const parentContextValue = typeof parentContext.getValue === "function" ? parentContext.getValue("braintrust.parent") : void 0;
          if (typeof parentContextValue === "string") {
            parentValue = parentContextValue;
          }
        }
        if (!parentValue && parentContext) {
          parentValue = this._getParentOtelBraintrustParent(parentContext);
        }
        if (parentValue && typeof span.setAttributes === "function") {
          span.setAttributes({ "braintrust.parent": parentValue });
        }
      }
    } catch {
    }
    this.aiSpanProcessor.onStart(span, parentContext);
  }
  _getParentOtelBraintrustParent(parentContext) {
    try {
      if (!otelApi || !otelApi.trace) {
        return void 0;
      }
      const currentSpan2 = typeof otelApi.trace.getSpan === "function" ? otelApi.trace.getSpan(parentContext) : void 0;
      if (currentSpan2 && typeof currentSpan2 === "object" && "attributes" in currentSpan2 && typeof currentSpan2.attributes === "object") {
        const attributes = currentSpan2.attributes;
        const parentAttr = attributes["braintrust.parent"];
        return typeof parentAttr === "string" ? parentAttr : void 0;
      }
      return void 0;
    } catch {
      return void 0;
    }
  }
  onEnd(span) {
    this.aiSpanProcessor.onEnd(span);
  }
  shutdown() {
    return this.aiSpanProcessor.shutdown();
  }
  forceFlush() {
    return this.aiSpanProcessor.forceFlush();
  }
};
var BraintrustExporter = class _BraintrustExporter {
  static {
    __name(this, "_BraintrustExporter");
  }
  static checkOtelAvailable() {
    if (!OTEL_AVAILABLE2) {
      throw new Error(
        "OpenTelemetry packages are not installed. Install them with: npm install @opentelemetry/api @opentelemetry/sdk-trace-base @opentelemetry/exporter-trace-otlp-http @opentelemetry/resources @opentelemetry/semantic-conventions"
      );
    }
  }
  processor;
  spans = [];
  callbacks = [];
  constructor(options = {}) {
    _BraintrustExporter.checkOtelAvailable();
    this.processor = new BraintrustSpanProcessor(options);
  }
  /**
   * Export spans to Braintrust by simulating span processor behavior.
   */
  export(spans, resultCallback) {
    try {
      spans.forEach((span) => {
        this.processor.onEnd(span);
      });
      this.processor.forceFlush().then(() => {
        resultCallback({ code: 0 });
      }).catch((error22) => {
        resultCallback({ code: 1, error: error22 });
      });
    } catch (error22) {
      resultCallback({ code: 1, error: error22 });
    }
  }
  /**
   * Shutdown the exporter.
   */
  shutdown() {
    return this.processor.shutdown();
  }
  /**
   * Force flush the exporter.
   */
  forceFlush() {
    return this.processor.forceFlush();
  }
};
init_generated_types();
var evalBodySchema = external_exports.object({
  name: external_exports.string(),
  parameters: external_exports.record(external_exports.string(), external_exports.unknown()).nullish(),
  data: RunEval.shape.data,
  scores: external_exports.array(
    external_exports.object({
      function_id: FunctionId,
      name: external_exports.string()
    })
  ).nullish(),
  experiment_name: external_exports.string().nullish(),
  project_id: external_exports.string().nullish(),
  parent: InvokeParent.optional(),
  stream: external_exports.boolean().optional()
});
var evalParametersSerializedSchema = external_exports.record(
  external_exports.string(),
  external_exports.union([
    external_exports.object({
      type: external_exports.literal("prompt"),
      default: PromptData.optional(),
      description: external_exports.string().optional()
    }),
    external_exports.object({
      type: external_exports.literal("data"),
      schema: external_exports.record(external_exports.unknown()),
      // JSON Schema
      default: external_exports.unknown().optional(),
      description: external_exports.string().optional()
    })
  ])
);
var evaluatorDefinitionSchema = external_exports.object({
  parameters: evalParametersSerializedSchema.optional()
});
var evaluatorDefinitionsSchema = external_exports.record(
  external_exports.string(),
  evaluatorDefinitionSchema
);
configureNode();

// node_modules/openai/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/client.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/internal/tslib.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
__name(__classPrivateFieldSet, "__classPrivateFieldSet");
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
__name(__classPrivateFieldGet, "__classPrivateFieldGet");

// node_modules/openai/internal/utils/uuid.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var uuid4 = /* @__PURE__ */ __name(function() {
  const { crypto: crypto3 } = globalThis;
  if (crypto3?.randomUUID) {
    uuid4 = crypto3.randomUUID.bind(crypto3);
    return crypto3.randomUUID();
  }
  const u8 = new Uint8Array(1);
  const randomByte = crypto3 ? () => crypto3.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
}, "uuid4");

// node_modules/openai/internal/utils/values.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/core/error.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/internal/errors.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function isAbortError(err) {
  return typeof err === "object" && err !== null && // Spec-compliant fetch implementations
  ("name" in err && err.name === "AbortError" || // Expo fetch
  "message" in err && String(err.message).includes("FetchRequestCanceledException"));
}
__name(isAbortError, "isAbortError");
var castToError = /* @__PURE__ */ __name((err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      if (Object.prototype.toString.call(err) === "[object Error]") {
        const error4 = new Error(err.message, err.cause ? { cause: err.cause } : {});
        if (err.stack)
          error4.stack = err.stack;
        if (err.cause && !error4.cause)
          error4.cause = err.cause;
        if (err.name)
          error4.name = err.name;
        return error4;
      }
    } catch {
    }
    try {
      return new Error(JSON.stringify(err));
    } catch {
    }
  }
  return new Error(err);
}, "castToError");

// node_modules/openai/core/error.mjs
var OpenAIError = class extends Error {
  static {
    __name(this, "OpenAIError");
  }
};
var APIError = class _APIError extends OpenAIError {
  static {
    __name(this, "APIError");
  }
  constructor(status, error4, message, headers) {
    super(`${_APIError.makeMessage(status, error4, message)}`);
    this.status = status;
    this.headers = headers;
    this.requestID = headers?.get("x-request-id");
    this.error = error4;
    const data = error4;
    this.code = data?.["code"];
    this.param = data?.["param"];
    this.type = data?.["type"];
  }
  static makeMessage(status, error4, message) {
    const msg = error4?.message ? typeof error4.message === "string" ? error4.message : JSON.stringify(error4.message) : error4 ? JSON.stringify(error4) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error4 = errorResponse?.["error"];
    if (status === 400) {
      return new BadRequestError(status, error4, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error4, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error4, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error4, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error4, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error4, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error4, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error4, message, headers);
    }
    return new _APIError(status, error4, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  static {
    __name(this, "APIUserAbortError");
  }
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError = class extends APIError {
  static {
    __name(this, "APIConnectionError");
  }
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  static {
    __name(this, "APIConnectionTimeoutError");
  }
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
  static {
    __name(this, "BadRequestError");
  }
};
var AuthenticationError = class extends APIError {
  static {
    __name(this, "AuthenticationError");
  }
};
var PermissionDeniedError = class extends APIError {
  static {
    __name(this, "PermissionDeniedError");
  }
};
var NotFoundError = class extends APIError {
  static {
    __name(this, "NotFoundError");
  }
};
var ConflictError = class extends APIError {
  static {
    __name(this, "ConflictError");
  }
};
var UnprocessableEntityError = class extends APIError {
  static {
    __name(this, "UnprocessableEntityError");
  }
};
var RateLimitError = class extends APIError {
  static {
    __name(this, "RateLimitError");
  }
};
var InternalServerError = class extends APIError {
  static {
    __name(this, "InternalServerError");
  }
};
var LengthFinishReasonError = class extends OpenAIError {
  static {
    __name(this, "LengthFinishReasonError");
  }
  constructor() {
    super(`Could not parse response content as the length limit was reached`);
  }
};
var ContentFilterFinishReasonError = class extends OpenAIError {
  static {
    __name(this, "ContentFilterFinishReasonError");
  }
  constructor() {
    super(`Could not parse response content as the request was rejected by the content filter`);
  }
};
var InvalidWebhookSignatureError = class extends Error {
  static {
    __name(this, "InvalidWebhookSignatureError");
  }
  constructor(message) {
    super(message);
  }
};

// node_modules/openai/internal/utils/values.mjs
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL = /* @__PURE__ */ __name((url) => {
  return startsWithSchemeRegexp.test(url);
}, "isAbsoluteURL");
var isArray3 = /* @__PURE__ */ __name((val) => (isArray3 = Array.isArray, isArray3(val)), "isArray");
var isReadonlyArray = isArray3;
function maybeObj(x) {
  if (typeof x !== "object") {
    return {};
  }
  return x ?? {};
}
__name(maybeObj, "maybeObj");
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
__name(isEmptyObj, "isEmptyObj");
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
__name(hasOwn, "hasOwn");
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}
__name(isObj, "isObj");
var validatePositiveInteger = /* @__PURE__ */ __name((name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
}, "validatePositiveInteger");
var safeJSON = /* @__PURE__ */ __name((text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
}, "safeJSON");

// node_modules/openai/internal/utils/sleep.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var sleep = /* @__PURE__ */ __name((ms) => new Promise((resolve) => setTimeout(resolve, ms)), "sleep");

// node_modules/openai/internal/detect-platform.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/version.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var VERSION2 = "6.4.0";

// node_modules/openai/internal/detect-platform.mjs
var isRunningInBrowser = /* @__PURE__ */ __name(() => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
}, "isRunningInBrowser");
function getDetectedPlatform() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
__name(getDetectedPlatform, "getDetectedPlatform");
var getPlatformProperties = /* @__PURE__ */ __name(() => {
  const detectedPlatform = getDetectedPlatform();
  if (detectedPlatform === "deno") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  }
  if (detectedPlatform === "node") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": normalizePlatform(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": normalizeArch(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION2,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
}, "getPlatformProperties");
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec("Cloudflare-Workers");
    if (match) {
      const major2 = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major2}.${minor}.${patch}` };
    }
  }
  return null;
}
__name(getBrowserInfo, "getBrowserInfo");
var normalizeArch = /* @__PURE__ */ __name((arch2) => {
  if (arch2 === "x32")
    return "x32";
  if (arch2 === "x86_64" || arch2 === "x64")
    return "x64";
  if (arch2 === "arm")
    return "arm";
  if (arch2 === "aarch64" || arch2 === "arm64")
    return "arm64";
  if (arch2)
    return `other:${arch2}`;
  return "unknown";
}, "normalizeArch");
var normalizePlatform = /* @__PURE__ */ __name((platform2) => {
  platform2 = platform2.toLowerCase();
  if (platform2.includes("ios"))
    return "iOS";
  if (platform2 === "android")
    return "Android";
  if (platform2 === "darwin")
    return "MacOS";
  if (platform2 === "win32")
    return "Windows";
  if (platform2 === "freebsd")
    return "FreeBSD";
  if (platform2 === "openbsd")
    return "OpenBSD";
  if (platform2 === "linux")
    return "Linux";
  if (platform2)
    return `Other:${platform2}`;
  return "Unknown";
}, "normalizePlatform");
var _platformHeaders;
var getPlatformHeaders = /* @__PURE__ */ __name(() => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
}, "getPlatformHeaders");

// node_modules/openai/internal/shims.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getDefaultFetch() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
__name(getDefaultFetch, "getDefaultFetch");
function makeReadableStream(...args) {
  const ReadableStream2 = globalThis.ReadableStream;
  if (typeof ReadableStream2 === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream2(...args);
}
__name(makeReadableStream, "makeReadableStream");
function ReadableStreamFrom(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream({
    start() {
    },
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      await iter.return?.();
    }
  });
}
__name(ReadableStreamFrom, "ReadableStreamFrom");
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
__name(ReadableStreamToAsyncIterable, "ReadableStreamToAsyncIterable");
async function CancelReadableStream(stream) {
  if (stream === null || typeof stream !== "object")
    return;
  if (stream[Symbol.asyncIterator]) {
    await stream[Symbol.asyncIterator]().return?.();
    return;
  }
  const reader = stream.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}
__name(CancelReadableStream, "CancelReadableStream");

// node_modules/openai/internal/request-options.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FallbackEncoder = /* @__PURE__ */ __name(({ headers, body }) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(body)
  };
}, "FallbackEncoder");

// node_modules/openai/internal/qs/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/internal/qs/formats.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var default_format = "RFC3986";
var default_formatter = /* @__PURE__ */ __name((v) => String(v), "default_formatter");
var formatters = {
  RFC1738: /* @__PURE__ */ __name((v) => String(v).replace(/%20/g, "+"), "RFC1738"),
  RFC3986: default_formatter
};
var RFC1738 = "RFC1738";

// node_modules/openai/internal/qs/stringify.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/internal/qs/utils.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var has = /* @__PURE__ */ __name((obj, key) => (has = Object.hasOwn ?? Function.prototype.call.bind(Object.prototype.hasOwnProperty), has(obj, key)), "has");
var hex_table = /* @__PURE__ */ (() => {
  const array = [];
  for (let i = 0; i < 256; ++i) {
    array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array;
})();
var limit = 1024;
var encode = /* @__PURE__ */ __name((str2, _defaultEncoder, charset, _kind, format) => {
  if (str2.length === 0) {
    return str2;
  }
  let string = str2;
  if (typeof str2 === "symbol") {
    string = Symbol.prototype.toString.call(str2);
  } else if (typeof str2 !== "string") {
    string = String(str2);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j = 0; j < string.length; j += limit) {
    const segment = string.length >= limit ? string.slice(j, j + limit) : string;
    const arr = [];
    for (let i = 0; i < segment.length; ++i) {
      let c = segment.charCodeAt(i);
      if (c === 45 || // -
      c === 46 || // .
      c === 95 || // _
      c === 126 || // ~
      c >= 48 && c <= 57 || // 0-9
      c >= 65 && c <= 90 || // a-z
      c >= 97 && c <= 122 || // A-Z
      format === RFC1738 && (c === 40 || c === 41)) {
        arr[arr.length] = segment.charAt(i);
        continue;
      }
      if (c < 128) {
        arr[arr.length] = hex_table[c];
        continue;
      }
      if (c < 2048) {
        arr[arr.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        arr[arr.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
      arr[arr.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
    }
    out += arr.join("");
  }
  return out;
}, "encode");
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
__name(is_buffer, "is_buffer");
function maybe_map(val, fn) {
  if (isArray3(val)) {
    const mapped = [];
    for (let i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
}
__name(maybe_map, "maybe_map");

// node_modules/openai/internal/qs/stringify.mjs
var array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
var push_to_array = /* @__PURE__ */ __name(function(arr, value_or_array) {
  Array.prototype.push.apply(arr, isArray3(value_or_array) ? value_or_array : [value_or_array]);
}, "push_to_array");
var toISOString;
var defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode,
  encodeValuesOnly: false,
  format: default_format,
  formatter: default_formatter,
  /** @deprecated */
  indices: false,
  serializeDate(date) {
    return (toISOString ?? (toISOString = Function.prototype.call.bind(Date.prototype.toISOString)))(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
__name(is_non_nullish_primitive, "is_non_nullish_primitive");
var sentinel = {};
function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj = object;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
    const pos = tmp_sc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter2 === "function") {
    obj = filter2(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate?.(obj);
  } else if (generateArrayPrefix === "comma" && isArray3(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate?.(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? (
        // @ts-expect-error
        encoder(prefix, defaults.encoder, charset, "key", format)
      ) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder) {
      const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
      return [
        formatter?.(key_value) + "=" + // @ts-expect-error
        formatter?.(encoder(obj, defaults.encoder, charset, "value", format))
      ];
    }
    return [formatter?.(prefix) + "=" + formatter?.(String(obj))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && isArray3(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = maybe_map(obj, encoder);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray3(filter2)) {
    obj_keys = filter2;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort ? keys.sort(sort) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && isArray3(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && isArray3(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j = 0; j < obj_keys.length; ++j) {
    const key = obj_keys[j];
    const value = (
      // @ts-ignore
      typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
    );
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = isArray3(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object, step);
    const valueSideChannel = /* @__PURE__ */ new WeakMap();
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(
      value,
      key_prefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      // @ts-ignore
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray3(obj) ? null : encoder,
      filter2,
      sort,
      allowDots,
      serializeDate,
      format,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
}
__name(inner_stringify, "inner_stringify");
function normalize_stringify_options(opts = defaults) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  const formatter = formatters[format];
  let filter2 = defaults.filter;
  if (typeof opts.filter === "function" || isArray3(opts.filter)) {
    filter2 = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
    // @ts-ignore
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter: filter2,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
    // @ts-ignore
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
}
__name(normalize_stringify_options, "normalize_stringify_options");
function stringify2(object, opts = {}) {
  let obj = object;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter2;
  if (typeof options.filter === "function") {
    filter2 = options.filter;
    obj = filter2("", obj);
  } else if (isArray3(options.filter)) {
    filter2 = options.filter;
    obj_keys = filter2;
  }
  const keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = /* @__PURE__ */ new WeakMap();
  for (let i = 0; i < obj_keys.length; ++i) {
    const key = obj_keys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(
      obj[key],
      key,
      // @ts-expect-error
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel
    ));
  }
  const joined = keys.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}
__name(stringify2, "stringify");

// node_modules/openai/core/pagination.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/internal/parse.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/core/streaming.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/internal/decoders/line.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/internal/utils/bytes.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function concatBytes(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}
__name(concatBytes, "concatBytes");
var encodeUTF8_;
function encodeUTF8(str2) {
  let encoder;
  return (encodeUTF8_ ?? (encoder = new globalThis.TextEncoder(), encodeUTF8_ = encoder.encode.bind(encoder)))(str2);
}
__name(encodeUTF8, "encodeUTF8");
var decodeUTF8_;
function decodeUTF8(bytes) {
  let decoder;
  return (decodeUTF8_ ?? (decoder = new globalThis.TextDecoder(), decodeUTF8_ = decoder.decode.bind(decoder)))(bytes);
}
__name(decodeUTF8, "decodeUTF8");

// node_modules/openai/internal/decoders/line.mjs
var _LineDecoder_buffer;
var _LineDecoder_carriageReturnIndex;
var LineDecoder = class {
  static {
    __name(this, "LineDecoder");
  }
  constructor() {
    _LineDecoder_buffer.set(this, void 0);
    _LineDecoder_carriageReturnIndex.set(this, void 0);
    __classPrivateFieldSet(this, _LineDecoder_buffer, new Uint8Array(), "f");
    __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    __classPrivateFieldSet(this, _LineDecoder_buffer, concatBytes([__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), binaryChunk]), "f");
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex(__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") == null) {
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
        continue;
      }
      if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
        lines.push(decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
        __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f")), "f");
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
        continue;
      }
      const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, endIndex));
      lines.push(line);
      __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(patternIndex.index), "f");
      __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
    }
    return lines;
  }
  flush() {
    if (!__classPrivateFieldGet(this, _LineDecoder_buffer, "f").length) {
      return [];
    }
    return this.decode("\n");
  }
};
_LineDecoder_buffer = /* @__PURE__ */ new WeakMap(), _LineDecoder_carriageReturnIndex = /* @__PURE__ */ new WeakMap();
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i = startIndex ?? 0; i < buffer.length; i++) {
    if (buffer[i] === newline) {
      return { preceding: i, index: i + 1, carriage: false };
    }
    if (buffer[i] === carriage) {
      return { preceding: i, index: i + 1, carriage: true };
    }
  }
  return null;
}
__name(findNewlineIndex, "findNewlineIndex");
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 1; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}
__name(findDoubleNewlineIndex, "findDoubleNewlineIndex");

// node_modules/openai/internal/utils/log.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var levelNumbers = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
};
var parseLogLevel = /* @__PURE__ */ __name((maybeLevel, sourceName, client) => {
  if (!maybeLevel) {
    return void 0;
  }
  if (hasOwn(levelNumbers, maybeLevel)) {
    return maybeLevel;
  }
  loggerFor(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);
  return void 0;
}, "parseLogLevel");
function noop() {
}
__name(noop, "noop");
function makeLogFn(fnLevel, logger, logLevel) {
  if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {
    return noop;
  } else {
    return logger[fnLevel].bind(logger);
  }
}
__name(makeLogFn, "makeLogFn");
var noopLogger = {
  error: noop,
  warn: noop,
  info: noop,
  debug: noop
};
var cachedLoggers = /* @__PURE__ */ new WeakMap();
function loggerFor(client) {
  const logger = client.logger;
  const logLevel = client.logLevel ?? "off";
  if (!logger) {
    return noopLogger;
  }
  const cachedLogger = cachedLoggers.get(logger);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn("error", logger, logLevel),
    warn: makeLogFn("warn", logger, logLevel),
    info: makeLogFn("info", logger, logLevel),
    debug: makeLogFn("debug", logger, logLevel)
  };
  cachedLoggers.set(logger, [logLevel, levelLogger]);
  return levelLogger;
}
__name(loggerFor, "loggerFor");
var formatRequestDetails = /* @__PURE__ */ __name((details) => {
  if (details.options) {
    details.options = { ...details.options };
    delete details.options["headers"];
  }
  if (details.headers) {
    details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
      name,
      name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
    ]));
  }
  if ("retryOfRequestLogID" in details) {
    if (details.retryOfRequestLogID) {
      details.retryOf = details.retryOfRequestLogID;
    }
    delete details.retryOfRequestLogID;
  }
  return details;
}, "formatRequestDetails");

// node_modules/openai/core/streaming.mjs
var _Stream_client;
var Stream = class _Stream {
  static {
    __name(this, "Stream");
  }
  constructor(iterator, controller, client) {
    this.iterator = iterator;
    _Stream_client.set(this, void 0);
    this.controller = controller;
    __classPrivateFieldSet(this, _Stream_client, client, "f");
  }
  static fromSSEResponse(response, controller, client) {
    let consumed = false;
    const logger = client ? loggerFor(client) : console;
    async function* iterator() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null || !sse.event.startsWith("thread.")) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              logger.error(`Could not parse message into JSON:`, sse.data);
              logger.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(void 0, data.error, void 0, response.headers);
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (sse.event == "error") {
              throw new APIError(void 0, data.error, data.message, void 0);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e) {
        if (isAbortError(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    __name(iterator, "iterator");
    return new _Stream(iterator, controller, client);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller, client) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = ReadableStreamToAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    __name(iterLines, "iterLines");
    async function* iterator() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (isAbortError(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    __name(iterator, "iterator");
    return new _Stream(iterator, controller, client);
  }
  [(_Stream_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = /* @__PURE__ */ __name((queue2) => {
      return {
        next: /* @__PURE__ */ __name(() => {
          if (queue2.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue2.shift();
        }, "next")
      };
    }, "teeIterator");
    return [
      new _Stream(() => teeIterator(left), this.controller, __classPrivateFieldGet(this, _Stream_client, "f")),
      new _Stream(() => teeIterator(right), this.controller, __classPrivateFieldGet(this, _Stream_client, "f"))
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self = this;
    let iter;
    return makeReadableStream({
      async start() {
        iter = self[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encodeUTF8(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      }
    });
  }
};
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
      throw new OpenAIError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
    }
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
__name(_iterSSEMessages, "_iterSSEMessages");
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
__name(iterSSEChunks, "iterSSEChunks");
var SSEDecoder = class {
  static {
    __name(this, "SSEDecoder");
  }
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}
__name(partition, "partition");

// node_modules/openai/internal/parse.mjs
async function defaultParseResponse(client, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    if (props.options.stream) {
      loggerFor(client).debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller, client);
      }
      return Stream.fromSSEResponse(response, props.controller, client);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = contentType?.split(";")[0]?.trim();
    const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
    if (isJSON) {
      const json = await response.json();
      return addRequestID(json, response);
    }
    const text = await response.text();
    return text;
  })();
  loggerFor(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}
__name(defaultParseResponse, "defaultParseResponse");
function addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("x-request-id"),
    enumerable: false
  });
}
__name(addRequestID, "addRequestID");

// node_modules/openai/core/api-promise.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var _APIPromise_client;
var APIPromise = class _APIPromise extends Promise {
  static {
    __name(this, "APIPromise");
  }
  constructor(client, responsePromise, parseResponse2 = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse2;
    _APIPromise_client.set(this, void 0);
    __classPrivateFieldSet(this, _APIPromise_client, client, "f");
  }
  _thenUnwrap(transform) {
    return new _APIPromise(__classPrivateFieldGet(this, _APIPromise_client, "f"), this.responsePromise, async (client, props) => addRequestID(transform(await this.parseResponse(client, props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("x-request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(__classPrivateFieldGet(this, _APIPromise_client, "f"), data));
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
_APIPromise_client = /* @__PURE__ */ new WeakMap();

// node_modules/openai/core/pagination.mjs
var _AbstractPage_client;
var AbstractPage = class {
  static {
    __name(this, "AbstractPage");
  }
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageRequestOptions() != null;
  }
  async getNextPage() {
    const nextOptions = this.nextPageRequestOptions();
    if (!nextOptions) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  static {
    __name(this, "PagePromise");
  }
  constructor(client, request, Page2) {
    super(client, request, async (client2, props) => new Page2(client2, props.response, await defaultParseResponse(client2, props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var Page = class extends AbstractPage {
  static {
    __name(this, "Page");
  }
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  nextPageRequestOptions() {
    return null;
  }
};
var CursorPage = class extends AbstractPage {
  static {
    __name(this, "CursorPage");
  }
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const data = this.getPaginatedItems();
    const id = data[data.length - 1]?.id;
    if (!id) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        after: id
      }
    };
  }
};
var ConversationCursorPage = class extends AbstractPage {
  static {
    __name(this, "ConversationCursorPage");
  }
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.last_id = body.last_id || "";
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const cursor = this.last_id;
    if (!cursor) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        after: cursor
      }
    };
  }
};

// node_modules/openai/core/uploads.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/internal/to-file.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/internal/uploads.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var checkFileSupport = /* @__PURE__ */ __name(() => {
  if (typeof File === "undefined") {
    const { process: process2 } = globalThis;
    const isOldNode = typeof process2?.versions?.node === "string" && parseInt(process2.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
}, "checkFileSupport");
function makeFile(fileBits, fileName, options) {
  checkFileSupport();
  return new File(fileBits, fileName ?? "unknown_file", options);
}
__name(makeFile, "makeFile");
function getName(value) {
  return (typeof value === "object" && value !== null && ("name" in value && value.name && String(value.name) || "url" in value && value.url && String(value.url) || "filename" in value && value.filename && String(value.filename) || "path" in value && value.path && String(value.path)) || "").split(/[\\/]/).pop() || void 0;
}
__name(getName, "getName");
var isAsyncIterable2 = /* @__PURE__ */ __name((value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function", "isAsyncIterable");
var maybeMultipartFormRequestOptions = /* @__PURE__ */ __name(async (opts, fetch2) => {
  if (!hasUploadableValue(opts.body))
    return opts;
  return { ...opts, body: await createForm(opts.body, fetch2) };
}, "maybeMultipartFormRequestOptions");
var multipartFormRequestOptions = /* @__PURE__ */ __name(async (opts, fetch2) => {
  return { ...opts, body: await createForm(opts.body, fetch2) };
}, "multipartFormRequestOptions");
var supportsFormDataMap = /* @__PURE__ */ new WeakMap();
function supportsFormData(fetchObject) {
  const fetch2 = typeof fetchObject === "function" ? fetchObject : fetchObject.fetch;
  const cached = supportsFormDataMap.get(fetch2);
  if (cached)
    return cached;
  const promise = (async () => {
    try {
      const FetchResponse = "Response" in fetch2 ? fetch2.Response : (await fetch2("data:,")).constructor;
      const data = new FormData();
      if (data.toString() === await new FetchResponse(data).text()) {
        return false;
      }
      return true;
    } catch {
      return true;
    }
  })();
  supportsFormDataMap.set(fetch2, promise);
  return promise;
}
__name(supportsFormData, "supportsFormData");
var createForm = /* @__PURE__ */ __name(async (body, fetch2) => {
  if (!await supportsFormData(fetch2)) {
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  }
  const form = new FormData();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
}, "createForm");
var isNamedBlob = /* @__PURE__ */ __name((value) => value instanceof Blob && "name" in value, "isNamedBlob");
var isUploadable = /* @__PURE__ */ __name((value) => typeof value === "object" && value !== null && (value instanceof Response || isAsyncIterable2(value) || isNamedBlob(value)), "isUploadable");
var hasUploadableValue = /* @__PURE__ */ __name((value) => {
  if (isUploadable(value))
    return true;
  if (Array.isArray(value))
    return value.some(hasUploadableValue);
  if (value && typeof value === "object") {
    for (const k in value) {
      if (hasUploadableValue(value[k]))
        return true;
    }
  }
  return false;
}, "hasUploadableValue");
var addFormValue = /* @__PURE__ */ __name(async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (value instanceof Response) {
    form.append(key, makeFile([await value.blob()], getName(value)));
  } else if (isAsyncIterable2(value)) {
    form.append(key, makeFile([await new Response(ReadableStreamFrom(value)).blob()], getName(value)));
  } else if (isNamedBlob(value)) {
    form.append(key, value, getName(value));
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
}, "addFormValue");

// node_modules/openai/internal/to-file.mjs
var isBlobLike = /* @__PURE__ */ __name((value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function", "isBlobLike");
var isFileLike = /* @__PURE__ */ __name((value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value), "isFileLike");
var isResponseLike = /* @__PURE__ */ __name((value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function", "isResponseLike");
async function toFile(value, name, options) {
  checkFileSupport();
  value = await value;
  if (isFileLike(value)) {
    if (value instanceof File) {
      return value;
    }
    return makeFile([await value.arrayBuffer()], value.name);
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile(await getBytes(blob), name, options);
  }
  const parts = await getBytes(value);
  name || (name = getName(value));
  if (!options?.type) {
    const type = parts.find((part) => typeof part === "object" && "type" in part && part.type);
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return makeFile(parts, name, options);
}
__name(toFile, "toFile");
async function getBytes(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable2(value)) {
    for await (const chunk of value) {
      parts.push(...await getBytes(chunk));
    }
  } else {
    const constructor = value?.constructor?.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError(value)}`);
  }
  return parts;
}
__name(getBytes, "getBytes");
function propsForError(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p) => `"${p}"`).join(", ")}]`;
}
__name(propsForError, "propsForError");

// node_modules/openai/resources/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/chat/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/chat/chat.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/core/resource.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var APIResource = class {
  static {
    __name(this, "APIResource");
  }
  constructor(client) {
    this._client = client;
  }
};

// node_modules/openai/resources/chat/completions/completions.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/chat/completions/messages.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/internal/utils/path.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function encodeURIPath(str2) {
  return str2.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
__name(encodeURIPath, "encodeURIPath");
var EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
var createPathTagFunction = /* @__PURE__ */ __name((pathEncoder = encodeURIPath) => /* @__PURE__ */ __name(function path4(statics, ...params) {
  if (statics.length === 1)
    return statics[0];
  let postPath = false;
  const invalidSegments = [];
  const path5 = statics.reduce((previousValue, currentValue, index) => {
    if (/[?#]/.test(currentValue)) {
      postPath = true;
    }
    const value = params[index];
    let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
    if (index !== params.length && (value == null || typeof value === "object" && // handle values from other realms
    value.toString === Object.getPrototypeOf(Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY) ?? EMPTY)?.toString)) {
      encoded = value + "";
      invalidSegments.push({
        start: previousValue.length + currentValue.length,
        length: encoded.length,
        error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
      });
    }
    return previousValue + currentValue + (index === params.length ? "" : encoded);
  }, "");
  const pathOnly = path5.split(/[?#]/, 1)[0];
  const invalidSegmentPattern = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;
  let match;
  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
    invalidSegments.push({
      start: match.index,
      length: match[0].length,
      error: `Value "${match[0]}" can't be safely passed as a path parameter`
    });
  }
  invalidSegments.sort((a, b) => a.start - b.start);
  if (invalidSegments.length > 0) {
    let lastEnd = 0;
    const underline = invalidSegments.reduce((acc, segment) => {
      const spaces = " ".repeat(segment.start - lastEnd);
      const arrows = "^".repeat(segment.length);
      lastEnd = segment.start + segment.length;
      return acc + spaces + arrows;
    }, "");
    throw new OpenAIError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e) => e.error).join("\n")}
${path5}
${underline}`);
  }
  return path5;
}, "path"), "createPathTagFunction");
var path3 = /* @__PURE__ */ createPathTagFunction(encodeURIPath);

// node_modules/openai/resources/chat/completions/messages.mjs
var Messages = class extends APIResource {
  static {
    __name(this, "Messages");
  }
  /**
   * Get the messages in a stored chat completion. Only Chat Completions that have
   * been created with the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletionStoreMessage of client.chat.completions.messages.list(
   *   'completion_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(completionID, query = {}, options) {
    return this._client.getAPIList(path3`/chat/completions/${completionID}/messages`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/lib/ChatCompletionRunner.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/error.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/lib/parser.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function isChatCompletionFunctionTool(tool) {
  return tool !== void 0 && "function" in tool && tool.function !== void 0;
}
__name(isChatCompletionFunctionTool, "isChatCompletionFunctionTool");
function isAutoParsableResponseFormat(response_format) {
  return response_format?.["$brand"] === "auto-parseable-response-format";
}
__name(isAutoParsableResponseFormat, "isAutoParsableResponseFormat");
function isAutoParsableTool(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
__name(isAutoParsableTool, "isAutoParsableTool");
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => {
        assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
        return {
          ...choice,
          message: {
            ...choice.message,
            parsed: null,
            ...choice.message.tool_calls ? {
              tool_calls: choice.message.tool_calls
            } : void 0
          }
        };
      })
    };
  }
  return parseChatCompletion(completion, params);
}
__name(maybeParseChatCompletion, "maybeParseChatCompletion");
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError();
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError();
    }
    assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
    return {
      ...choice,
      message: {
        ...choice.message,
        ...choice.message.tool_calls ? {
          tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)) ?? void 0
        } : void 0,
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
__name(parseChatCompletion, "parseChatCompletion");
function parseResponseFormat(params, content) {
  if (params.response_format?.type !== "json_schema") {
    return null;
  }
  if (params.response_format?.type === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
__name(parseResponseFormat, "parseResponseFormat");
function parseToolCall(params, toolCall) {
  const inputTool = params.tools?.find((inputTool2) => isChatCompletionFunctionTool(inputTool2) && inputTool2.function?.name === toolCall.function.name);
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
__name(parseToolCall, "parseToolCall");
function shouldParseToolCall(params, toolCall) {
  if (!params || !("tools" in params) || !params.tools) {
    return false;
  }
  const inputTool = params.tools?.find((inputTool2) => isChatCompletionFunctionTool(inputTool2) && inputTool2.function?.name === toolCall.function.name);
  return isChatCompletionFunctionTool(inputTool) && (isAutoParsableTool(inputTool) || inputTool?.function.strict || false);
}
__name(shouldParseToolCall, "shouldParseToolCall");
function hasAutoParseableInput(params) {
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return params.tools?.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true) ?? false;
}
__name(hasAutoParseableInput, "hasAutoParseableInput");
function assertToolCallsAreChatCompletionFunctionToolCalls(toolCalls) {
  for (const toolCall of toolCalls || []) {
    if (toolCall.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool calls are supported; Received \`${toolCall.type}\``);
    }
  }
}
__name(assertToolCallsAreChatCompletionFunctionToolCalls, "assertToolCallsAreChatCompletionFunctionToolCalls");
function validateInputTools(tools) {
  for (const tool of tools ?? []) {
    if (tool.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
    }
    if (tool.function.strict !== true) {
      throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}
__name(validateInputTools, "validateInputTools");

// node_modules/openai/lib/chatCompletionUtils.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isAssistantMessage = /* @__PURE__ */ __name((message) => {
  return message?.role === "assistant";
}, "isAssistantMessage");
var isToolMessage = /* @__PURE__ */ __name((message) => {
  return message?.role === "tool";
}, "isToolMessage");

// node_modules/openai/lib/EventStream.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var _EventStream_instances;
var _EventStream_connectedPromise;
var _EventStream_resolveConnectedPromise;
var _EventStream_rejectConnectedPromise;
var _EventStream_endPromise;
var _EventStream_resolveEndPromise;
var _EventStream_rejectEndPromise;
var _EventStream_listeners;
var _EventStream_ended;
var _EventStream_errored;
var _EventStream_aborted;
var _EventStream_catchingPromiseCreated;
var _EventStream_handleError;
var EventStream = class {
  static {
    __name(this, "EventStream");
  }
  constructor() {
    _EventStream_instances.add(this);
    this.controller = new AbortController();
    _EventStream_connectedPromise.set(this, void 0);
    _EventStream_resolveConnectedPromise.set(this, () => {
    });
    _EventStream_rejectConnectedPromise.set(this, () => {
    });
    _EventStream_endPromise.set(this, void 0);
    _EventStream_resolveEndPromise.set(this, () => {
    });
    _EventStream_rejectEndPromise.set(this, () => {
    });
    _EventStream_listeners.set(this, {});
    _EventStream_ended.set(this, false);
    _EventStream_errored.set(this, false);
    _EventStream_aborted.set(this, false);
    _EventStream_catchingPromiseCreated.set(this, false);
    __classPrivateFieldSet(this, _EventStream_connectedPromise, new Promise((resolve, reject2) => {
      __classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject2, "f");
    }), "f");
    __classPrivateFieldSet(this, _EventStream_endPromise, new Promise((resolve, reject2) => {
      __classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject2, "f");
    }), "f");
    __classPrivateFieldGet(this, _EventStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet(this, _EventStream_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
    }, 0);
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet(this, _EventStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet(this, _EventStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet(this, _EventStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners2 = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
    listeners2.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners2 = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
    if (!listeners2)
      return this;
    const index = listeners2.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners2.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners2 = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
    listeners2.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject2) => {
      __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject2);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet(this, _EventStream_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet(this, _EventStream_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet(this, _EventStream_ended, true, "f");
      __classPrivateFieldGet(this, _EventStream_resolveEndPromise, "f").call(this);
    }
    const listeners2 = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
    if (listeners2) {
      __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = listeners2.filter((l) => !l.once);
      listeners2.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error4 = args[0];
      if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !listeners2?.length) {
        Promise.reject(error4);
      }
      __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error4);
      __classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error4);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error4 = args[0];
      if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !listeners2?.length) {
        Promise.reject(error4);
      }
      __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error4);
      __classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error4);
      this._emit("end");
    }
  }
  _emitFinal() {
  }
};
_EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = /* @__PURE__ */ __name(function _EventStream_handleError2(error4) {
  __classPrivateFieldSet(this, _EventStream_errored, true, "f");
  if (error4 instanceof Error && error4.name === "AbortError") {
    error4 = new APIUserAbortError();
  }
  if (error4 instanceof APIUserAbortError) {
    __classPrivateFieldSet(this, _EventStream_aborted, true, "f");
    return this._emit("abort", error4);
  }
  if (error4 instanceof OpenAIError) {
    return this._emit("error", error4);
  }
  if (error4 instanceof Error) {
    const openAIError = new OpenAIError(error4.message);
    openAIError.cause = error4;
    return this._emit("error", openAIError);
  }
  return this._emit("error", new OpenAIError(String(error4)));
}, "_EventStream_handleError");

// node_modules/openai/lib/RunnableFunction.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}
__name(isRunnableFunctionWithParse, "isRunnableFunctionWithParse");

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var _AbstractChatCompletionRunner_instances;
var _AbstractChatCompletionRunner_getFinalContent;
var _AbstractChatCompletionRunner_getFinalMessage;
var _AbstractChatCompletionRunner_getFinalFunctionToolCall;
var _AbstractChatCompletionRunner_getFinalFunctionToolCallResult;
var _AbstractChatCompletionRunner_calculateTotalUsage;
var _AbstractChatCompletionRunner_validateParams;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
var DEFAULT_MAX_CHAT_COMPLETIONS = 10;
var AbstractChatCompletionRunner = class extends EventStream {
  static {
    __name(this, "AbstractChatCompletionRunner");
  }
  constructor() {
    super(...arguments);
    _AbstractChatCompletionRunner_instances.add(this);
    this._chatCompletions = [];
    this.messages = [];
  }
  _addChatCompletion(chatCompletion) {
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = chatCompletion.choices[0]?.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit2 = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit2) {
      this._emit("message", message);
      if (isToolMessage(message) && message.content) {
        this._emit("functionToolCallResult", message.content);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionToolCall", tool_call.function);
          }
        }
      }
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionToolCall() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
  }
  async finalFunctionToolCallResult() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionToolCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionToolCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(client, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
  }
  async _runChatCompletion(client, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(client, params, options);
  }
  async _runTools(client, params, options) {
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice.type === "function" && tool_choice?.function?.name;
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const inputTools = params.tools.map((tool) => {
      if (isAutoParsableTool(tool)) {
        if (!tool.$callback) {
          throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
        }
        return {
          type: "function",
          function: {
            function: tool.$callback,
            name: tool.function.name,
            description: tool.function.description || "",
            parameters: tool.function.parameters,
            parse: tool.$parseRaw,
            strict: true
          }
        };
      }
      return tool;
    });
    const functionsByName = {};
    for (const f of inputTools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
      type: "function",
      function: {
        name: t.function.name || t.function.function.name,
        parameters: t.function.parameters,
        description: t.function.description,
        strict: t.function.strict
      }
    } : t) : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message = chatCompletion.choices[0]?.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.tool_calls?.length) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error4) {
          const content2 = error4 instanceof Error ? error4.message : String(error4);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
};
_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = /* @__PURE__ */ __name(function _AbstractChatCompletionRunner_getFinalContent2() {
  return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
}, "_AbstractChatCompletionRunner_getFinalContent"), _AbstractChatCompletionRunner_getFinalMessage = /* @__PURE__ */ __name(function _AbstractChatCompletionRunner_getFinalMessage2() {
  let i = this.messages.length;
  while (i-- > 0) {
    const message = this.messages[i];
    if (isAssistantMessage(message)) {
      const ret = {
        ...message,
        content: message.content ?? null,
        refusal: message.refusal ?? null
      };
      return ret;
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, "_AbstractChatCompletionRunner_getFinalMessage"), _AbstractChatCompletionRunner_getFinalFunctionToolCall = /* @__PURE__ */ __name(function _AbstractChatCompletionRunner_getFinalFunctionToolCall2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isAssistantMessage(message) && message?.tool_calls?.length) {
      return message.tool_calls.filter((x) => x.type === "function").at(-1)?.function;
    }
  }
  return;
}, "_AbstractChatCompletionRunner_getFinalFunctionToolCall"), _AbstractChatCompletionRunner_getFinalFunctionToolCallResult = /* @__PURE__ */ __name(function _AbstractChatCompletionRunner_getFinalFunctionToolCallResult2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => x.role === "assistant" && x.tool_calls?.some((y) => y.type === "function" && y.id === message.tool_call_id))) {
      return message.content;
    }
  }
  return;
}, "_AbstractChatCompletionRunner_getFinalFunctionToolCallResult"), _AbstractChatCompletionRunner_calculateTotalUsage = /* @__PURE__ */ __name(function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, "_AbstractChatCompletionRunner_calculateTotalUsage"), _AbstractChatCompletionRunner_validateParams = /* @__PURE__ */ __name(function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, "_AbstractChatCompletionRunner_validateParams"), _AbstractChatCompletionRunner_stringifyFunctionCallResult = /* @__PURE__ */ __name(function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
}, "_AbstractChatCompletionRunner_stringifyFunctionCallResult");

// node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner = class _ChatCompletionRunner extends AbstractChatCompletionRunner {
  static {
    __name(this, "ChatCompletionRunner");
  }
  static runTools(client, params, options) {
    const runner = new _ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
  _addMessage(message, emit2 = true) {
    super._addMessage(message, emit2);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
};

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/lib/ChatCompletionStream.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/_vendor/partial-json-parser/parser.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var STR = 1;
var NUM = 2;
var ARR = 4;
var OBJ = 8;
var NULL2 = 16;
var BOOL = 32;
var NAN = 64;
var INFINITY = 128;
var MINUS_INFINITY = 256;
var INF = INFINITY | MINUS_INFINITY;
var SPECIAL = NULL2 | BOOL | INF | NAN;
var ATOM = STR | NUM | SPECIAL;
var COLLECTION = ARR | OBJ;
var ALL = ATOM | COLLECTION;
var Allow = {
  STR,
  NUM,
  ARR,
  OBJ,
  NULL: NULL2,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL
};
var PartialJSON = class extends Error {
  static {
    __name(this, "PartialJSON");
  }
};
var MalformedJSON = class extends Error {
  static {
    __name(this, "MalformedJSON");
  }
};
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
__name(parseJSON, "parseJSON");
var _parseJSON = /* @__PURE__ */ __name((jsonString, allow) => {
  const length = jsonString.length;
  let index = 0;
  const markPartialJSON = /* @__PURE__ */ __name((msg) => {
    throw new PartialJSON(`${msg} at position ${index}`);
  }, "markPartialJSON");
  const throwMalformedError = /* @__PURE__ */ __name((msg) => {
    throw new MalformedJSON(`${msg} at position ${index}`);
  }, "throwMalformedError");
  const parseAny = /* @__PURE__ */ __name(() => {
    skipBlank();
    if (index >= length)
      markPartialJSON("Unexpected end of input");
    if (jsonString[index] === '"')
      return parseStr();
    if (jsonString[index] === "{")
      return parseObj();
    if (jsonString[index] === "[")
      return parseArr();
    if (jsonString.substring(index, index + 4) === "null" || Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
      index += 4;
      return null;
    }
    if (jsonString.substring(index, index + 4) === "true" || Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
      index += 4;
      return true;
    }
    if (jsonString.substring(index, index + 5) === "false" || Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
      index += 5;
      return false;
    }
    if (jsonString.substring(index, index + 8) === "Infinity" || Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
      index += 8;
      return Infinity;
    }
    if (jsonString.substring(index, index + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
      index += 9;
      return -Infinity;
    }
    if (jsonString.substring(index, index + 3) === "NaN" || Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
      index += 3;
      return NaN;
    }
    return parseNum();
  }, "parseAny");
  const parseStr = /* @__PURE__ */ __name(() => {
    const start = index;
    let escape2 = false;
    index++;
    while (index < length && (jsonString[index] !== '"' || escape2 && jsonString[index - 1] === "\\")) {
      escape2 = jsonString[index] === "\\" ? !escape2 : false;
      index++;
    }
    if (jsonString.charAt(index) == '"') {
      try {
        return JSON.parse(jsonString.substring(start, ++index - Number(escape2)));
      } catch (e) {
        throwMalformedError(String(e));
      }
    } else if (Allow.STR & allow) {
      try {
        return JSON.parse(jsonString.substring(start, index - Number(escape2)) + '"');
      } catch (e) {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
      }
    }
    markPartialJSON("Unterminated string literal");
  }, "parseStr");
  const parseObj = /* @__PURE__ */ __name(() => {
    index++;
    skipBlank();
    const obj = {};
    try {
      while (jsonString[index] !== "}") {
        skipBlank();
        if (index >= length && Allow.OBJ & allow)
          return obj;
        const key = parseStr();
        skipBlank();
        index++;
        try {
          const value = parseAny();
          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
        } catch (e) {
          if (Allow.OBJ & allow)
            return obj;
          else
            throw e;
        }
        skipBlank();
        if (jsonString[index] === ",")
          index++;
      }
    } catch (e) {
      if (Allow.OBJ & allow)
        return obj;
      else
        markPartialJSON("Expected '}' at end of object");
    }
    index++;
    return obj;
  }, "parseObj");
  const parseArr = /* @__PURE__ */ __name(() => {
    index++;
    const arr = [];
    try {
      while (jsonString[index] !== "]") {
        arr.push(parseAny());
        skipBlank();
        if (jsonString[index] === ",") {
          index++;
        }
      }
    } catch (e) {
      if (Allow.ARR & allow) {
        return arr;
      }
      markPartialJSON("Expected ']' at end of array");
    }
    index++;
    return arr;
  }, "parseArr");
  const parseNum = /* @__PURE__ */ __name(() => {
    if (index === 0) {
      if (jsonString === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        if (Allow.NUM & allow) {
          try {
            if ("." === jsonString[jsonString.length - 1])
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
          } catch (e2) {
          }
        }
        throwMalformedError(String(e));
      }
    }
    const start = index;
    if (jsonString[index] === "-")
      index++;
    while (jsonString[index] && !",]}".includes(jsonString[index]))
      index++;
    if (index == length && !(Allow.NUM & allow))
      markPartialJSON("Unterminated number literal");
    try {
      return JSON.parse(jsonString.substring(start, index));
    } catch (e) {
      if (jsonString.substring(start, index) === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
      } catch (e2) {
        throwMalformedError(String(e2));
      }
    }
  }, "parseNum");
  const skipBlank = /* @__PURE__ */ __name(() => {
    while (index < length && " \n\r	".includes(jsonString[index])) {
      index++;
    }
  }, "skipBlank");
  return parseAny();
}, "_parseJSON");
var partialParse = /* @__PURE__ */ __name((input) => parseJSON(input, Allow.ALL ^ Allow.NUM), "partialParse");

// node_modules/openai/streaming.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/lib/ChatCompletionStream.mjs
var _ChatCompletionStream_instances;
var _ChatCompletionStream_params;
var _ChatCompletionStream_choiceEventStates;
var _ChatCompletionStream_currentChatCompletionSnapshot;
var _ChatCompletionStream_beginRequest;
var _ChatCompletionStream_getChoiceEventState;
var _ChatCompletionStream_addChunk;
var _ChatCompletionStream_emitToolCallDoneEvent;
var _ChatCompletionStream_emitContentDoneEvents;
var _ChatCompletionStream_endRequest;
var _ChatCompletionStream_getAutoParseableResponseFormat;
var _ChatCompletionStream_accumulateChatCompletion;
var ChatCompletionStream = class _ChatCompletionStream extends AbstractChatCompletionRunner {
  static {
    __name(this, "ChatCompletionStream");
  }
  constructor(params) {
    super();
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_params.set(this, void 0);
    _ChatCompletionStream_choiceEventStates.set(this, void 0);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
    __classPrivateFieldSet(this, _ChatCompletionStream_params, params, "f");
    __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], "f");
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new _ChatCompletionStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(client, params, options) {
    const runner = new _ChatCompletionStream(params);
    runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(client, params, options) {
    super._createChatCompletion;
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = /* @__PURE__ */ __name(function _ChatCompletionStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
  }, "_ChatCompletionStream_beginRequest"), _ChatCompletionStream_getChoiceEventState = /* @__PURE__ */ __name(function _ChatCompletionStream_getChoiceEventState2(choice) {
    let state = __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
    if (state) {
      return state;
    }
    state = {
      content_done: false,
      refusal_done: false,
      logprobs_content_done: false,
      logprobs_refusal_done: false,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    };
    __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
    return state;
  }, "_ChatCompletionStream_getChoiceEventState"), _ChatCompletionStream_addChunk = /* @__PURE__ */ __name(function _ChatCompletionStream_addChunk2(chunk) {
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    for (const choice of chunk.choices) {
      const choiceSnapshot = completion.choices[choice.index];
      if (choice.delta.content != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.content) {
        this._emit("content", choice.delta.content, choiceSnapshot.message.content);
        this._emit("content.delta", {
          delta: choice.delta.content,
          snapshot: choiceSnapshot.message.content,
          parsed: choiceSnapshot.message.parsed
        });
      }
      if (choice.delta.refusal != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.refusal) {
        this._emit("refusal.delta", {
          delta: choice.delta.refusal,
          snapshot: choiceSnapshot.message.refusal
        });
      }
      if (choice.logprobs?.content != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.content.delta", {
          content: choice.logprobs?.content,
          snapshot: choiceSnapshot.logprobs?.content ?? []
        });
      }
      if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.refusal.delta", {
          refusal: choice.logprobs?.refusal,
          snapshot: choiceSnapshot.logprobs?.refusal ?? []
        });
      }
      const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.finish_reason) {
        __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
        if (state.current_tool_call_index != null) {
          __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
        }
      }
      for (const toolCall of choice.delta.tool_calls ?? []) {
        if (state.current_tool_call_index !== toolCall.index) {
          __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        state.current_tool_call_index = toolCall.index;
      }
      for (const toolCallDelta of choice.delta.tool_calls ?? []) {
        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];
        if (!toolCallSnapshot?.type) {
          continue;
        }
        if (toolCallSnapshot?.type === "function") {
          this._emit("tool_calls.function.arguments.delta", {
            name: toolCallSnapshot.function?.name,
            index: toolCallDelta.index,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: toolCallSnapshot.function.parsed_arguments,
            arguments_delta: toolCallDelta.function?.arguments ?? ""
          });
        } else {
          assertNever(toolCallSnapshot?.type);
        }
      }
    }
  }, "_ChatCompletionStream_addChunk"), _ChatCompletionStream_emitToolCallDoneEvent = /* @__PURE__ */ __name(function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
    const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (state.done_tool_calls.has(toolCallIndex)) {
      return;
    }
    const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];
    if (!toolCallSnapshot) {
      throw new Error("no tool call snapshot");
    }
    if (!toolCallSnapshot.type) {
      throw new Error("tool call snapshot missing `type`");
    }
    if (toolCallSnapshot.type === "function") {
      const inputTool = __classPrivateFieldGet(this, _ChatCompletionStream_params, "f")?.tools?.find((tool) => isChatCompletionFunctionTool(tool) && tool.function.name === toolCallSnapshot.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: toolCallSnapshot.function.name,
        index: toolCallIndex,
        arguments: toolCallSnapshot.function.arguments,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments) : null
      });
    } else {
      assertNever(toolCallSnapshot.type);
    }
  }, "_ChatCompletionStream_emitToolCallDoneEvent"), _ChatCompletionStream_emitContentDoneEvents = /* @__PURE__ */ __name(function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
    const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (choiceSnapshot.message.content && !state.content_done) {
      state.content_done = true;
      const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
      this._emit("content.done", {
        content: choiceSnapshot.message.content,
        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
      });
    }
    if (choiceSnapshot.message.refusal && !state.refusal_done) {
      state.refusal_done = true;
      this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
    }
    if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {
      state.logprobs_content_done = true;
      this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
    }
    if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {
      state.logprobs_refusal_done = true;
      this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
    }
  }, "_ChatCompletionStream_emitContentDoneEvents"), _ChatCompletionStream_endRequest = /* @__PURE__ */ __name(function _ChatCompletionStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], "f");
    return finalizeChatCompletion(snapshot, __classPrivateFieldGet(this, _ChatCompletionStream_params, "f"));
  }, "_ChatCompletionStream_endRequest"), _ChatCompletionStream_getAutoParseableResponseFormat = /* @__PURE__ */ __name(function _ChatCompletionStream_getAutoParseableResponseFormat2() {
    const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_params, "f")?.response_format;
    if (isAutoParsableResponseFormat(responseFormat)) {
      return responseFormat;
    }
    return null;
  }, "_ChatCompletionStream_getAutoParseableResponseFormat"), _ChatCompletionStream_accumulateChatCompletion = /* @__PURE__ */ __name(function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
    var _a4, _b, _c, _d;
    let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index];
      if (!choice) {
        choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
          assertIsEmpty(rest3);
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a4 = choice.logprobs).content ?? (_a4.content = []);
            choice.logprobs.content.push(...content2);
          }
          if (refusal2) {
            (_b = choice.logprobs).refusal ?? (_b.refusal = []);
            choice.logprobs.refusal.push(...refusal2);
          }
        }
      }
      if (finish_reason) {
        choice.finish_reason = finish_reason;
        if (__classPrivateFieldGet(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"))) {
          if (finish_reason === "length") {
            throw new LengthFinishReasonError();
          }
          if (finish_reason === "content_filter") {
            throw new ContentFilterFinishReasonError();
          }
        }
      }
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
      assertIsEmpty(rest2);
      Object.assign(choice.message, rest2);
      if (refusal) {
        choice.message.refusal = (choice.message.refusal || "") + refusal;
      }
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_c = choice.message.function_call).arguments ?? (_c.arguments = "");
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (content) {
        choice.message.content = (choice.message.content || "") + content;
        if (!choice.message.refusal && __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
          choice.message.parsed = partialParse(choice.message.content);
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index2, id, type, function: fn, ...rest3 } of tool_calls) {
          const tool_call = (_d = choice.message.tool_calls)[index2] ?? (_d[index2] = {});
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type)
            tool_call.type = type;
          if (fn)
            tool_call.function ?? (tool_call.function = { name: fn.name ?? "", arguments: "" });
          if (fn?.name)
            tool_call.function.name = fn.name;
          if (fn?.arguments) {
            tool_call.function.arguments += fn.arguments;
            if (shouldParseToolCall(__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"), tool_call)) {
              tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
            }
          }
        }
      }
    }
    return snapshot;
  }, "_ChatCompletionStream_accumulateChatCompletion"), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: /* @__PURE__ */ __name(async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject2) => readQueue.push({ resolve, reject: reject2 })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      }, "next"),
      return: /* @__PURE__ */ __name(async () => {
        this.abort();
        return { value: void 0, done: true };
      }, "return")
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: message.refusal ?? null
          },
          finish_reason,
          index,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: message.refusal ?? null,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id
${str(snapshot)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type
${str(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name
${str(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
              }
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: message.refusal ?? null },
        finish_reason,
        index,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
__name(finalizeChatCompletion, "finalizeChatCompletion");
function str(x) {
  return JSON.stringify(x);
}
__name(str, "str");
function assertIsEmpty(obj) {
  return;
}
__name(assertIsEmpty, "assertIsEmpty");
function assertNever(_x) {
}
__name(assertNever, "assertNever");

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner = class _ChatCompletionStreamingRunner extends ChatCompletionStream {
  static {
    __name(this, "ChatCompletionStreamingRunner");
  }
  static fromReadableStream(stream) {
    const runner = new _ChatCompletionStreamingRunner(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new _ChatCompletionStreamingRunner(
      // @ts-expect-error TODO these types are incompatible
      params
    );
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
};

// node_modules/openai/resources/chat/completions/completions.mjs
var Completions = class extends APIResource {
  static {
    __name(this, "Completions");
  }
  constructor() {
    super(...arguments);
    this.messages = new Messages(this._client);
  }
  create(body, options) {
    return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
  }
  /**
   * Get a stored chat completion. Only Chat Completions that have been created with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * const chatCompletion =
   *   await client.chat.completions.retrieve('completion_id');
   * ```
   */
  retrieve(completionID, options) {
    return this._client.get(path3`/chat/completions/${completionID}`, options);
  }
  /**
   * Modify a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be modified. Currently, the only
   * supported modification is to update the `metadata` field.
   *
   * @example
   * ```ts
   * const chatCompletion = await client.chat.completions.update(
   *   'completion_id',
   *   { metadata: { foo: 'string' } },
   * );
   * ```
   */
  update(completionID, body, options) {
    return this._client.post(path3`/chat/completions/${completionID}`, { body, ...options });
  }
  /**
   * List stored Chat Completions. Only Chat Completions that have been stored with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletion of client.chat.completions.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/chat/completions", CursorPage, { query, ...options });
  }
  /**
   * Delete a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be deleted.
   *
   * @example
   * ```ts
   * const chatCompletionDeleted =
   *   await client.chat.completions.delete('completion_id');
   * ```
   */
  delete(completionID, options) {
    return this._client.delete(path3`/chat/completions/${completionID}`, options);
  }
  parse(body, options) {
    validateInputTools(body.tools);
    return this._client.chat.completions.create(body, {
      ...options,
      headers: {
        ...options?.headers,
        "X-Stainless-Helper-Method": "chat.completions.parse"
      }
    })._thenUnwrap((completion) => parseChatCompletion(completion, body));
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client, body, options);
    }
    return ChatCompletionRunner.runTools(this._client, body, options);
  }
  /**
   * Creates a chat completion stream
   */
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client, body, options);
  }
};
Completions.Messages = Messages;

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
  static {
    __name(this, "Chat");
  }
  constructor() {
    super(...arguments);
    this.completions = new Completions(this._client);
  }
};
Chat.Completions = Completions;

// node_modules/openai/resources/chat/completions/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/shared.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/audio/audio.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/audio/speech.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/internal/headers.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var brand_privateNullableHeaders = /* @__PURE__ */ Symbol("brand.privateNullableHeaders");
function* iterateHeaders(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers ?? {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === void 0)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
__name(iterateHeaders, "iterateHeaders");
var buildHeaders = /* @__PURE__ */ __name((newHeaders) => {
  const targetHeaders = new Headers();
  const nullHeaders = /* @__PURE__ */ new Set();
  for (const headers of newHeaders) {
    const seenHeaders = /* @__PURE__ */ new Set();
    for (const [name, value] of iterateHeaders(headers)) {
      const lowerName = name.toLowerCase();
      if (!seenHeaders.has(lowerName)) {
        targetHeaders.delete(name);
        seenHeaders.add(lowerName);
      }
      if (value === null) {
        targetHeaders.delete(name);
        nullHeaders.add(lowerName);
      } else {
        targetHeaders.append(name, value);
        nullHeaders.delete(lowerName);
      }
    }
  }
  return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };
}, "buildHeaders");

// node_modules/openai/resources/audio/speech.mjs
var Speech = class extends APIResource {
  static {
    __name(this, "Speech");
  }
  /**
   * Generates audio from the input text.
   *
   * @example
   * ```ts
   * const speech = await client.audio.speech.create({
   *   input: 'input',
   *   model: 'string',
   *   voice: 'ash',
   * });
   *
   * const content = await speech.blob();
   * console.log(content);
   * ```
   */
  create(body, options) {
    return this._client.post("/audio/speech", {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "application/octet-stream" }, options?.headers]),
      __binaryResponse: true
    });
  }
};

// node_modules/openai/resources/audio/transcriptions.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Transcriptions = class extends APIResource {
  static {
    __name(this, "Transcriptions");
  }
  create(body, options) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions({
      body,
      ...options,
      stream: body.stream ?? false,
      __metadata: { model: body.model }
    }, this._client));
  }
};

// node_modules/openai/resources/audio/translations.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Translations = class extends APIResource {
  static {
    __name(this, "Translations");
  }
  create(body, options) {
    return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options, __metadata: { model: body.model } }, this._client));
  }
};

// node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource {
  static {
    __name(this, "Audio");
  }
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
};
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;
Audio.Speech = Speech;

// node_modules/openai/resources/batches.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Batches = class extends APIResource {
  static {
    __name(this, "Batches");
  }
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(body, options) {
    return this._client.post("/batches", { body, ...options });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(batchID, options) {
    return this._client.get(path3`/batches/${batchID}`, options);
  }
  /**
   * List your organization's batches.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/batches", CursorPage, { query, ...options });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(batchID, options) {
    return this._client.post(path3`/batches/${batchID}/cancel`, options);
  }
};

// node_modules/openai/resources/beta/beta.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/beta/assistants.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Assistants = class extends APIResource {
  static {
    __name(this, "Assistants");
  }
  /**
   * Create an assistant with a model and instructions.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.create({
   *   model: 'gpt-4o',
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieves an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.retrieve(
   *   'assistant_id',
   * );
   * ```
   */
  retrieve(assistantID, options) {
    return this._client.get(path3`/assistants/${assistantID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Modifies an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.update(
   *   'assistant_id',
   * );
   * ```
   */
  update(assistantID, body, options) {
    return this._client.post(path3`/assistants/${assistantID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of assistants.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const assistant of client.beta.assistants.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/assistants", CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Delete an assistant.
   *
   * @example
   * ```ts
   * const assistantDeleted =
   *   await client.beta.assistants.delete('assistant_id');
   * ```
   */
  delete(assistantID, options) {
    return this._client.delete(path3`/assistants/${assistantID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/beta/realtime/realtime.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/beta/realtime/sessions.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Sessions = class extends APIResource {
  static {
    __name(this, "Sessions");
  }
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const session =
   *   await client.beta.realtime.sessions.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/sessions", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/beta/realtime/transcription-sessions.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TranscriptionSessions = class extends APIResource {
  static {
    __name(this, "TranscriptionSessions");
  }
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions. Can be configured with
   * the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const transcriptionSession =
   *   await client.beta.realtime.transcriptionSessions.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/transcription_sessions", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/beta/realtime/realtime.mjs
var Realtime = class extends APIResource {
  static {
    __name(this, "Realtime");
  }
  constructor() {
    super(...arguments);
    this.sessions = new Sessions(this._client);
    this.transcriptionSessions = new TranscriptionSessions(this._client);
  }
};
Realtime.Sessions = Sessions;
Realtime.TranscriptionSessions = TranscriptionSessions;

// node_modules/openai/resources/beta/chatkit/chatkit.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/beta/chatkit/sessions.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Sessions2 = class extends APIResource {
  static {
    __name(this, "Sessions");
  }
  /**
   * Create a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.create({
   *     user: 'x',
   *     workflow: { id: 'id' },
   *   });
   * ```
   */
  create(body, options) {
    return this._client.post("/chatkit/sessions", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  /**
   * Cancel a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.cancel('cksess_123');
   * ```
   */
  cancel(sessionID, options) {
    return this._client.post(path3`/chatkit/sessions/${sessionID}/cancel`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/beta/chatkit/threads.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Threads = class extends APIResource {
  static {
    __name(this, "Threads");
  }
  /**
   * Retrieve a ChatKit thread
   *
   * @example
   * ```ts
   * const chatkitThread =
   *   await client.beta.chatkit.threads.retrieve('cthr_123');
   * ```
   */
  retrieve(threadID, options) {
    return this._client.get(path3`/chatkit/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  /**
   * List ChatKit threads
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatkitThread of client.beta.chatkit.threads.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/chatkit/threads", ConversationCursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  /**
   * Delete a ChatKit thread
   *
   * @example
   * ```ts
   * const thread = await client.beta.chatkit.threads.delete(
   *   'cthr_123',
   * );
   * ```
   */
  delete(threadID, options) {
    return this._client.delete(path3`/chatkit/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  /**
   * List ChatKit thread items
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const thread of client.beta.chatkit.threads.listItems(
   *   'cthr_123',
   * )) {
   *   // ...
   * }
   * ```
   */
  listItems(threadID, query = {}, options) {
    return this._client.getAPIList(path3`/chatkit/threads/${threadID}/items`, ConversationCursorPage, { query, ...options, headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers]) });
  }
};

// node_modules/openai/resources/beta/chatkit/chatkit.mjs
var ChatKit = class extends APIResource {
  static {
    __name(this, "ChatKit");
  }
  constructor() {
    super(...arguments);
    this.sessions = new Sessions2(this._client);
    this.threads = new Threads(this._client);
  }
  /**
   * Upload a ChatKit file
   *
   * @example
   * ```ts
   * const response = await client.beta.chatkit.uploadFile({
   *   file: fs.createReadStream('path/to/file'),
   * });
   * ```
   */
  uploadFile(body, options) {
    return this._client.post("/chatkit/files", maybeMultipartFormRequestOptions({ body, ...options, headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers]) }, this._client));
  }
};
ChatKit.Sessions = Sessions2;
ChatKit.Threads = Threads;

// node_modules/openai/resources/beta/threads/threads.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/beta/threads/messages.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Messages2 = class extends APIResource {
  static {
    __name(this, "Messages");
  }
  /**
   * Create a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(threadID, body, options) {
    return this._client.post(path3`/threads/${threadID}/messages`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieve a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(messageID, params, options) {
    const { thread_id } = params;
    return this._client.get(path3`/threads/${thread_id}/messages/${messageID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Modifies a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(messageID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path3`/threads/${thread_id}/messages/${messageID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of messages for a given thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(threadID, query = {}, options) {
    return this._client.getAPIList(path3`/threads/${threadID}/messages`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Deletes a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(messageID, params, options) {
    const { thread_id } = params;
    return this._client.delete(path3`/threads/${thread_id}/messages/${messageID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/beta/threads/runs/runs.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/beta/threads/runs/steps.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Steps = class extends APIResource {
  static {
    __name(this, "Steps");
  }
  /**
   * Retrieves a run step.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(stepID, params, options) {
    const { thread_id, run_id, ...query } = params;
    return this._client.get(path3`/threads/${thread_id}/runs/${run_id}/steps/${stepID}`, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of run steps belonging to a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(runID, params, options) {
    const { thread_id, ...query } = params;
    return this._client.getAPIList(path3`/threads/${thread_id}/runs/${runID}/steps`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};

// node_modules/openai/lib/AssistantStream.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/internal/utils.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/internal/utils/base64.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var toFloat32Array = /* @__PURE__ */ __name((base64Str) => {
  if (typeof Buffer !== "undefined") {
    const buf = Buffer.from(base64Str, "base64");
    return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));
  } else {
    const binaryStr = atob(base64Str);
    const len = binaryStr.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binaryStr.charCodeAt(i);
    }
    return Array.from(new Float32Array(bytes.buffer));
  }
}, "toFloat32Array");

// node_modules/openai/internal/utils/env.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var readEnv = /* @__PURE__ */ __name((env2) => {
  if (typeof globalThis.process !== "undefined") {
    return globalThis.process.env?.[env2]?.trim() ?? void 0;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return globalThis.Deno.env?.get?.(env2)?.trim();
  }
  return void 0;
}, "readEnv");

// node_modules/openai/lib/AssistantStream.mjs
var _AssistantStream_instances;
var _a2;
var _AssistantStream_events;
var _AssistantStream_runStepSnapshots;
var _AssistantStream_messageSnapshots;
var _AssistantStream_messageSnapshot;
var _AssistantStream_finalRun;
var _AssistantStream_currentContentIndex;
var _AssistantStream_currentContent;
var _AssistantStream_currentToolCallIndex;
var _AssistantStream_currentToolCall;
var _AssistantStream_currentEvent;
var _AssistantStream_currentRunSnapshot;
var _AssistantStream_currentRunStepSnapshot;
var _AssistantStream_addEvent;
var _AssistantStream_endRequest;
var _AssistantStream_handleMessage;
var _AssistantStream_handleRunStep;
var _AssistantStream_handleEvent;
var _AssistantStream_accumulateRunStep;
var _AssistantStream_accumulateMessage;
var _AssistantStream_accumulateContent;
var _AssistantStream_handleRun;
var AssistantStream = class extends EventStream {
  static {
    __name(this, "AssistantStream");
  }
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, void 0);
    _AssistantStream_finalRun.set(this, void 0);
    _AssistantStream_currentContentIndex.set(this, void 0);
    _AssistantStream_currentContent.set(this, void 0);
    _AssistantStream_currentToolCallIndex.set(this, void 0);
    _AssistantStream_currentToolCall.set(this, void 0);
    _AssistantStream_currentEvent.set(this, void 0);
    _AssistantStream_currentRunSnapshot.set(this, void 0);
    _AssistantStream_currentRunStepSnapshot.set(this, void 0);
  }
  [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: /* @__PURE__ */ __name(async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject2) => readQueue.push({ resolve, reject: reject2 })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      }, "next"),
      return: /* @__PURE__ */ __name(async () => {
        this.abort();
        return { value: void 0, done: true };
      }, "return")
    };
  }
  static fromReadableStream(stream) {
    const runner = new _a2();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
  static createToolAssistantStream(runId, runs, params, options) {
    const runner = new _a2();
    runner._run(() => runner._runToolAssistantStream(runId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run, runId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.submitToolOutputs(runId, body, {
      ...options,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(params, thread, options) {
    const runner = new _a2();
    runner._run(() => runner._threadAssistantStream(params, thread, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options) {
    const runner = new _a2();
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run, threadId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === void 0) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
        for (const deltaEntry of deltaValue) {
          if (!isObj(deltaEntry)) {
            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
          }
          const index = deltaEntry["index"];
          if (index == null) {
            console.error(deltaEntry);
            throw new Error("Expected array delta entry to have an `index` property");
          }
          if (typeof index !== "number") {
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index}`);
          }
          const accEntry = accValue[index];
          if (accEntry == null) {
            accValue.push(deltaEntry);
          } else {
            accValue[index] = this.accumulateDelta(accEntry, deltaEntry);
          }
        }
        continue;
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
  _addRun(run) {
    return run;
  }
  async _threadAssistantStream(params, thread, options) {
    return await this._createThreadAssistantStream(thread, params, options);
  }
  async _runAssistantStream(threadId, runs, params, options) {
    return await this._createAssistantStream(runs, threadId, params, options);
  }
  async _runToolAssistantStream(runId, runs, params, options) {
    return await this._createToolAssistantStream(runs, runId, params, options);
  }
};
_a2 = AssistantStream, _AssistantStream_addEvent = /* @__PURE__ */ __name(function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, "f");
  __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.incomplete":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    default:
      assertNever2(event);
  }
}, "_AssistantStream_addEvent"), _AssistantStream_endRequest = /* @__PURE__ */ __name(function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has not been received");
  return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
}, "_AssistantStream_endRequest"), _AssistantStream_handleMessage = /* @__PURE__ */ __name(function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
  __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if (snapshotContent?.type == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, "f");
          }
          __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
        const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, void 0, "f");
  }
}, "_AssistantStream_handleMessage"), _AssistantStream_handleRunStep = /* @__PURE__ */ __name(function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
            __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
    case "thread.run.step.in_progress":
      break;
  }
}, "_AssistantStream_handleRunStep"), _AssistantStream_handleEvent = /* @__PURE__ */ __name(function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, "_AssistantStream_handleEvent"), _AssistantStream_accumulateRunStep = /* @__PURE__ */ __name(function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = _a2.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, "_AssistantStream_accumulateRunStep"), _AssistantStream_accumulateMessage = /* @__PURE__ */ __name(function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, "_AssistantStream_accumulateMessage"), _AssistantStream_accumulateContent = /* @__PURE__ */ __name(function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return _a2.accumulateDelta(currentContent, contentElement);
}, "_AssistantStream_accumulateContent"), _AssistantStream_handleRun = /* @__PURE__ */ __name(function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, "f");
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
    case "thread.run.incomplete":
      __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, "f");
      if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
      }
      break;
    case "thread.run.cancelling":
      break;
  }
}, "_AssistantStream_handleRun");
function assertNever2(_x) {
}
__name(assertNever2, "assertNever");

// node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs = class extends APIResource {
  static {
    __name(this, "Runs");
  }
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadID, params, options) {
    const { include, ...body } = params;
    return this._client.post(path3`/threads/${threadID}/runs`, {
      query: { include },
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
      stream: params.stream ?? false
    });
  }
  /**
   * Retrieves a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(runID, params, options) {
    const { thread_id } = params;
    return this._client.get(path3`/threads/${thread_id}/runs/${runID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Modifies a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(runID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path3`/threads/${thread_id}/runs/${runID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of runs belonging to a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(threadID, query = {}, options) {
    return this._client.getAPIList(path3`/threads/${threadID}/runs`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  cancel(runID, params, options) {
    const { thread_id } = params;
    return this._client.post(path3`/threads/${thread_id}/runs/${runID}/cancel`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(threadId, body, options) {
    const run = await this.create(threadId, body, options);
    return await this.poll(run.id, { thread_id: threadId }, options);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(runId, params, options) {
    const headers = buildHeaders([
      options?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? void 0
      }
    ]);
    while (true) {
      const { data: run, response } = await this.retrieve(runId, params, {
        ...options,
        headers: { ...options?.headers, ...headers }
      }).withResponse();
      switch (run.status) {
        //If we are in any sort of intermediate state we poll
        case "queued":
        case "in_progress":
        case "cancelling":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        //We return the run in any terminal state.
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return run;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  submitToolOutputs(runID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path3`/threads/${thread_id}/runs/${runID}/submit_tool_outputs`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
      stream: params.stream ?? false
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(runId, params, options) {
    const run = await this.submitToolOutputs(runId, params, options);
    return await this.poll(run.id, params, options);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(runId, params, options) {
    return AssistantStream.createToolAssistantStream(runId, this._client.beta.threads.runs, params, options);
  }
};
Runs.Steps = Steps;

// node_modules/openai/resources/beta/threads/threads.mjs
var Threads2 = class extends APIResource {
  static {
    __name(this, "Threads");
  }
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
    this.messages = new Messages2(this._client);
  }
  /**
   * Create a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(body = {}, options) {
    return this._client.post("/threads", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieves a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(threadID, options) {
    return this._client.get(path3`/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Modifies a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(threadID, body, options) {
    return this._client.post(path3`/threads/${threadID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Delete a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(threadID, options) {
    return this._client.delete(path3`/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  createAndRun(body, options) {
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
      stream: body.stream ?? false
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(body, options) {
    const run = await this.createAndRun(body, options);
    return await this.runs.poll(run.id, { thread_id: run.thread_id }, options);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(body, options) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
  }
};
Threads2.Runs = Runs;
Threads2.Messages = Messages2;

// node_modules/openai/resources/beta/beta.mjs
var Beta = class extends APIResource {
  static {
    __name(this, "Beta");
  }
  constructor() {
    super(...arguments);
    this.realtime = new Realtime(this._client);
    this.chatkit = new ChatKit(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads2(this._client);
  }
};
Beta.Realtime = Realtime;
Beta.ChatKit = ChatKit;
Beta.Assistants = Assistants;
Beta.Threads = Threads2;

// node_modules/openai/resources/completions.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Completions2 = class extends APIResource {
  static {
    __name(this, "Completions");
  }
  create(body, options) {
    return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
  }
};

// node_modules/openai/resources/containers/containers.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/containers/files/files.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/containers/files/content.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Content = class extends APIResource {
  static {
    __name(this, "Content");
  }
  /**
   * Retrieve Container File Content
   */
  retrieve(fileID, params, options) {
    const { container_id } = params;
    return this._client.get(path3`/containers/${container_id}/files/${fileID}/content`, {
      ...options,
      headers: buildHeaders([{ Accept: "application/binary" }, options?.headers]),
      __binaryResponse: true
    });
  }
};

// node_modules/openai/resources/containers/files/files.mjs
var Files = class extends APIResource {
  static {
    __name(this, "Files");
  }
  constructor() {
    super(...arguments);
    this.content = new Content(this._client);
  }
  /**
   * Create a Container File
   *
   * You can send either a multipart/form-data request with the raw file content, or
   * a JSON request with a file ID.
   */
  create(containerID, body, options) {
    return this._client.post(path3`/containers/${containerID}/files`, multipartFormRequestOptions({ body, ...options }, this._client));
  }
  /**
   * Retrieve Container File
   */
  retrieve(fileID, params, options) {
    const { container_id } = params;
    return this._client.get(path3`/containers/${container_id}/files/${fileID}`, options);
  }
  /**
   * List Container files
   */
  list(containerID, query = {}, options) {
    return this._client.getAPIList(path3`/containers/${containerID}/files`, CursorPage, {
      query,
      ...options
    });
  }
  /**
   * Delete Container File
   */
  delete(fileID, params, options) {
    const { container_id } = params;
    return this._client.delete(path3`/containers/${container_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
};
Files.Content = Content;

// node_modules/openai/resources/containers/containers.mjs
var Containers = class extends APIResource {
  static {
    __name(this, "Containers");
  }
  constructor() {
    super(...arguments);
    this.files = new Files(this._client);
  }
  /**
   * Create Container
   */
  create(body, options) {
    return this._client.post("/containers", { body, ...options });
  }
  /**
   * Retrieve Container
   */
  retrieve(containerID, options) {
    return this._client.get(path3`/containers/${containerID}`, options);
  }
  /**
   * List Containers
   */
  list(query = {}, options) {
    return this._client.getAPIList("/containers", CursorPage, { query, ...options });
  }
  /**
   * Delete Container
   */
  delete(containerID, options) {
    return this._client.delete(path3`/containers/${containerID}`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
};
Containers.Files = Files;

// node_modules/openai/resources/conversations/conversations.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/conversations/items.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Items = class extends APIResource {
  static {
    __name(this, "Items");
  }
  /**
   * Create items in a conversation with the given ID.
   */
  create(conversationID, params, options) {
    const { include, ...body } = params;
    return this._client.post(path3`/conversations/${conversationID}/items`, {
      query: { include },
      body,
      ...options
    });
  }
  /**
   * Get a single item from a conversation with the given IDs.
   */
  retrieve(itemID, params, options) {
    const { conversation_id, ...query } = params;
    return this._client.get(path3`/conversations/${conversation_id}/items/${itemID}`, { query, ...options });
  }
  /**
   * List all items for a conversation with the given ID.
   */
  list(conversationID, query = {}, options) {
    return this._client.getAPIList(path3`/conversations/${conversationID}/items`, ConversationCursorPage, { query, ...options });
  }
  /**
   * Delete an item from a conversation with the given IDs.
   */
  delete(itemID, params, options) {
    const { conversation_id } = params;
    return this._client.delete(path3`/conversations/${conversation_id}/items/${itemID}`, options);
  }
};

// node_modules/openai/resources/conversations/conversations.mjs
var Conversations = class extends APIResource {
  static {
    __name(this, "Conversations");
  }
  constructor() {
    super(...arguments);
    this.items = new Items(this._client);
  }
  /**
   * Create a conversation.
   */
  create(body = {}, options) {
    return this._client.post("/conversations", { body, ...options });
  }
  /**
   * Get a conversation
   */
  retrieve(conversationID, options) {
    return this._client.get(path3`/conversations/${conversationID}`, options);
  }
  /**
   * Update a conversation
   */
  update(conversationID, body, options) {
    return this._client.post(path3`/conversations/${conversationID}`, { body, ...options });
  }
  /**
   * Delete a conversation. Items in the conversation will not be deleted.
   */
  delete(conversationID, options) {
    return this._client.delete(path3`/conversations/${conversationID}`, options);
  }
};
Conversations.Items = Items;

// node_modules/openai/resources/embeddings.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Embeddings = class extends APIResource {
  static {
    __name(this, "Embeddings");
  }
  /**
   * Creates an embedding vector representing the input text.
   *
   * @example
   * ```ts
   * const createEmbeddingResponse =
   *   await client.embeddings.create({
   *     input: 'The quick brown fox jumped over the lazy dog',
   *     model: 'text-embedding-3-small',
   *   });
   * ```
   */
  create(body, options) {
    const hasUserProvidedEncodingFormat = !!body.encoding_format;
    let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : "base64";
    if (hasUserProvidedEncodingFormat) {
      loggerFor(this._client).debug("embeddings/user defined encoding_format:", body.encoding_format);
    }
    const response = this._client.post("/embeddings", {
      body: {
        ...body,
        encoding_format
      },
      ...options
    });
    if (hasUserProvidedEncodingFormat) {
      return response;
    }
    loggerFor(this._client).debug("embeddings/decoding base64 embeddings from base64");
    return response._thenUnwrap((response2) => {
      if (response2 && response2.data) {
        response2.data.forEach((embeddingBase64Obj) => {
          const embeddingBase64Str = embeddingBase64Obj.embedding;
          embeddingBase64Obj.embedding = toFloat32Array(embeddingBase64Str);
        });
      }
      return response2;
    });
  }
};

// node_modules/openai/resources/evals/evals.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/evals/runs/runs.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/evals/runs/output-items.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OutputItems = class extends APIResource {
  static {
    __name(this, "OutputItems");
  }
  /**
   * Get an evaluation run output item by ID.
   */
  retrieve(outputItemID, params, options) {
    const { eval_id, run_id } = params;
    return this._client.get(path3`/evals/${eval_id}/runs/${run_id}/output_items/${outputItemID}`, options);
  }
  /**
   * Get a list of output items for an evaluation run.
   */
  list(runID, params, options) {
    const { eval_id, ...query } = params;
    return this._client.getAPIList(path3`/evals/${eval_id}/runs/${runID}/output_items`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/resources/evals/runs/runs.mjs
var Runs2 = class extends APIResource {
  static {
    __name(this, "Runs");
  }
  constructor() {
    super(...arguments);
    this.outputItems = new OutputItems(this._client);
  }
  /**
   * Kicks off a new run for a given evaluation, specifying the data source, and what
   * model configuration to use to test. The datasource will be validated against the
   * schema specified in the config of the evaluation.
   */
  create(evalID, body, options) {
    return this._client.post(path3`/evals/${evalID}/runs`, { body, ...options });
  }
  /**
   * Get an evaluation run by ID.
   */
  retrieve(runID, params, options) {
    const { eval_id } = params;
    return this._client.get(path3`/evals/${eval_id}/runs/${runID}`, options);
  }
  /**
   * Get a list of runs for an evaluation.
   */
  list(evalID, query = {}, options) {
    return this._client.getAPIList(path3`/evals/${evalID}/runs`, CursorPage, {
      query,
      ...options
    });
  }
  /**
   * Delete an eval run.
   */
  delete(runID, params, options) {
    const { eval_id } = params;
    return this._client.delete(path3`/evals/${eval_id}/runs/${runID}`, options);
  }
  /**
   * Cancel an ongoing evaluation run.
   */
  cancel(runID, params, options) {
    const { eval_id } = params;
    return this._client.post(path3`/evals/${eval_id}/runs/${runID}`, options);
  }
};
Runs2.OutputItems = OutputItems;

// node_modules/openai/resources/evals/evals.mjs
var Evals = class extends APIResource {
  static {
    __name(this, "Evals");
  }
  constructor() {
    super(...arguments);
    this.runs = new Runs2(this._client);
  }
  /**
   * Create the structure of an evaluation that can be used to test a model's
   * performance. An evaluation is a set of testing criteria and the config for a
   * data source, which dictates the schema of the data used in the evaluation. After
   * creating an evaluation, you can run it on different models and model parameters.
   * We support several types of graders and datasources. For more information, see
   * the [Evals guide](https://platform.openai.com/docs/guides/evals).
   */
  create(body, options) {
    return this._client.post("/evals", { body, ...options });
  }
  /**
   * Get an evaluation by ID.
   */
  retrieve(evalID, options) {
    return this._client.get(path3`/evals/${evalID}`, options);
  }
  /**
   * Update certain properties of an evaluation.
   */
  update(evalID, body, options) {
    return this._client.post(path3`/evals/${evalID}`, { body, ...options });
  }
  /**
   * List evaluations for a project.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/evals", CursorPage, { query, ...options });
  }
  /**
   * Delete an evaluation.
   */
  delete(evalID, options) {
    return this._client.delete(path3`/evals/${evalID}`, options);
  }
};
Evals.Runs = Runs2;

// node_modules/openai/resources/files.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Files2 = class extends APIResource {
  static {
    __name(this, "Files");
  }
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 1 TB.
   *
   * The Assistants API supports files up to 2 million tokens and of specific file
   * types. See the
   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
   * details.
   *
   * The Fine-tuning API only supports `.jsonl` files. The input also has certain
   * required formats for fine-tuning
   * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
   * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   * models.
   *
   * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
   * has a specific required
   * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(body, options) {
    return this._client.post("/files", multipartFormRequestOptions({ body, ...options }, this._client));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileID, options) {
    return this._client.get(path3`/files/${fileID}`, options);
  }
  /**
   * Returns a list of files.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/files", CursorPage, { query, ...options });
  }
  /**
   * Delete a file and remove it from all vector stores.
   */
  delete(fileID, options) {
    return this._client.delete(path3`/files/${fileID}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileID, options) {
    return this._client.get(path3`/files/${fileID}/content`, {
      ...options,
      headers: buildHeaders([{ Accept: "application/binary" }, options?.headers]),
      __binaryResponse: true
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/fine-tuning/methods.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Methods = class extends APIResource {
  static {
    __name(this, "Methods");
  }
};

// node_modules/openai/resources/fine-tuning/alpha/alpha.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/fine-tuning/alpha/graders.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Graders = class extends APIResource {
  static {
    __name(this, "Graders");
  }
  /**
   * Run a grader.
   *
   * @example
   * ```ts
   * const response = await client.fineTuning.alpha.graders.run({
   *   grader: {
   *     input: 'input',
   *     name: 'name',
   *     operation: 'eq',
   *     reference: 'reference',
   *     type: 'string_check',
   *   },
   *   model_sample: 'model_sample',
   * });
   * ```
   */
  run(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/run", { body, ...options });
  }
  /**
   * Validate a grader.
   *
   * @example
   * ```ts
   * const response =
   *   await client.fineTuning.alpha.graders.validate({
   *     grader: {
   *       input: 'input',
   *       name: 'name',
   *       operation: 'eq',
   *       reference: 'reference',
   *       type: 'string_check',
   *     },
   *   });
   * ```
   */
  validate(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/validate", { body, ...options });
  }
};

// node_modules/openai/resources/fine-tuning/alpha/alpha.mjs
var Alpha = class extends APIResource {
  static {
    __name(this, "Alpha");
  }
  constructor() {
    super(...arguments);
    this.graders = new Graders(this._client);
  }
};
Alpha.Graders = Graders;

// node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/fine-tuning/checkpoints/permissions.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Permissions = class extends APIResource {
  static {
    __name(this, "Permissions");
  }
  /**
   * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
   *
   * This enables organization owners to share fine-tuned models with other projects
   * in their organization.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
   *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *   { project_ids: ['string'] },
   * )) {
   *   // ...
   * }
   * ```
   */
  create(fineTunedModelCheckpoint, body, options) {
    return this._client.getAPIList(path3`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, Page, { body, method: "post", ...options });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to view all permissions for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.retrieve(
   *     'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   *   );
   * ```
   */
  retrieve(fineTunedModelCheckpoint, query = {}, options) {
    return this._client.get(path3`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {
      query,
      ...options
    });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to delete a permission for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.delete(
   *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
   *     {
   *       fine_tuned_model_checkpoint:
   *         'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *     },
   *   );
   * ```
   */
  delete(permissionID, params, options) {
    const { fine_tuned_model_checkpoint } = params;
    return this._client.delete(path3`/fine_tuning/checkpoints/${fine_tuned_model_checkpoint}/permissions/${permissionID}`, options);
  }
};

// node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs
var Checkpoints = class extends APIResource {
  static {
    __name(this, "Checkpoints");
  }
  constructor() {
    super(...arguments);
    this.permissions = new Permissions(this._client);
  }
};
Checkpoints.Permissions = Permissions;

// node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Checkpoints2 = class extends APIResource {
  static {
    __name(this, "Checkpoints");
  }
  /**
   * List checkpoints for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobCheckpoint of client.fineTuning.jobs.checkpoints.list(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(fineTuningJobID, query = {}, options) {
    return this._client.getAPIList(path3`/fine_tuning/jobs/${fineTuningJobID}/checkpoints`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
var Jobs = class extends APIResource {
  static {
    __name(this, "Jobs");
  }
  constructor() {
    super(...arguments);
    this.checkpoints = new Checkpoints2(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.create({
   *   model: 'gpt-4o-mini',
   *   training_file: 'file-abc123',
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.retrieve(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  retrieve(fineTuningJobID, options) {
    return this._client.get(path3`/fine_tuning/jobs/${fineTuningJobID}`, options);
  }
  /**
   * List your organization's fine-tuning jobs
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJob of client.fineTuning.jobs.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/fine_tuning/jobs", CursorPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.cancel(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  cancel(fineTuningJobID, options) {
    return this._client.post(path3`/fine_tuning/jobs/${fineTuningJobID}/cancel`, options);
  }
  /**
   * Get status updates for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobEvent of client.fineTuning.jobs.listEvents(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  listEvents(fineTuningJobID, query = {}, options) {
    return this._client.getAPIList(path3`/fine_tuning/jobs/${fineTuningJobID}/events`, CursorPage, { query, ...options });
  }
  /**
   * Pause a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.pause(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  pause(fineTuningJobID, options) {
    return this._client.post(path3`/fine_tuning/jobs/${fineTuningJobID}/pause`, options);
  }
  /**
   * Resume a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.resume(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  resume(fineTuningJobID, options) {
    return this._client.post(path3`/fine_tuning/jobs/${fineTuningJobID}/resume`, options);
  }
};
Jobs.Checkpoints = Checkpoints2;

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
  static {
    __name(this, "FineTuning");
  }
  constructor() {
    super(...arguments);
    this.methods = new Methods(this._client);
    this.jobs = new Jobs(this._client);
    this.checkpoints = new Checkpoints(this._client);
    this.alpha = new Alpha(this._client);
  }
};
FineTuning.Methods = Methods;
FineTuning.Jobs = Jobs;
FineTuning.Checkpoints = Checkpoints;
FineTuning.Alpha = Alpha;

// node_modules/openai/resources/graders/graders.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/graders/grader-models.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var GraderModels = class extends APIResource {
  static {
    __name(this, "GraderModels");
  }
};

// node_modules/openai/resources/graders/graders.mjs
var Graders2 = class extends APIResource {
  static {
    __name(this, "Graders");
  }
  constructor() {
    super(...arguments);
    this.graderModels = new GraderModels(this._client);
  }
};
Graders2.GraderModels = GraderModels;

// node_modules/openai/resources/images.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Images = class extends APIResource {
  static {
    __name(this, "Images");
  }
  /**
   * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.createVariation({
   *   image: fs.createReadStream('otter.png'),
   * });
   * ```
   */
  createVariation(body, options) {
    return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }, this._client));
  }
  edit(body, options) {
    return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options, stream: body.stream ?? false }, this._client));
  }
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options, stream: body.stream ?? false });
  }
};

// node_modules/openai/resources/models.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Models = class extends APIResource {
  static {
    __name(this, "Models");
  }
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this._client.get(path3`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this._client.getAPIList("/models", Page, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  delete(model, options) {
    return this._client.delete(path3`/models/${model}`, options);
  }
};

// node_modules/openai/resources/moderations.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Moderations = class extends APIResource {
  static {
    __name(this, "Moderations");
  }
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
};

// node_modules/openai/resources/realtime/realtime.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/realtime/calls.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Calls = class extends APIResource {
  static {
    __name(this, "Calls");
  }
  /**
   * Accept an incoming SIP call and configure the realtime session that will handle
   * it.
   *
   * @example
   * ```ts
   * await client.realtime.calls.accept('call_id', {
   *   type: 'realtime',
   * });
   * ```
   */
  accept(callID, body, options) {
    return this._client.post(path3`/realtime/calls/${callID}/accept`, {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  /**
   * End an active Realtime API call, whether it was initiated over SIP or WebRTC.
   *
   * @example
   * ```ts
   * await client.realtime.calls.hangup('call_id');
   * ```
   */
  hangup(callID, options) {
    return this._client.post(path3`/realtime/calls/${callID}/hangup`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  /**
   * Transfer an active SIP call to a new destination using the SIP REFER verb.
   *
   * @example
   * ```ts
   * await client.realtime.calls.refer('call_id', {
   *   target_uri: 'tel:+14155550123',
   * });
   * ```
   */
  refer(callID, body, options) {
    return this._client.post(path3`/realtime/calls/${callID}/refer`, {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  /**
   * Decline an incoming SIP call by returning a SIP status code to the caller.
   *
   * @example
   * ```ts
   * await client.realtime.calls.reject('call_id');
   * ```
   */
  reject(callID, body = {}, options) {
    return this._client.post(path3`/realtime/calls/${callID}/reject`, {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/realtime/client-secrets.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ClientSecrets = class extends APIResource {
  static {
    __name(this, "ClientSecrets");
  }
  /**
   * Create a Realtime client secret with an associated session configuration.
   *
   * @example
   * ```ts
   * const clientSecret =
   *   await client.realtime.clientSecrets.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/client_secrets", { body, ...options });
  }
};

// node_modules/openai/resources/realtime/realtime.mjs
var Realtime2 = class extends APIResource {
  static {
    __name(this, "Realtime");
  }
  constructor() {
    super(...arguments);
    this.clientSecrets = new ClientSecrets(this._client);
    this.calls = new Calls(this._client);
  }
};
Realtime2.ClientSecrets = ClientSecrets;
Realtime2.Calls = Calls;

// node_modules/openai/resources/responses/responses.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/lib/ResponsesParser.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function maybeParseResponse(response, params) {
  if (!params || !hasAutoParseableInput2(params)) {
    return {
      ...response,
      output_parsed: null,
      output: response.output.map((item) => {
        if (item.type === "function_call") {
          return {
            ...item,
            parsed_arguments: null
          };
        }
        if (item.type === "message") {
          return {
            ...item,
            content: item.content.map((content) => ({
              ...content,
              parsed: null
            }))
          };
        } else {
          return item;
        }
      })
    };
  }
  return parseResponse(response, params);
}
__name(maybeParseResponse, "maybeParseResponse");
function parseResponse(response, params) {
  const output = response.output.map((item) => {
    if (item.type === "function_call") {
      return {
        ...item,
        parsed_arguments: parseToolCall2(params, item)
      };
    }
    if (item.type === "message") {
      const content = item.content.map((content2) => {
        if (content2.type === "output_text") {
          return {
            ...content2,
            parsed: parseTextFormat(params, content2.text)
          };
        }
        return content2;
      });
      return {
        ...item,
        content
      };
    }
    return item;
  });
  const parsed = Object.assign({}, response, { output });
  if (!Object.getOwnPropertyDescriptor(response, "output_text")) {
    addOutputText(parsed);
  }
  Object.defineProperty(parsed, "output_parsed", {
    enumerable: true,
    get() {
      for (const output2 of parsed.output) {
        if (output2.type !== "message") {
          continue;
        }
        for (const content of output2.content) {
          if (content.type === "output_text" && content.parsed !== null) {
            return content.parsed;
          }
        }
      }
      return null;
    }
  });
  return parsed;
}
__name(parseResponse, "parseResponse");
function parseTextFormat(params, content) {
  if (params.text?.format?.type !== "json_schema") {
    return null;
  }
  if ("$parseRaw" in params.text?.format) {
    const text_format = params.text?.format;
    return text_format.$parseRaw(content);
  }
  return JSON.parse(content);
}
__name(parseTextFormat, "parseTextFormat");
function hasAutoParseableInput2(params) {
  if (isAutoParsableResponseFormat(params.text?.format)) {
    return true;
  }
  return false;
}
__name(hasAutoParseableInput2, "hasAutoParseableInput");
function isAutoParsableTool2(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
__name(isAutoParsableTool2, "isAutoParsableTool");
function getInputToolByName(input_tools, name) {
  return input_tools.find((tool) => tool.type === "function" && tool.name === name);
}
__name(getInputToolByName, "getInputToolByName");
function parseToolCall2(params, toolCall) {
  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
  return {
    ...toolCall,
    ...toolCall,
    parsed_arguments: isAutoParsableTool2(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : inputTool?.strict ? JSON.parse(toolCall.arguments) : null
  };
}
__name(parseToolCall2, "parseToolCall");
function addOutputText(rsp) {
  const texts = [];
  for (const output of rsp.output) {
    if (output.type !== "message") {
      continue;
    }
    for (const content of output.content) {
      if (content.type === "output_text") {
        texts.push(content.text);
      }
    }
  }
  rsp.output_text = texts.join("");
}
__name(addOutputText, "addOutputText");

// node_modules/openai/lib/responses/ResponseStream.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var _ResponseStream_instances;
var _ResponseStream_params;
var _ResponseStream_currentResponseSnapshot;
var _ResponseStream_finalResponse;
var _ResponseStream_beginRequest;
var _ResponseStream_addEvent;
var _ResponseStream_endRequest;
var _ResponseStream_accumulateResponse;
var ResponseStream = class _ResponseStream extends EventStream {
  static {
    __name(this, "ResponseStream");
  }
  constructor(params) {
    super();
    _ResponseStream_instances.add(this);
    _ResponseStream_params.set(this, void 0);
    _ResponseStream_currentResponseSnapshot.set(this, void 0);
    _ResponseStream_finalResponse.set(this, void 0);
    __classPrivateFieldSet(this, _ResponseStream_params, params, "f");
  }
  static createResponse(client, params, options) {
    const runner = new _ResponseStream(params);
    runner._run(() => runner._createOrRetrieveResponse(client, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createOrRetrieveResponse(client, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_beginRequest).call(this);
    let stream;
    let starting_after = null;
    if ("response_id" in params) {
      stream = await client.responses.retrieve(params.response_id, { stream: true }, { ...options, signal: this.controller.signal, stream: true });
      starting_after = params.starting_after ?? null;
    } else {
      stream = await client.responses.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    }
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_addEvent).call(this, event, starting_after);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_endRequest).call(this);
  }
  [(_ResponseStream_params = /* @__PURE__ */ new WeakMap(), _ResponseStream_currentResponseSnapshot = /* @__PURE__ */ new WeakMap(), _ResponseStream_finalResponse = /* @__PURE__ */ new WeakMap(), _ResponseStream_instances = /* @__PURE__ */ new WeakSet(), _ResponseStream_beginRequest = /* @__PURE__ */ __name(function _ResponseStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
  }, "_ResponseStream_beginRequest"), _ResponseStream_addEvent = /* @__PURE__ */ __name(function _ResponseStream_addEvent2(event, starting_after) {
    if (this.ended)
      return;
    const maybeEmit = /* @__PURE__ */ __name((name, event2) => {
      if (starting_after == null || event2.sequence_number > starting_after) {
        this._emit(name, event2);
      }
    }, "maybeEmit");
    const response = __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_accumulateResponse).call(this, event);
    maybeEmit("event", event);
    switch (event.type) {
      case "response.output_text.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          maybeEmit("response.output_text.delta", {
            ...event,
            snapshot: content.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          maybeEmit("response.function_call_arguments.delta", {
            ...event,
            snapshot: output.arguments
          });
        }
        break;
      }
      default:
        maybeEmit(event.type, event);
        break;
    }
  }, "_ResponseStream_addEvent"), _ResponseStream_endRequest = /* @__PURE__ */ __name(function _ResponseStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any events`);
    }
    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
    const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet(this, _ResponseStream_params, "f"));
    __classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse, "f");
    return parsedResponse;
  }, "_ResponseStream_endRequest"), _ResponseStream_accumulateResponse = /* @__PURE__ */ __name(function _ResponseStream_accumulateResponse2(event) {
    let snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      if (event.type !== "response.created") {
        throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);
      }
      snapshot = __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
      return snapshot;
    }
    switch (event.type) {
      case "response.output_item.added": {
        snapshot.output.push(event.item);
        break;
      }
      case "response.content_part.added": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        const type = output.type;
        const part = event.part;
        if (type === "message" && part.type !== "reasoning_text") {
          output.content.push(part);
        } else if (type === "reasoning" && part.type === "reasoning_text") {
          if (!output.content) {
            output.content = [];
          }
          output.content.push(part);
        }
        break;
      }
      case "response.output_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          output.arguments += event.delta;
        }
        break;
      }
      case "response.reasoning_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "reasoning") {
          const content = output.content?.[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "reasoning_text") {
            throw new OpenAIError(`expected content to be 'reasoning_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.completed": {
        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
        break;
      }
    }
    return snapshot;
  }, "_ResponseStream_accumulateResponse"), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: /* @__PURE__ */ __name(async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject2) => readQueue.push({ resolve, reject: reject2 })).then((event2) => event2 ? { value: event2, done: false } : { value: void 0, done: true });
        }
        const event = pushQueue.shift();
        return { value: event, done: false };
      }, "next"),
      return: /* @__PURE__ */ __name(async () => {
        this.abort();
        return { value: void 0, done: true };
      }, "return")
    };
  }
  /**
   * @returns a promise that resolves with the final Response, or rejects
   * if an error occurred or the stream ended prematurely without producing a REsponse.
   */
  async finalResponse() {
    await this.done();
    const response = __classPrivateFieldGet(this, _ResponseStream_finalResponse, "f");
    if (!response)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return response;
  }
};
function finalizeResponse(snapshot, params) {
  return maybeParseResponse(snapshot, params);
}
__name(finalizeResponse, "finalizeResponse");

// node_modules/openai/resources/responses/input-items.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var InputItems = class extends APIResource {
  static {
    __name(this, "InputItems");
  }
  /**
   * Returns a list of input items for a given response.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const responseItem of client.responses.inputItems.list(
   *   'response_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(responseID, query = {}, options) {
    return this._client.getAPIList(path3`/responses/${responseID}/input_items`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/resources/responses/responses.mjs
var Responses = class extends APIResource {
  static {
    __name(this, "Responses");
  }
  constructor() {
    super(...arguments);
    this.inputItems = new InputItems(this._client);
  }
  create(body, options) {
    return this._client.post("/responses", { body, ...options, stream: body.stream ?? false })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  retrieve(responseID, query = {}, options) {
    return this._client.get(path3`/responses/${responseID}`, {
      query,
      ...options,
      stream: query?.stream ?? false
    })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  /**
   * Deletes a model response with the given ID.
   *
   * @example
   * ```ts
   * await client.responses.delete(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  delete(responseID, options) {
    return this._client.delete(path3`/responses/${responseID}`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  parse(body, options) {
    return this._client.responses.create(body, options)._thenUnwrap((response) => parseResponse(response, body));
  }
  /**
   * Creates a model response stream
   */
  stream(body, options) {
    return ResponseStream.createResponse(this._client, body, options);
  }
  /**
   * Cancels a model response with the given ID. Only responses created with the
   * `background` parameter set to `true` can be cancelled.
   * [Learn more](https://platform.openai.com/docs/guides/background).
   *
   * @example
   * ```ts
   * const response = await client.responses.cancel(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  cancel(responseID, options) {
    return this._client.post(path3`/responses/${responseID}/cancel`, options);
  }
};
Responses.InputItems = InputItems;

// node_modules/openai/resources/uploads/uploads.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/uploads/parts.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Parts = class extends APIResource {
  static {
    __name(this, "Parts");
  }
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(uploadID, body, options) {
    return this._client.post(path3`/uploads/${uploadID}/parts`, multipartFormRequestOptions({ body, ...options }, this._client));
  }
};

// node_modules/openai/resources/uploads/uploads.mjs
var Uploads = class extends APIResource {
  static {
    __name(this, "Uploads");
  }
  constructor() {
    super(...arguments);
    this.parts = new Parts(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified. Please
   * refer to documentation for the
   * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(body, options) {
    return this._client.post("/uploads", { body, ...options });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(uploadID, options) {
    return this._client.post(path3`/uploads/${uploadID}/cancel`, options);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(uploadID, body, options) {
    return this._client.post(path3`/uploads/${uploadID}/complete`, { body, ...options });
  }
};
Uploads.Parts = Parts;

// node_modules/openai/resources/vector-stores/vector-stores.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/resources/vector-stores/file-batches.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/openai/lib/Util.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var allSettledWithThrow = /* @__PURE__ */ __name(async (promises) => {
  const results = await Promise.allSettled(promises);
  const rejected = results.filter((result) => result.status === "rejected");
  if (rejected.length) {
    for (const result of rejected) {
      console.error(result.reason);
    }
    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
  }
  const values = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      values.push(result.value);
    }
  }
  return values;
}, "allSettledWithThrow");

// node_modules/openai/resources/vector-stores/file-batches.mjs
var FileBatches = class extends APIResource {
  static {
    __name(this, "FileBatches");
  }
  /**
   * Create a vector store file batch.
   */
  create(vectorStoreID, body, options) {
    return this._client.post(path3`/vector_stores/${vectorStoreID}/file_batches`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(batchID, params, options) {
    const { vector_store_id } = params;
    return this._client.get(path3`/vector_stores/${vector_store_id}/file_batches/${batchID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(batchID, params, options) {
    const { vector_store_id } = params;
    return this._client.post(path3`/vector_stores/${vector_store_id}/file_batches/${batchID}/cancel`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const batch = await this.create(vectorStoreId, body);
    return await this.poll(vectorStoreId, batch.id, options);
  }
  /**
   * Returns a list of vector store files in a batch.
   */
  listFiles(batchID, params, options) {
    const { vector_store_id, ...query } = params;
    return this._client.getAPIList(path3`/vector_stores/${vector_store_id}/file_batches/${batchID}/files`, CursorPage, { query, ...options, headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]) });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(vectorStoreID, batchID, options) {
    const headers = buildHeaders([
      options?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? void 0
      }
    ]);
    while (true) {
      const { data: batch, response } = await this.retrieve(batchID, { vector_store_id: vectorStoreID }, {
        ...options,
        headers
      }).withResponse();
      switch (batch.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return batch;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
    if (files == null || files.length == 0) {
      throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
    }
    const configuredConcurrency = options?.maxConcurrency ?? 5;
    const concurrencyLimit = Math.min(configuredConcurrency, files.length);
    const client = this._client;
    const fileIterator = files.values();
    const allFileIds = [...fileIds];
    async function processFiles(iterator) {
      for (let item of iterator) {
        const fileObj = await client.files.create({ file: item, purpose: "assistants" }, options);
        allFileIds.push(fileObj.id);
      }
    }
    __name(processFiles, "processFiles");
    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
    await allSettledWithThrow(workers);
    return await this.createAndPoll(vectorStoreId, {
      file_ids: allFileIds
    });
  }
};

// node_modules/openai/resources/vector-stores/files.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Files3 = class extends APIResource {
  static {
    __name(this, "Files");
  }
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(vectorStoreID, body, options) {
    return this._client.post(path3`/vector_stores/${vectorStoreID}/files`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.get(path3`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Update attributes on a vector store file.
   */
  update(fileID, params, options) {
    const { vector_store_id, ...body } = params;
    return this._client.post(path3`/vector_stores/${vector_store_id}/files/${fileID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of vector store files.
   */
  list(vectorStoreID, query = {}, options) {
    return this._client.getAPIList(path3`/vector_stores/${vectorStoreID}/files`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  delete(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.delete(path3`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const file = await this.create(vectorStoreId, body, options);
    return await this.poll(vectorStoreId, file.id, options);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(vectorStoreID, fileID, options) {
    const headers = buildHeaders([
      options?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? void 0
      }
    ]);
    while (true) {
      const fileResponse = await this.retrieve(fileID, {
        vector_store_id: vectorStoreID
      }, { ...options, headers }).withResponse();
      const file = fileResponse.data;
      switch (file.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "failed":
        case "completed":
          return file;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(vectorStoreId, file, options) {
    const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
    return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(vectorStoreId, file, options) {
    const fileInfo = await this.upload(vectorStoreId, file, options);
    return await this.poll(vectorStoreId, fileInfo.id, options);
  }
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  content(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.getAPIList(path3`/vector_stores/${vector_store_id}/files/${fileID}/content`, Page, { ...options, headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]) });
  }
};

// node_modules/openai/resources/vector-stores/vector-stores.mjs
var VectorStores = class extends APIResource {
  static {
    __name(this, "VectorStores");
  }
  constructor() {
    super(...arguments);
    this.files = new Files3(this._client);
    this.fileBatches = new FileBatches(this._client);
  }
  /**
   * Create a vector store.
   */
  create(body, options) {
    return this._client.post("/vector_stores", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(vectorStoreID, options) {
    return this._client.get(path3`/vector_stores/${vectorStoreID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Modifies a vector store.
   */
  update(vectorStoreID, body, options) {
    return this._client.post(path3`/vector_stores/${vectorStoreID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of vector stores.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/vector_stores", CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Delete a vector store.
   */
  delete(vectorStoreID, options) {
    return this._client.delete(path3`/vector_stores/${vectorStoreID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Search a vector store for relevant chunks based on a query and file attributes
   * filter.
   */
  search(vectorStoreID, body, options) {
    return this._client.getAPIList(path3`/vector_stores/${vectorStoreID}/search`, Page, {
      body,
      method: "post",
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};
VectorStores.Files = Files3;
VectorStores.FileBatches = FileBatches;

// node_modules/openai/resources/videos.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Videos = class extends APIResource {
  static {
    __name(this, "Videos");
  }
  /**
   * Create a video
   */
  create(body, options) {
    return this._client.post("/videos", maybeMultipartFormRequestOptions({ body, ...options }, this._client));
  }
  /**
   * Retrieve a video
   */
  retrieve(videoID, options) {
    return this._client.get(path3`/videos/${videoID}`, options);
  }
  /**
   * List videos
   */
  list(query = {}, options) {
    return this._client.getAPIList("/videos", ConversationCursorPage, { query, ...options });
  }
  /**
   * Delete a video
   */
  delete(videoID, options) {
    return this._client.delete(path3`/videos/${videoID}`, options);
  }
  /**
   * Download video content
   */
  downloadContent(videoID, query = {}, options) {
    return this._client.get(path3`/videos/${videoID}/content`, {
      query,
      ...options,
      headers: buildHeaders([{ Accept: "application/binary" }, options?.headers]),
      __binaryResponse: true
    });
  }
  /**
   * Create a video remix
   */
  remix(videoID, body, options) {
    return this._client.post(path3`/videos/${videoID}/remix`, maybeMultipartFormRequestOptions({ body, ...options }, this._client));
  }
};

// node_modules/openai/resources/webhooks.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var _Webhooks_instances;
var _Webhooks_validateSecret;
var _Webhooks_getRequiredHeader;
var Webhooks = class extends APIResource {
  static {
    __name(this, "Webhooks");
  }
  constructor() {
    super(...arguments);
    _Webhooks_instances.add(this);
  }
  /**
   * Validates that the given payload was sent by OpenAI and parses the payload.
   */
  async unwrap(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    await this.verifySignature(payload, headers, secret, tolerance);
    return JSON.parse(payload);
  }
  /**
   * Validates whether or not the webhook payload was sent by OpenAI.
   *
   * An error will be raised if the webhook payload was not sent by OpenAI.
   *
   * @param payload - The webhook payload
   * @param headers - The webhook headers
   * @param secret - The webhook secret (optional, will use client secret if not provided)
   * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)
   */
  async verifySignature(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    if (typeof crypto === "undefined" || typeof crypto.subtle.importKey !== "function" || typeof crypto.subtle.verify !== "function") {
      throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");
    }
    __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_validateSecret).call(this, secret);
    const headersObj = buildHeaders([headers]).values;
    const signatureHeader = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-signature");
    const timestamp = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-timestamp");
    const webhookId = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-id");
    const timestampSeconds = parseInt(timestamp, 10);
    if (isNaN(timestampSeconds)) {
      throw new InvalidWebhookSignatureError("Invalid webhook timestamp format");
    }
    const nowSeconds = Math.floor(Date.now() / 1e3);
    if (nowSeconds - timestampSeconds > tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too old");
    }
    if (timestampSeconds > nowSeconds + tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too new");
    }
    const signatures = signatureHeader.split(" ").map((part) => part.startsWith("v1,") ? part.substring(3) : part);
    const decodedSecret = secret.startsWith("whsec_") ? Buffer.from(secret.replace("whsec_", ""), "base64") : Buffer.from(secret, "utf-8");
    const signedPayload = webhookId ? `${webhookId}.${timestamp}.${payload}` : `${timestamp}.${payload}`;
    const key = await crypto.subtle.importKey("raw", decodedSecret, { name: "HMAC", hash: "SHA-256" }, false, ["verify"]);
    for (const signature of signatures) {
      try {
        const signatureBytes = Buffer.from(signature, "base64");
        const isValid2 = await crypto.subtle.verify("HMAC", key, signatureBytes, new TextEncoder().encode(signedPayload));
        if (isValid2) {
          return;
        }
      } catch {
        continue;
      }
    }
    throw new InvalidWebhookSignatureError("The given webhook signature does not match the expected signature");
  }
};
_Webhooks_instances = /* @__PURE__ */ new WeakSet(), _Webhooks_validateSecret = /* @__PURE__ */ __name(function _Webhooks_validateSecret2(secret) {
  if (typeof secret !== "string" || secret.length === 0) {
    throw new Error(`The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function`);
  }
}, "_Webhooks_validateSecret"), _Webhooks_getRequiredHeader = /* @__PURE__ */ __name(function _Webhooks_getRequiredHeader2(headers, name) {
  if (!headers) {
    throw new Error(`Headers are required`);
  }
  const value = headers.get(name);
  if (value === null || value === void 0) {
    throw new Error(`Missing required header: ${name}`);
  }
  return value;
}, "_Webhooks_getRequiredHeader");

// node_modules/openai/client.mjs
var _OpenAI_instances;
var _a3;
var _OpenAI_encoder;
var _OpenAI_baseURLOverridden;
var OpenAI = class {
  static {
    __name(this, "OpenAI");
  }
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string | null | undefined} [opts.webhookSecret=process.env['OPENAI_WEBHOOK_SECRET'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = readEnv("OPENAI_ORG_ID") ?? null, project = readEnv("OPENAI_PROJECT_ID") ?? null, webhookSecret = readEnv("OPENAI_WEBHOOK_SECRET") ?? null, ...opts } = {}) {
    _OpenAI_instances.add(this);
    _OpenAI_encoder.set(this, void 0);
    this.completions = new Completions2(this);
    this.chat = new Chat(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files2(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.graders = new Graders2(this);
    this.vectorStores = new VectorStores(this);
    this.webhooks = new Webhooks(this);
    this.beta = new Beta(this);
    this.batches = new Batches(this);
    this.uploads = new Uploads(this);
    this.responses = new Responses(this);
    this.realtime = new Realtime2(this);
    this.conversations = new Conversations(this);
    this.evals = new Evals(this);
    this.containers = new Containers(this);
    this.videos = new Videos(this);
    if (apiKey === void 0) {
      throw new OpenAIError("Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable.");
    }
    const options = {
      apiKey,
      organization,
      project,
      webhookSecret,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    this.baseURL = options.baseURL;
    this.timeout = options.timeout ?? _a3.DEFAULT_TIMEOUT;
    this.logger = options.logger ?? console;
    const defaultLogLevel = "warn";
    this.logLevel = defaultLogLevel;
    this.logLevel = parseLogLevel(options.logLevel, "ClientOptions.logLevel", this) ?? parseLogLevel(readEnv("OPENAI_LOG"), "process.env['OPENAI_LOG']", this) ?? defaultLogLevel;
    this.fetchOptions = options.fetchOptions;
    this.maxRetries = options.maxRetries ?? 2;
    this.fetch = options.fetch ?? getDefaultFetch();
    __classPrivateFieldSet(this, _OpenAI_encoder, FallbackEncoder, "f");
    this._options = options;
    this.apiKey = typeof apiKey === "string" ? apiKey : "Missing Key";
    this.organization = organization;
    this.project = project;
    this.webhookSecret = webhookSecret;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(options) {
    const client = new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      organization: this.organization,
      project: this.project,
      webhookSecret: this.webhookSecret,
      ...options
    });
    return client;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values, nulls }) {
    return;
  }
  async authHeaders(opts) {
    return buildHeaders([{ Authorization: `Bearer ${this.apiKey}` }]);
  }
  stringifyQuery(query) {
    return stringify2(query, { arrayFormat: "brackets" });
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION2}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  makeStatusError(status, error4, message, headers) {
    return APIError.generate(status, error4, message, headers);
  }
  async _callApiKey() {
    const apiKey = this._options.apiKey;
    if (typeof apiKey !== "function")
      return false;
    let token;
    try {
      token = await apiKey();
    } catch (err) {
      if (err instanceof OpenAIError)
        throw err;
      throw new OpenAIError(
        `Failed to get token from 'apiKey' function: ${err.message}`,
        // @ts-ignore
        { cause: err }
      );
    }
    if (typeof token !== "string" || !token) {
      throw new OpenAIError(`Expected 'apiKey' function argument to return a string but it returned ${token}`);
    }
    this.apiKey = token;
    return true;
  }
  buildURL(path4, query, defaultBaseURL) {
    const baseURL = !__classPrivateFieldGet(this, _OpenAI_instances, "m", _OpenAI_baseURLOverridden).call(this) && defaultBaseURL || this.baseURL;
    const url = isAbsoluteURL(path4) ? new URL(path4) : new URL(baseURL + (baseURL.endsWith("/") && path4.startsWith("/") ? path4.slice(1) : path4));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
    await this._callApiKey();
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  get(path4, opts) {
    return this.methodRequest("get", path4, opts);
  }
  post(path4, opts) {
    return this.methodRequest("post", path4, opts);
  }
  patch(path4, opts) {
    return this.methodRequest("patch", path4, opts);
  }
  put(path4, opts) {
    return this.methodRequest("put", path4, opts);
  }
  delete(path4, opts) {
    return this.methodRequest("delete", path4, opts);
  }
  methodRequest(method, path4, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => {
      return { method, path: path4, ...opts2 };
    }));
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this, this.makeRequest(options, remainingRetries, void 0));
  }
  async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = await this.buildRequest(options, {
      retryCount: maxRetries - retriesRemaining
    });
    await this.prepareRequest(req, { url, options });
    const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
    const retryLogStr = retryOfRequestLogID === void 0 ? "" : `, retryOf: ${retryOfRequestLogID}`;
    const startTime = Date.now();
    loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({
      retryOfRequestLogID,
      method: options.method,
      url,
      options,
      headers: req.headers
    }));
    if (options.signal?.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    const headersTime = Date.now();
    if (response instanceof globalThis.Error) {
      const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
      if (options.signal?.aborted) {
        throw new APIUserAbortError();
      }
      const isTimeout = isAbortError(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
      if (retriesRemaining) {
        loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
        loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails({
          retryOfRequestLogID,
          url,
          durationMs: headersTime - startTime,
          message: response.message
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);
      }
      loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
      loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails({
        retryOfRequestLogID,
        url,
        durationMs: headersTime - startTime,
        message: response.message
      }));
      if (isTimeout) {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const specialHeaders = [...response.headers.entries()].filter(([name]) => name === "x-request-id").map(([name, value]) => ", " + name + ": " + JSON.stringify(value)).join("");
    const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
    if (!response.ok) {
      const shouldRetry = await this.shouldRetry(response);
      if (retriesRemaining && shouldRetry) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        await CancelReadableStream(response.body);
        loggerFor(this).info(`${responseInfo} - ${retryMessage2}`);
        loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
      }
      const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
      loggerFor(this).info(`${responseInfo} - ${retryMessage}`);
      const errText = await response.text().catch((err2) => castToError(err2).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({
        retryOfRequestLogID,
        url: response.url,
        status: response.status,
        headers: response.headers,
        message: errMessage,
        durationMs: Date.now() - startTime
      }));
      const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
      throw err;
    }
    loggerFor(this).info(responseInfo);
    loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({
      retryOfRequestLogID,
      url: response.url,
      status: response.status,
      headers: response.headers,
      durationMs: headersTime - startTime
    }));
    return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
  }
  getAPIList(path4, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path: path4, ...opts });
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null, void 0);
    return new PagePromise(this, request, Page2);
  }
  async fetchWithTimeout(url, init2, ms, controller) {
    const { signal, method, ...options } = init2 || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
    const fetchOptions = {
      signal: controller.signal,
      ...isReadableBody ? { duplex: "half" } : {},
      method: "GET",
      ...options
    };
    if (method) {
      fetchOptions.method = method.toUpperCase();
    }
    try {
      return await this.fetch.call(void 0, url, fetchOptions);
    } finally {
      clearTimeout(timeout);
    }
  }
  async shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.get("retry-after-ms");
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.get("retry-after");
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1, requestLogID);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  async buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options = { ...inputOptions };
    const { method, path: path4, query, defaultBaseURL } = options;
    const url = this.buildURL(path4, query, defaultBaseURL);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const { bodyHeaders, body } = this.buildBody({ options });
    const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
    const req = {
      method,
      headers: reqHeaders,
      ...options.signal && { signal: options.signal },
      ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
      ...body && { body },
      ...this.fetchOptions ?? {},
      ...options.fetchOptions ?? {}
    };
    return { req, url, timeout: options.timeout };
  }
  async buildHeaders({ options, method, bodyHeaders, retryCount }) {
    let idempotencyHeaders = {};
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
    }
    const headers = buildHeaders([
      idempotencyHeaders,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(retryCount),
        ...options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1e3)) } : {},
        ...getPlatformHeaders(),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project
      },
      await this.authHeaders(options),
      this._options.defaultHeaders,
      bodyHeaders,
      options.headers
    ]);
    this.validateHeaders(headers);
    return headers.values;
  }
  buildBody({ options: { body, headers: rawHeaders } }) {
    if (!body) {
      return { bodyHeaders: void 0, body: void 0 };
    }
    const headers = buildHeaders([rawHeaders]);
    if (
      // Pass raw type verbatim
      ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && // Preserve legacy string encoding behavior for now
      headers.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && body instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && body instanceof globalThis.ReadableStream
    ) {
      return { bodyHeaders: void 0, body };
    } else if (typeof body === "object" && (Symbol.asyncIterator in body || Symbol.iterator in body && "next" in body && typeof body.next === "function")) {
      return { bodyHeaders: void 0, body: ReadableStreamFrom(body) };
    } else {
      return __classPrivateFieldGet(this, _OpenAI_encoder, "f").call(this, { body, headers });
    }
  }
};
_a3 = OpenAI, _OpenAI_encoder = /* @__PURE__ */ new WeakMap(), _OpenAI_instances = /* @__PURE__ */ new WeakSet(), _OpenAI_baseURLOverridden = /* @__PURE__ */ __name(function _OpenAI_baseURLOverridden2() {
  return this.baseURL !== "https://api.openai.com/v1";
}, "_OpenAI_baseURLOverridden");
OpenAI.OpenAI = _a3;
OpenAI.DEFAULT_TIMEOUT = 6e5;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
OpenAI.InvalidWebhookSignatureError = InvalidWebhookSignatureError;
OpenAI.toFile = toFile;
OpenAI.Completions = Completions2;
OpenAI.Chat = Chat;
OpenAI.Embeddings = Embeddings;
OpenAI.Files = Files2;
OpenAI.Images = Images;
OpenAI.Audio = Audio;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models;
OpenAI.FineTuning = FineTuning;
OpenAI.Graders = Graders2;
OpenAI.VectorStores = VectorStores;
OpenAI.Webhooks = Webhooks;
OpenAI.Beta = Beta;
OpenAI.Batches = Batches;
OpenAI.Uploads = Uploads;
OpenAI.Responses = Responses;
OpenAI.Realtime = Realtime2;
OpenAI.Conversations = Conversations;
OpenAI.Evals = Evals;
OpenAI.Containers = Containers;
OpenAI.Videos = Videos;

// node_modules/openai/azure.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/index.ts
async function runTracingExample(env2, ctx) {
  await login({
    apiKey: env2.BRAINTRUST_API_KEY
  });
  const logger = initLogger({
    projectName: "cloudflare-worker-tracing",
    apiKey: env2.BRAINTRUST_API_KEY,
    asyncFlush: true
  });
  const getCurrentWeather = wrapTraced(async (location, unit = "fahrenheit") => {
    const weatherData = {
      "San Francisco": { temperature: 68, condition: "sunny" },
      "Tokyo": { temperature: 75, condition: "cloudy" },
      "Paris": { temperature: 55, condition: "rainy" }
    };
    const data = weatherData[location] || { temperature: 70, condition: "unknown" };
    return JSON.stringify({
      location,
      temperature: data.temperature,
      unit,
      condition: data.condition
    });
  }, { name: "getCurrentWeather" });
  const searchDatabase = wrapTraced(async (query) => {
    const results = {
      "python": ["Python is a high-level programming language", "Created by Guido van Rossum"],
      "typescript": ["TypeScript is a superset of JavaScript", "Developed by Microsoft"]
    };
    const matches = results[query.toLowerCase()] || ["No results found"];
    return JSON.stringify({ query, results: matches });
  }, { name: "searchDatabase" });
  const client = wrapOpenAI(
    new OpenAI({
      apiKey: env2.OPENAI_API_KEY
    })
  );
  const result = await logger.traced(async (span) => {
    span.log({
      input: "User asks about weather in San Francisco and information about Python"
    });
    const weatherResponse = await client.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "user",
          content: "What's the weather like in San Francisco?"
        }
      ],
      tools: [
        {
          type: "function",
          function: {
            name: "getCurrentWeather",
            description: "Get the current weather in a given location",
            parameters: {
              type: "object",
              properties: {
                location: {
                  type: "string",
                  description: "The city name, e.g. San Francisco"
                },
                unit: {
                  type: "string",
                  enum: ["celsius", "fahrenheit"]
                }
              },
              required: ["location"]
            }
          }
        }
      ],
      tool_choice: "auto"
    });
    let weatherResult = "";
    const weatherMessage = weatherResponse.choices[0].message;
    if (weatherMessage.tool_calls) {
      const toolCall = weatherMessage.tool_calls[0];
      const functionArgs = JSON.parse(toolCall.function.arguments);
      const functionResult = await getCurrentWeather(
        functionArgs.location,
        functionArgs.unit
      );
      weatherResult = functionResult;
      const followUpResponse = await client.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [
          {
            role: "user",
            content: "What's the weather like in San Francisco?"
          },
          weatherMessage,
          {
            role: "tool",
            tool_call_id: toolCall.id,
            content: functionResult
          }
        ]
      });
      weatherResult = followUpResponse.choices[0].message.content || "";
    }
    const searchResponse = await client.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "user",
          content: "Tell me about Python programming language"
        }
      ],
      tools: [
        {
          type: "function",
          function: {
            name: "searchDatabase",
            description: "Search the knowledge database",
            parameters: {
              type: "object",
              properties: {
                query: {
                  type: "string",
                  description: "The search query"
                }
              },
              required: ["query"]
            }
          }
        }
      ]
    });
    let searchResult = "";
    const searchMessage = searchResponse.choices[0].message;
    if (searchMessage.tool_calls) {
      const toolCall = searchMessage.tool_calls[0];
      const functionArgs = JSON.parse(toolCall.function.arguments);
      const functionResult = await searchDatabase(functionArgs.query);
      searchResult = functionResult;
      const finalResponse = await client.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [
          {
            role: "user",
            content: "Tell me about Python programming language"
          },
          searchMessage,
          {
            role: "tool",
            tool_call_id: toolCall.id,
            content: functionResult
          }
        ]
      });
      searchResult = finalResponse.choices[0].message.content || "";
    }
    const output = {
      weather: weatherResult,
      search: searchResult
    };
    span.log({ output });
    return output;
  });
  const flushPromise = logger.flush();
  ctx.waitUntil(flushPromise);
  return result;
}
__name(runTracingExample, "runTracingExample");
async function runEval(env2) {
  await login({
    apiKey: env2.BRAINTRUST_API_KEY
  });
  const result = await Eval("cloudflare-worker-eval", {
    data: /* @__PURE__ */ __name(() => [
      { input: "What is 2+2?", expected: "4" },
      { input: "What is the capital of France?", expected: "Paris" },
      { input: "What color is the sky?", expected: "blue" }
    ], "data"),
    task: /* @__PURE__ */ __name(async (input) => {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${env2.OPENAI_API_KEY}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          messages: [
            {
              role: "system",
              content: "You are a helpful assistant. Answer questions concisely."
            },
            {
              role: "user",
              content: input
            }
          ],
          temperature: 0
        })
      });
      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.statusText}`);
      }
      const data = await response.json();
      return data.choices[0].message.content;
    }, "task"),
    scores: [
      (output, expected) => {
        const outputLower = output?.toLowerCase() || "";
        const expectedLower = expected?.expected?.toLowerCase() || "";
        return {
          name: "contains_expected",
          score: outputLower.includes(expectedLower) ? 1 : 0
        };
      }
    ]
  });
  return result;
}
__name(runEval, "runEval");
var index_default = {
  async fetch(request, env2, ctx) {
    const url = new URL(request.url);
    if (url.pathname === "/trace") {
      try {
        const result = await runTracingExample(env2, ctx);
        return new Response(
          JSON.stringify({
            success: true,
            result
          }),
          {
            headers: { "Content-Type": "application/json" }
          }
        );
      } catch (error4) {
        return new Response(
          JSON.stringify({
            success: false,
            error: error4 instanceof Error ? error4.message : String(error4),
            stack: error4 instanceof Error ? error4.stack : void 0
          }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" }
          }
        );
      }
    }
    if (url.pathname === "/run-eval") {
      try {
        const result = await runEval(env2);
        return new Response(
          JSON.stringify({
            success: true,
            summary: result.summary,
            results: result.results
          }),
          {
            headers: { "Content-Type": "application/json" }
          }
        );
      } catch (error4) {
        return new Response(
          JSON.stringify({
            success: false,
            error: error4 instanceof Error ? error4.message : String(error4),
            debug: {
              envKeys: Object.keys(env2),
              hasBraintrustKey: "BRAINTRUST_API_KEY" in env2,
              braintrustKeyType: typeof env2.BRAINTRUST_API_KEY,
              braintrustKeyLength: env2.BRAINTRUST_API_KEY?.length,
              braintrustKeyPrefix: env2.BRAINTRUST_API_KEY?.substring(0, 10)
            }
          }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" }
          }
        );
      }
    }
    return new Response(
      JSON.stringify({
        message: "Braintrust Eval Worker",
        endpoints: {
          "/trace": "Run tracing example with OpenAI tool calls",
          "/run-eval": "Run the evaluation"
        }
      }),
      {
        headers: { "Content-Type": "application/json" }
      }
    );
  },
  async scheduled(event, env2, ctx) {
    ctx.waitUntil(runEval(env2));
  }
};
export {
  index_default as default
};
/*! Bundled license information:

mustache/mustache.mjs:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)
*/
//# sourceMappingURL=index.js.map
